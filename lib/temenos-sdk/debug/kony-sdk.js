/* FilePath: lib/konyinit.js */
/* Version: 202305.0.0 */
/* TimeStamp: Fri Apr 14 2023 18:32:27 */
/* global initializeApp */
/* global requirejs */

//Pollyfill starts
if(!String.prototype.startsWith) {
    String.prototype.startsWith = function(str) {
        return this.slice(0, str.length) === str;
    };
}


//pollyfill ends

(function() {

    // DESKTOPWEB CODE ONLY  - JS PREPROCESSOR



    function initializeLocalStorage() {
        var $K = kony.$kwebfw$, $KA = $K.app, store = null;

        if(typeof(localStorage) === 'object') {
            store = localStorage.getItem($KA.id);

            if(!(typeof store === 'string' && store)) {
                store = {migrated: true, store: [], ds: [], ns: {}};
                localStorage.setItem($KA.id, JSON.stringify(store));
            }
        }
    }


    Object.defineProperty(window, 'kony', {configurable:false, enumerable:false, writable:false, value:(function() {
        var _ns = {}, _props = null, _def = function(obj, items) {
                var i = 0, ilen = (items instanceof Array) ? items.length : 0;

                for(i=0; i<ilen; i++) {
                    (function(target, item) {
                        item.writable = _defWritable(item.writable);

                        //NOTE:: When a function scope is changed using bind API.
                        //Then that new function does not contain "prototype" property
                        if(typeof item.value === 'function') {
                            item.value.toLocaleString = item.value.__proto__.toLocaleString;
                            item.value.toSource = item.value.__proto__.toSource;
                            item.value.toString = item.value.__proto__.toString;
                        }

                        Object.defineProperty(target, item.keey, {
                            configurable: false,
                            enumerable: false,
                            value: item.value,
                            writable: item.writable
                        });

                        if(item.items && item.items.length) {
                            _def(item.value, item.items);
                        }
                    }(obj, items[i]));
                }
            }, _defWritable = function(writable) {
                if(typeof writable !== 'boolean') {
                    writable = false;
                }

                return writable;
            };

        _props = [
            {keey:'$kwebfw$', value:{}, items:[
                {keey:'app', value:{}, items:[
                    {keey:'id', value:'', writable:true}
                ]},
                {keey:'behavior', value:{}},
                {keey:'defKonyProp', value:_def},
                {keey:'defWritable', value:_defWritable},
                {keey:'device', value:{}, items:[
                    {keey:'DPI', value:1}, //window.devicePixelRatio
                    {keey:'height', value:-1, writable:true},
                    {keey:'width', value:-1, writable:true}
                ]},
                {keey:'globals', value:{}, items:[
                    {keey:'kof', value: {}, writable: true}
                ]}
            ]}
        ]; _def(_ns, _props);
        return _ns;
    }())});

    initializeLocalStorage();

}());

/* FilePath: jslib/tparty/crypto/cryptojslib.js */
/* Version: 202305.0.0 */
/* TimeStamp: Fri Apr 14 2023 18:32:27 */
/*
CryptoJS v3.1.2
code.google.com/p/crypto-js
(c) 2009-2013 by Jeff Mott. All rights reserved.
code.google.com/p/crypto-js/wiki/License
*/

//AES Algo (aes.js)
var CryptoJS = CryptoJS || function (u, p) {
    var d = {}, l = d.lib = {}, s = function () { }, t = l.Base = { extend: function (a) { s.prototype = this; var c = new s; a && c.mixIn(a); c.hasOwnProperty("init") || (c.init = function () { c.$super.init.apply(this, arguments) }); c.init.prototype = c; c.$super = this; return c }, create: function () { var a = this.extend(); a.init.apply(a, arguments); return a }, init: function () { }, mixIn: function (a) { for (var c in a) a.hasOwnProperty(c) && (this[c] = a[c]); a.hasOwnProperty("toString") && (this.toString = a.toString) }, clone: function () { return this.init.prototype.extend(this) } },
    r = l.WordArray = t.extend({
        init: function (a, c) { a = this.words = a || []; this.sigBytes = c != p ? c : 4 * a.length }, toString: function (a) { return (a || v).stringify(this) }, concat: function (a) { var c = this.words, e = a.words, j = this.sigBytes; a = a.sigBytes; this.clamp(); if (j % 4) for (var k = 0; k < a; k++)c[j + k >>> 2] |= (e[k >>> 2] >>> 24 - 8 * (k % 4) & 255) << 24 - 8 * ((j + k) % 4); else if (65535 < e.length) for (k = 0; k < a; k += 4)c[j + k >>> 2] = e[k >>> 2]; else c.push.apply(c, e); this.sigBytes += a; return this }, clamp: function () {
            var a = this.words, c = this.sigBytes; a[c >>> 2] &= 4294967295 <<
                32 - 8 * (c % 4); a.length = u.ceil(c / 4)
        }, clone: function () { var a = t.clone.call(this); a.words = this.words.slice(0); return a }, random: function (a) { for (var c = [], e = 0; e < a; e += 4)c.push(4294967296 * u.random() | 0); return new r.init(c, a) }
    }), w = d.enc = {}, v = w.Hex = {
        stringify: function (a) { var c = a.words; a = a.sigBytes; for (var e = [], j = 0; j < a; j++) { var k = c[j >>> 2] >>> 24 - 8 * (j % 4) & 255; e.push((k >>> 4).toString(16)); e.push((k & 15).toString(16)) } return e.join("") }, parse: function (a) {
            for (var c = a.length, e = [], j = 0; j < c; j += 2)e[j >>> 3] |= parseInt(a.substr(j,
                2), 16) << 24 - 4 * (j % 8); return new r.init(e, c / 2)
        }
    }, b = w.Latin1 = { stringify: function (a) { var c = a.words; a = a.sigBytes; for (var e = [], j = 0; j < a; j++)e.push(String.fromCharCode(c[j >>> 2] >>> 24 - 8 * (j % 4) & 255)); return e.join("") }, parse: function (a) { for (var c = a.length, e = [], j = 0; j < c; j++)e[j >>> 2] |= (a.charCodeAt(j) & 255) << 24 - 8 * (j % 4); return new r.init(e, c) } }, x = w.Utf8 = { stringify: function (a) { try { return decodeURIComponent(escape(b.stringify(a))) } catch (c) { throw Error("Malformed UTF-8 data"); } }, parse: function (a) { return b.parse(unescape(encodeURIComponent(a))) } },
    q = l.BufferedBlockAlgorithm = t.extend({
        reset: function () { this._data = new r.init; this._nDataBytes = 0 }, _append: function (a) { "string" == typeof a && (a = x.parse(a)); this._data.concat(a); this._nDataBytes += a.sigBytes }, _process: function (a) { var c = this._data, e = c.words, j = c.sigBytes, k = this.blockSize, b = j / (4 * k), b = a ? u.ceil(b) : u.max((b | 0) - this._minBufferSize, 0); a = b * k; j = u.min(4 * a, j); if (a) { for (var q = 0; q < a; q += k)this._doProcessBlock(e, q); q = e.splice(0, a); c.sigBytes -= j } return new r.init(q, j) }, clone: function () {
            var a = t.clone.call(this);
            a._data = this._data.clone(); return a
        }, _minBufferSize: 0
    }); l.Hasher = q.extend({
        cfg: t.extend(), init: function (a) { this.cfg = this.cfg.extend(a); this.reset() }, reset: function () { q.reset.call(this); this._doReset() }, update: function (a) { this._append(a); this._process(); return this }, finalize: function (a) { a && this._append(a); return this._doFinalize() }, blockSize: 16, _createHelper: function (a) { return function (b, e) { return (new a.init(e)).finalize(b) } }, _createHmacHelper: function (a) {
            return function (b, e) {
                return (new n.HMAC.init(a,
                    e)).finalize(b)
            }
        }
    }); var n = d.algo = {}; return d
}(Math);
(function () {
    var u = CryptoJS, p = u.lib.WordArray; u.enc.Base64 = {
        stringify: function (d) { var l = d.words, p = d.sigBytes, t = this._map; d.clamp(); d = []; for (var r = 0; r < p; r += 3)for (var w = (l[r >>> 2] >>> 24 - 8 * (r % 4) & 255) << 16 | (l[r + 1 >>> 2] >>> 24 - 8 * ((r + 1) % 4) & 255) << 8 | l[r + 2 >>> 2] >>> 24 - 8 * ((r + 2) % 4) & 255, v = 0; 4 > v && r + 0.75 * v < p; v++)d.push(t.charAt(w >>> 6 * (3 - v) & 63)); if (l = t.charAt(64)) for (; d.length % 4;)d.push(l); return d.join("") }, parse: function (d) {
            var l = d.length, s = this._map, t = s.charAt(64); t && (t = d.indexOf(t), -1 != t && (l = t)); for (var t = [], r = 0, w = 0; w <
                l; w++)if (w % 4) { var v = s.indexOf(d.charAt(w - 1)) << 2 * (w % 4), b = s.indexOf(d.charAt(w)) >>> 6 - 2 * (w % 4); t[r >>> 2] |= (v | b) << 24 - 8 * (r % 4); r++ } return p.create(t, r)
        }, _map: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/="
    }
})();
(function (u) {
    function p(b, n, a, c, e, j, k) { b = b + (n & a | ~n & c) + e + k; return (b << j | b >>> 32 - j) + n } function d(b, n, a, c, e, j, k) { b = b + (n & c | a & ~c) + e + k; return (b << j | b >>> 32 - j) + n } function l(b, n, a, c, e, j, k) { b = b + (n ^ a ^ c) + e + k; return (b << j | b >>> 32 - j) + n } function s(b, n, a, c, e, j, k) { b = b + (a ^ (n | ~c)) + e + k; return (b << j | b >>> 32 - j) + n } for (var t = CryptoJS, r = t.lib, w = r.WordArray, v = r.Hasher, r = t.algo, b = [], x = 0; 64 > x; x++)b[x] = 4294967296 * u.abs(u.sin(x + 1)) | 0; r = r.MD5 = v.extend({
        _doReset: function () { this._hash = new w.init([1732584193, 4023233417, 2562383102, 271733878]) },
        _doProcessBlock: function (q, n) {
            for (var a = 0; 16 > a; a++) { var c = n + a, e = q[c]; q[c] = (e << 8 | e >>> 24) & 16711935 | (e << 24 | e >>> 8) & 4278255360 } var a = this._hash.words, c = q[n + 0], e = q[n + 1], j = q[n + 2], k = q[n + 3], z = q[n + 4], r = q[n + 5], t = q[n + 6], w = q[n + 7], v = q[n + 8], A = q[n + 9], B = q[n + 10], C = q[n + 11], u = q[n + 12], D = q[n + 13], E = q[n + 14], x = q[n + 15], f = a[0], m = a[1], g = a[2], h = a[3], f = p(f, m, g, h, c, 7, b[0]), h = p(h, f, m, g, e, 12, b[1]), g = p(g, h, f, m, j, 17, b[2]), m = p(m, g, h, f, k, 22, b[3]), f = p(f, m, g, h, z, 7, b[4]), h = p(h, f, m, g, r, 12, b[5]), g = p(g, h, f, m, t, 17, b[6]), m = p(m, g, h, f, w, 22, b[7]),
                f = p(f, m, g, h, v, 7, b[8]), h = p(h, f, m, g, A, 12, b[9]), g = p(g, h, f, m, B, 17, b[10]), m = p(m, g, h, f, C, 22, b[11]), f = p(f, m, g, h, u, 7, b[12]), h = p(h, f, m, g, D, 12, b[13]), g = p(g, h, f, m, E, 17, b[14]), m = p(m, g, h, f, x, 22, b[15]), f = d(f, m, g, h, e, 5, b[16]), h = d(h, f, m, g, t, 9, b[17]), g = d(g, h, f, m, C, 14, b[18]), m = d(m, g, h, f, c, 20, b[19]), f = d(f, m, g, h, r, 5, b[20]), h = d(h, f, m, g, B, 9, b[21]), g = d(g, h, f, m, x, 14, b[22]), m = d(m, g, h, f, z, 20, b[23]), f = d(f, m, g, h, A, 5, b[24]), h = d(h, f, m, g, E, 9, b[25]), g = d(g, h, f, m, k, 14, b[26]), m = d(m, g, h, f, v, 20, b[27]), f = d(f, m, g, h, D, 5, b[28]), h = d(h, f,
                    m, g, j, 9, b[29]), g = d(g, h, f, m, w, 14, b[30]), m = d(m, g, h, f, u, 20, b[31]), f = l(f, m, g, h, r, 4, b[32]), h = l(h, f, m, g, v, 11, b[33]), g = l(g, h, f, m, C, 16, b[34]), m = l(m, g, h, f, E, 23, b[35]), f = l(f, m, g, h, e, 4, b[36]), h = l(h, f, m, g, z, 11, b[37]), g = l(g, h, f, m, w, 16, b[38]), m = l(m, g, h, f, B, 23, b[39]), f = l(f, m, g, h, D, 4, b[40]), h = l(h, f, m, g, c, 11, b[41]), g = l(g, h, f, m, k, 16, b[42]), m = l(m, g, h, f, t, 23, b[43]), f = l(f, m, g, h, A, 4, b[44]), h = l(h, f, m, g, u, 11, b[45]), g = l(g, h, f, m, x, 16, b[46]), m = l(m, g, h, f, j, 23, b[47]), f = s(f, m, g, h, c, 6, b[48]), h = s(h, f, m, g, w, 10, b[49]), g = s(g, h, f, m,
                        E, 15, b[50]), m = s(m, g, h, f, r, 21, b[51]), f = s(f, m, g, h, u, 6, b[52]), h = s(h, f, m, g, k, 10, b[53]), g = s(g, h, f, m, B, 15, b[54]), m = s(m, g, h, f, e, 21, b[55]), f = s(f, m, g, h, v, 6, b[56]), h = s(h, f, m, g, x, 10, b[57]), g = s(g, h, f, m, t, 15, b[58]), m = s(m, g, h, f, D, 21, b[59]), f = s(f, m, g, h, z, 6, b[60]), h = s(h, f, m, g, C, 10, b[61]), g = s(g, h, f, m, j, 15, b[62]), m = s(m, g, h, f, A, 21, b[63]); a[0] = a[0] + f | 0; a[1] = a[1] + m | 0; a[2] = a[2] + g | 0; a[3] = a[3] + h | 0
        }, _doFinalize: function () {
            var b = this._data, n = b.words, a = 8 * this._nDataBytes, c = 8 * b.sigBytes; n[c >>> 5] |= 128 << 24 - c % 32; var e = u.floor(a /
                4294967296); n[(c + 64 >>> 9 << 4) + 15] = (e << 8 | e >>> 24) & 16711935 | (e << 24 | e >>> 8) & 4278255360; n[(c + 64 >>> 9 << 4) + 14] = (a << 8 | a >>> 24) & 16711935 | (a << 24 | a >>> 8) & 4278255360; b.sigBytes = 4 * (n.length + 1); this._process(); b = this._hash; n = b.words; for (a = 0; 4 > a; a++)c = n[a], n[a] = (c << 8 | c >>> 24) & 16711935 | (c << 24 | c >>> 8) & 4278255360; return b
        }, clone: function () { var b = v.clone.call(this); b._hash = this._hash.clone(); return b }
    }); t.MD5 = v._createHelper(r); t.HmacMD5 = v._createHmacHelper(r)
})(Math);
(function () {
    var u = CryptoJS, p = u.lib, d = p.Base, l = p.WordArray, p = u.algo, s = p.EvpKDF = d.extend({ cfg: d.extend({ keySize: 4, hasher: p.MD5, iterations: 1 }), init: function (d) { this.cfg = this.cfg.extend(d) }, compute: function (d, r) { for (var p = this.cfg, s = p.hasher.create(), b = l.create(), u = b.words, q = p.keySize, p = p.iterations; u.length < q;) { n && s.update(n); var n = s.update(d).finalize(r); s.reset(); for (var a = 1; a < p; a++)n = s.finalize(n), s.reset(); b.concat(n) } b.sigBytes = 4 * q; return b } }); u.EvpKDF = function (d, l, p) {
        return s.create(p).compute(d,
            l)
    }
})();
CryptoJS.lib.Cipher || function (u) {
    var p = CryptoJS, d = p.lib, l = d.Base, s = d.WordArray, t = d.BufferedBlockAlgorithm, r = p.enc.Base64, w = p.algo.EvpKDF, v = d.Cipher = t.extend({
        cfg: l.extend(), createEncryptor: function (e, a) { return this.create(this._ENC_XFORM_MODE, e, a) }, createDecryptor: function (e, a) { return this.create(this._DEC_XFORM_MODE, e, a) }, init: function (e, a, b) { this.cfg = this.cfg.extend(b); this._xformMode = e; this._key = a; this.reset() }, reset: function () { t.reset.call(this); this._doReset() }, process: function (e) { this._append(e); return this._process() },
        finalize: function (e) { e && this._append(e); return this._doFinalize() }, keySize: 4, ivSize: 4, _ENC_XFORM_MODE: 1, _DEC_XFORM_MODE: 2, _createHelper: function (e) { return { encrypt: function (b, k, d) { return ("string" == typeof k ? c : a).encrypt(e, b, k, d) }, decrypt: function (b, k, d) { return ("string" == typeof k ? c : a).decrypt(e, b, k, d) } } }
    }); d.StreamCipher = v.extend({ _doFinalize: function () { return this._process(!0) }, blockSize: 1 }); var b = p.mode = {}, x = function (e, a, b) {
        var c = this._iv; c ? this._iv = u : c = this._prevBlock; for (var d = 0; d < b; d++)e[a + d] ^=
            c[d]
    }, q = (d.BlockCipherMode = l.extend({ createEncryptor: function (e, a) { return this.Encryptor.create(e, a) }, createDecryptor: function (e, a) { return this.Decryptor.create(e, a) }, init: function (e, a) { this._cipher = e; this._iv = a } })).extend(); q.Encryptor = q.extend({ processBlock: function (e, a) { var b = this._cipher, c = b.blockSize; x.call(this, e, a, c); b.encryptBlock(e, a); this._prevBlock = e.slice(a, a + c) } }); q.Decryptor = q.extend({
        processBlock: function (e, a) {
            var b = this._cipher, c = b.blockSize, d = e.slice(a, a + c); b.decryptBlock(e, a); x.call(this,
                e, a, c); this._prevBlock = d
        }
    }); b = b.CBC = q; q = (p.pad = {}).Pkcs7 = { pad: function (a, b) { for (var c = 4 * b, c = c - a.sigBytes % c, d = c << 24 | c << 16 | c << 8 | c, l = [], n = 0; n < c; n += 4)l.push(d); c = s.create(l, c); a.concat(c) }, unpad: function (a) { a.sigBytes -= a.words[a.sigBytes - 1 >>> 2] & 255 } }; d.BlockCipher = v.extend({
        cfg: v.cfg.extend({ mode: b, padding: q }), reset: function () {
            v.reset.call(this); var a = this.cfg, b = a.iv, a = a.mode; if (this._xformMode == this._ENC_XFORM_MODE) var c = a.createEncryptor; else c = a.createDecryptor, this._minBufferSize = 1; this._mode = c.call(a,
                this, b && b.words)
        }, _doProcessBlock: function (a, b) { this._mode.processBlock(a, b) }, _doFinalize: function () { var a = this.cfg.padding; if (this._xformMode == this._ENC_XFORM_MODE) { a.pad(this._data, this.blockSize); var b = this._process(!0) } else b = this._process(!0), a.unpad(b); return b }, blockSize: 4
    }); var n = d.CipherParams = l.extend({ init: function (a) { this.mixIn(a) }, toString: function (a) { return (a || this.formatter).stringify(this) } }), b = (p.format = {}).OpenSSL = {
        stringify: function (a) {
            var b = a.ciphertext; a = a.salt; return (a ? s.create([1398893684,
                1701076831]).concat(a).concat(b) : b).toString(r)
        }, parse: function (a) { a = r.parse(a); var b = a.words; if (1398893684 == b[0] && 1701076831 == b[1]) { var c = s.create(b.slice(2, 4)); b.splice(0, 4); a.sigBytes -= 16 } return n.create({ ciphertext: a, salt: c }) }
    }, a = d.SerializableCipher = l.extend({
        cfg: l.extend({ format: b }), encrypt: function (a, b, c, d) { d = this.cfg.extend(d); var l = a.createEncryptor(c, d); b = l.finalize(b); l = l.cfg; return n.create({ ciphertext: b, key: c, iv: l.iv, algorithm: a, mode: l.mode, padding: l.padding, blockSize: a.blockSize, formatter: d.format }) },
        decrypt: function (a, b, c, d) { d = this.cfg.extend(d); b = this._parse(b, d.format); return a.createDecryptor(c, d).finalize(b.ciphertext) }, _parse: function (a, b) { return "string" == typeof a ? b.parse(a, this) : a }
    }), p = (p.kdf = {}).OpenSSL = { execute: function (a, b, c, d) { d || (d = s.random(8)); a = w.create({ keySize: b + c }).compute(a, d); c = s.create(a.words.slice(b), 4 * c); a.sigBytes = 4 * b; return n.create({ key: a, iv: c, salt: d }) } }, c = d.PasswordBasedCipher = a.extend({
        cfg: a.cfg.extend({ kdf: p }), encrypt: function (b, c, d, l) {
            l = this.cfg.extend(l); d = l.kdf.execute(d,
                b.keySize, b.ivSize); l.iv = d.iv; b = a.encrypt.call(this, b, c, d.key, l); b.mixIn(d); return b
        }, decrypt: function (b, c, d, l) { l = this.cfg.extend(l); c = this._parse(c, l.format); d = l.kdf.execute(d, b.keySize, b.ivSize, c.salt); l.iv = d.iv; return a.decrypt.call(this, b, c, d.key, l) }
    })
}();
(function () {
    for (var u = CryptoJS, p = u.lib.BlockCipher, d = u.algo, l = [], s = [], t = [], r = [], w = [], v = [], b = [], x = [], q = [], n = [], a = [], c = 0; 256 > c; c++)a[c] = 128 > c ? c << 1 : c << 1 ^ 283; for (var e = 0, j = 0, c = 0; 256 > c; c++) { var k = j ^ j << 1 ^ j << 2 ^ j << 3 ^ j << 4, k = k >>> 8 ^ k & 255 ^ 99; l[e] = k; s[k] = e; var z = a[e], F = a[z], G = a[F], y = 257 * a[k] ^ 16843008 * k; t[e] = y << 24 | y >>> 8; r[e] = y << 16 | y >>> 16; w[e] = y << 8 | y >>> 24; v[e] = y; y = 16843009 * G ^ 65537 * F ^ 257 * z ^ 16843008 * e; b[k] = y << 24 | y >>> 8; x[k] = y << 16 | y >>> 16; q[k] = y << 8 | y >>> 24; n[k] = y; e ? (e = z ^ a[a[a[G ^ z]]], j ^= a[a[j]]) : e = j = 1 } var H = [0, 1, 2, 4, 8,
        16, 32, 64, 128, 27, 54], d = d.AES = p.extend({
            _doReset: function () {
                for (var a = this._key, c = a.words, d = a.sigBytes / 4, a = 4 * ((this._nRounds = d + 6) + 1), e = this._keySchedule = [], j = 0; j < a; j++)if (j < d) e[j] = c[j]; else { var k = e[j - 1]; j % d ? 6 < d && 4 == j % d && (k = l[k >>> 24] << 24 | l[k >>> 16 & 255] << 16 | l[k >>> 8 & 255] << 8 | l[k & 255]) : (k = k << 8 | k >>> 24, k = l[k >>> 24] << 24 | l[k >>> 16 & 255] << 16 | l[k >>> 8 & 255] << 8 | l[k & 255], k ^= H[j / d | 0] << 24); e[j] = e[j - d] ^ k } c = this._invKeySchedule = []; for (d = 0; d < a; d++)j = a - d, k = d % 4 ? e[j] : e[j - 4], c[d] = 4 > d || 4 >= j ? k : b[l[k >>> 24]] ^ x[l[k >>> 16 & 255]] ^ q[l[k >>>
                    8 & 255]] ^ n[l[k & 255]]
            }, encryptBlock: function (a, b) { this._doCryptBlock(a, b, this._keySchedule, t, r, w, v, l) }, decryptBlock: function (a, c) { var d = a[c + 1]; a[c + 1] = a[c + 3]; a[c + 3] = d; this._doCryptBlock(a, c, this._invKeySchedule, b, x, q, n, s); d = a[c + 1]; a[c + 1] = a[c + 3]; a[c + 3] = d }, _doCryptBlock: function (a, b, c, d, e, j, l, f) {
                for (var m = this._nRounds, g = a[b] ^ c[0], h = a[b + 1] ^ c[1], k = a[b + 2] ^ c[2], n = a[b + 3] ^ c[3], p = 4, r = 1; r < m; r++)var q = d[g >>> 24] ^ e[h >>> 16 & 255] ^ j[k >>> 8 & 255] ^ l[n & 255] ^ c[p++], s = d[h >>> 24] ^ e[k >>> 16 & 255] ^ j[n >>> 8 & 255] ^ l[g & 255] ^ c[p++], t =
                    d[k >>> 24] ^ e[n >>> 16 & 255] ^ j[g >>> 8 & 255] ^ l[h & 255] ^ c[p++], n = d[n >>> 24] ^ e[g >>> 16 & 255] ^ j[h >>> 8 & 255] ^ l[k & 255] ^ c[p++], g = q, h = s, k = t; q = (f[g >>> 24] << 24 | f[h >>> 16 & 255] << 16 | f[k >>> 8 & 255] << 8 | f[n & 255]) ^ c[p++]; s = (f[h >>> 24] << 24 | f[k >>> 16 & 255] << 16 | f[n >>> 8 & 255] << 8 | f[g & 255]) ^ c[p++]; t = (f[k >>> 24] << 24 | f[n >>> 16 & 255] << 16 | f[g >>> 8 & 255] << 8 | f[h & 255]) ^ c[p++]; n = (f[n >>> 24] << 24 | f[g >>> 16 & 255] << 16 | f[h >>> 8 & 255] << 8 | f[k & 255]) ^ c[p++]; a[b] = q; a[b + 1] = s; a[b + 2] = t; a[b + 3] = n
            }, keySize: 8
        }); u.AES = p._createHelper(d)
})();

//TripleDES Algo (tripledes.js)

(function () {
    // Shortcuts
    var C = CryptoJS;
    var C_lib = C.lib;
    var WordArray = C_lib.WordArray;
    var BlockCipher = C_lib.BlockCipher;
    var C_algo = C.algo;

    // Permuted Choice 1 constants
    var PC1 = [
        57, 49, 41, 33, 25, 17, 9,  1,
        58, 50, 42, 34, 26, 18, 10, 2,
        59, 51, 43, 35, 27, 19, 11, 3,
        60, 52, 44, 36, 63, 55, 47, 39,
        31, 23, 15, 7,  62, 54, 46, 38,
        30, 22, 14, 6,  61, 53, 45, 37,
        29, 21, 13, 5,  28, 20, 12, 4
    ];

    // Permuted Choice 2 constants
    var PC2 = [
        14, 17, 11, 24, 1,  5,
        3,  28, 15, 6,  21, 10,
        23, 19, 12, 4,  26, 8,
        16, 7,  27, 20, 13, 2,
        41, 52, 31, 37, 47, 55,
        30, 40, 51, 45, 33, 48,
        44, 49, 39, 56, 34, 53,
        46, 42, 50, 36, 29, 32
    ];

    // Cumulative bit shift constants
    var BIT_SHIFTS = [1,  2,  4,  6,  8,  10, 12, 14, 15, 17, 19, 21, 23, 25, 27, 28];

    // SBOXes and round permutation constants
    var SBOX_P = [
        {
            0x0: 0x808200,
            0x10000000: 0x8000,
            0x20000000: 0x808002,
            0x30000000: 0x2,
            0x40000000: 0x200,
            0x50000000: 0x808202,
            0x60000000: 0x800202,
            0x70000000: 0x800000,
            0x80000000: 0x202,
            0x90000000: 0x800200,
            0xa0000000: 0x8200,
            0xb0000000: 0x808000,
            0xc0000000: 0x8002,
            0xd0000000: 0x800002,
            0xe0000000: 0x0,
            0xf0000000: 0x8202,
            0x8000000: 0x0,
            0x18000000: 0x808202,
            0x28000000: 0x8202,
            0x38000000: 0x8000,
            0x48000000: 0x808200,
            0x58000000: 0x200,
            0x68000000: 0x808002,
            0x78000000: 0x2,
            0x88000000: 0x800200,
            0x98000000: 0x8200,
            0xa8000000: 0x808000,
            0xb8000000: 0x800202,
            0xc8000000: 0x800002,
            0xd8000000: 0x8002,
            0xe8000000: 0x202,
            0xf8000000: 0x800000,
            0x1: 0x8000,
            0x10000001: 0x2,
            0x20000001: 0x808200,
            0x30000001: 0x800000,
            0x40000001: 0x808002,
            0x50000001: 0x8200,
            0x60000001: 0x200,
            0x70000001: 0x800202,
            0x80000001: 0x808202,
            0x90000001: 0x808000,
            0xa0000001: 0x800002,
            0xb0000001: 0x8202,
            0xc0000001: 0x202,
            0xd0000001: 0x800200,
            0xe0000001: 0x8002,
            0xf0000001: 0x0,
            0x8000001: 0x808202,
            0x18000001: 0x808000,
            0x28000001: 0x800000,
            0x38000001: 0x200,
            0x48000001: 0x8000,
            0x58000001: 0x800002,
            0x68000001: 0x2,
            0x78000001: 0x8202,
            0x88000001: 0x8002,
            0x98000001: 0x800202,
            0xa8000001: 0x202,
            0xb8000001: 0x808200,
            0xc8000001: 0x800200,
            0xd8000001: 0x0,
            0xe8000001: 0x8200,
            0xf8000001: 0x808002
        },
        {
            0x0: 0x40084010,
            0x1000000: 0x4000,
            0x2000000: 0x80000,
            0x3000000: 0x40080010,
            0x4000000: 0x40000010,
            0x5000000: 0x40084000,
            0x6000000: 0x40004000,
            0x7000000: 0x10,
            0x8000000: 0x84000,
            0x9000000: 0x40004010,
            0xa000000: 0x40000000,
            0xb000000: 0x84010,
            0xc000000: 0x80010,
            0xd000000: 0x0,
            0xe000000: 0x4010,
            0xf000000: 0x40080000,
            0x800000: 0x40004000,
            0x1800000: 0x84010,
            0x2800000: 0x10,
            0x3800000: 0x40004010,
            0x4800000: 0x40084010,
            0x5800000: 0x40000000,
            0x6800000: 0x80000,
            0x7800000: 0x40080010,
            0x8800000: 0x80010,
            0x9800000: 0x0,
            0xa800000: 0x4000,
            0xb800000: 0x40080000,
            0xc800000: 0x40000010,
            0xd800000: 0x84000,
            0xe800000: 0x40084000,
            0xf800000: 0x4010,
            0x10000000: 0x0,
            0x11000000: 0x40080010,
            0x12000000: 0x40004010,
            0x13000000: 0x40084000,
            0x14000000: 0x40080000,
            0x15000000: 0x10,
            0x16000000: 0x84010,
            0x17000000: 0x4000,
            0x18000000: 0x4010,
            0x19000000: 0x80000,
            0x1a000000: 0x80010,
            0x1b000000: 0x40000010,
            0x1c000000: 0x84000,
            0x1d000000: 0x40004000,
            0x1e000000: 0x40000000,
            0x1f000000: 0x40084010,
            0x10800000: 0x84010,
            0x11800000: 0x80000,
            0x12800000: 0x40080000,
            0x13800000: 0x4000,
            0x14800000: 0x40004000,
            0x15800000: 0x40084010,
            0x16800000: 0x10,
            0x17800000: 0x40000000,
            0x18800000: 0x40084000,
            0x19800000: 0x40000010,
            0x1a800000: 0x40004010,
            0x1b800000: 0x80010,
            0x1c800000: 0x0,
            0x1d800000: 0x4010,
            0x1e800000: 0x40080010,
            0x1f800000: 0x84000
        },
        {
            0x0: 0x104,
            0x100000: 0x0,
            0x200000: 0x4000100,
            0x300000: 0x10104,
            0x400000: 0x10004,
            0x500000: 0x4000004,
            0x600000: 0x4010104,
            0x700000: 0x4010000,
            0x800000: 0x4000000,
            0x900000: 0x4010100,
            0xa00000: 0x10100,
            0xb00000: 0x4010004,
            0xc00000: 0x4000104,
            0xd00000: 0x10000,
            0xe00000: 0x4,
            0xf00000: 0x100,
            0x80000: 0x4010100,
            0x180000: 0x4010004,
            0x280000: 0x0,
            0x380000: 0x4000100,
            0x480000: 0x4000004,
            0x580000: 0x10000,
            0x680000: 0x10004,
            0x780000: 0x104,
            0x880000: 0x4,
            0x980000: 0x100,
            0xa80000: 0x4010000,
            0xb80000: 0x10104,
            0xc80000: 0x10100,
            0xd80000: 0x4000104,
            0xe80000: 0x4010104,
            0xf80000: 0x4000000,
            0x1000000: 0x4010100,
            0x1100000: 0x10004,
            0x1200000: 0x10000,
            0x1300000: 0x4000100,
            0x1400000: 0x100,
            0x1500000: 0x4010104,
            0x1600000: 0x4000004,
            0x1700000: 0x0,
            0x1800000: 0x4000104,
            0x1900000: 0x4000000,
            0x1a00000: 0x4,
            0x1b00000: 0x10100,
            0x1c00000: 0x4010000,
            0x1d00000: 0x104,
            0x1e00000: 0x10104,
            0x1f00000: 0x4010004,
            0x1080000: 0x4000000,
            0x1180000: 0x104,
            0x1280000: 0x4010100,
            0x1380000: 0x0,
            0x1480000: 0x10004,
            0x1580000: 0x4000100,
            0x1680000: 0x100,
            0x1780000: 0x4010004,
            0x1880000: 0x10000,
            0x1980000: 0x4010104,
            0x1a80000: 0x10104,
            0x1b80000: 0x4000004,
            0x1c80000: 0x4000104,
            0x1d80000: 0x4010000,
            0x1e80000: 0x4,
            0x1f80000: 0x10100
        },
        {
            0x0: 0x80401000,
            0x10000: 0x80001040,
            0x20000: 0x401040,
            0x30000: 0x80400000,
            0x40000: 0x0,
            0x50000: 0x401000,
            0x60000: 0x80000040,
            0x70000: 0x400040,
            0x80000: 0x80000000,
            0x90000: 0x400000,
            0xa0000: 0x40,
            0xb0000: 0x80001000,
            0xc0000: 0x80400040,
            0xd0000: 0x1040,
            0xe0000: 0x1000,
            0xf0000: 0x80401040,
            0x8000: 0x80001040,
            0x18000: 0x40,
            0x28000: 0x80400040,
            0x38000: 0x80001000,
            0x48000: 0x401000,
            0x58000: 0x80401040,
            0x68000: 0x0,
            0x78000: 0x80400000,
            0x88000: 0x1000,
            0x98000: 0x80401000,
            0xa8000: 0x400000,
            0xb8000: 0x1040,
            0xc8000: 0x80000000,
            0xd8000: 0x400040,
            0xe8000: 0x401040,
            0xf8000: 0x80000040,
            0x100000: 0x400040,
            0x110000: 0x401000,
            0x120000: 0x80000040,
            0x130000: 0x0,
            0x140000: 0x1040,
            0x150000: 0x80400040,
            0x160000: 0x80401000,
            0x170000: 0x80001040,
            0x180000: 0x80401040,
            0x190000: 0x80000000,
            0x1a0000: 0x80400000,
            0x1b0000: 0x401040,
            0x1c0000: 0x80001000,
            0x1d0000: 0x400000,
            0x1e0000: 0x40,
            0x1f0000: 0x1000,
            0x108000: 0x80400000,
            0x118000: 0x80401040,
            0x128000: 0x0,
            0x138000: 0x401000,
            0x148000: 0x400040,
            0x158000: 0x80000000,
            0x168000: 0x80001040,
            0x178000: 0x40,
            0x188000: 0x80000040,
            0x198000: 0x1000,
            0x1a8000: 0x80001000,
            0x1b8000: 0x80400040,
            0x1c8000: 0x1040,
            0x1d8000: 0x80401000,
            0x1e8000: 0x400000,
            0x1f8000: 0x401040
        },
        {
            0x0: 0x80,
            0x1000: 0x1040000,
            0x2000: 0x40000,
            0x3000: 0x20000000,
            0x4000: 0x20040080,
            0x5000: 0x1000080,
            0x6000: 0x21000080,
            0x7000: 0x40080,
            0x8000: 0x1000000,
            0x9000: 0x20040000,
            0xa000: 0x20000080,
            0xb000: 0x21040080,
            0xc000: 0x21040000,
            0xd000: 0x0,
            0xe000: 0x1040080,
            0xf000: 0x21000000,
            0x800: 0x1040080,
            0x1800: 0x21000080,
            0x2800: 0x80,
            0x3800: 0x1040000,
            0x4800: 0x40000,
            0x5800: 0x20040080,
            0x6800: 0x21040000,
            0x7800: 0x20000000,
            0x8800: 0x20040000,
            0x9800: 0x0,
            0xa800: 0x21040080,
            0xb800: 0x1000080,
            0xc800: 0x20000080,
            0xd800: 0x21000000,
            0xe800: 0x1000000,
            0xf800: 0x40080,
            0x10000: 0x40000,
            0x11000: 0x80,
            0x12000: 0x20000000,
            0x13000: 0x21000080,
            0x14000: 0x1000080,
            0x15000: 0x21040000,
            0x16000: 0x20040080,
            0x17000: 0x1000000,
            0x18000: 0x21040080,
            0x19000: 0x21000000,
            0x1a000: 0x1040000,
            0x1b000: 0x20040000,
            0x1c000: 0x40080,
            0x1d000: 0x20000080,
            0x1e000: 0x0,
            0x1f000: 0x1040080,
            0x10800: 0x21000080,
            0x11800: 0x1000000,
            0x12800: 0x1040000,
            0x13800: 0x20040080,
            0x14800: 0x20000000,
            0x15800: 0x1040080,
            0x16800: 0x80,
            0x17800: 0x21040000,
            0x18800: 0x40080,
            0x19800: 0x21040080,
            0x1a800: 0x0,
            0x1b800: 0x21000000,
            0x1c800: 0x1000080,
            0x1d800: 0x40000,
            0x1e800: 0x20040000,
            0x1f800: 0x20000080
        },
        {
            0x0: 0x10000008,
            0x100: 0x2000,
            0x200: 0x10200000,
            0x300: 0x10202008,
            0x400: 0x10002000,
            0x500: 0x200000,
            0x600: 0x200008,
            0x700: 0x10000000,
            0x800: 0x0,
            0x900: 0x10002008,
            0xa00: 0x202000,
            0xb00: 0x8,
            0xc00: 0x10200008,
            0xd00: 0x202008,
            0xe00: 0x2008,
            0xf00: 0x10202000,
            0x80: 0x10200000,
            0x180: 0x10202008,
            0x280: 0x8,
            0x380: 0x200000,
            0x480: 0x202008,
            0x580: 0x10000008,
            0x680: 0x10002000,
            0x780: 0x2008,
            0x880: 0x200008,
            0x980: 0x2000,
            0xa80: 0x10002008,
            0xb80: 0x10200008,
            0xc80: 0x0,
            0xd80: 0x10202000,
            0xe80: 0x202000,
            0xf80: 0x10000000,
            0x1000: 0x10002000,
            0x1100: 0x10200008,
            0x1200: 0x10202008,
            0x1300: 0x2008,
            0x1400: 0x200000,
            0x1500: 0x10000000,
            0x1600: 0x10000008,
            0x1700: 0x202000,
            0x1800: 0x202008,
            0x1900: 0x0,
            0x1a00: 0x8,
            0x1b00: 0x10200000,
            0x1c00: 0x2000,
            0x1d00: 0x10002008,
            0x1e00: 0x10202000,
            0x1f00: 0x200008,
            0x1080: 0x8,
            0x1180: 0x202000,
            0x1280: 0x200000,
            0x1380: 0x10000008,
            0x1480: 0x10002000,
            0x1580: 0x2008,
            0x1680: 0x10202008,
            0x1780: 0x10200000,
            0x1880: 0x10202000,
            0x1980: 0x10200008,
            0x1a80: 0x2000,
            0x1b80: 0x202008,
            0x1c80: 0x200008,
            0x1d80: 0x0,
            0x1e80: 0x10000000,
            0x1f80: 0x10002008
        },
        {
            0x0: 0x100000,
            0x10: 0x2000401,
            0x20: 0x400,
            0x30: 0x100401,
            0x40: 0x2100401,
            0x50: 0x0,
            0x60: 0x1,
            0x70: 0x2100001,
            0x80: 0x2000400,
            0x90: 0x100001,
            0xa0: 0x2000001,
            0xb0: 0x2100400,
            0xc0: 0x2100000,
            0xd0: 0x401,
            0xe0: 0x100400,
            0xf0: 0x2000000,
            0x8: 0x2100001,
            0x18: 0x0,
            0x28: 0x2000401,
            0x38: 0x2100400,
            0x48: 0x100000,
            0x58: 0x2000001,
            0x68: 0x2000000,
            0x78: 0x401,
            0x88: 0x100401,
            0x98: 0x2000400,
            0xa8: 0x2100000,
            0xb8: 0x100001,
            0xc8: 0x400,
            0xd8: 0x2100401,
            0xe8: 0x1,
            0xf8: 0x100400,
            0x100: 0x2000000,
            0x110: 0x100000,
            0x120: 0x2000401,
            0x130: 0x2100001,
            0x140: 0x100001,
            0x150: 0x2000400,
            0x160: 0x2100400,
            0x170: 0x100401,
            0x180: 0x401,
            0x190: 0x2100401,
            0x1a0: 0x100400,
            0x1b0: 0x1,
            0x1c0: 0x0,
            0x1d0: 0x2100000,
            0x1e0: 0x2000001,
            0x1f0: 0x400,
            0x108: 0x100400,
            0x118: 0x2000401,
            0x128: 0x2100001,
            0x138: 0x1,
            0x148: 0x2000000,
            0x158: 0x100000,
            0x168: 0x401,
            0x178: 0x2100400,
            0x188: 0x2000001,
            0x198: 0x2100000,
            0x1a8: 0x0,
            0x1b8: 0x2100401,
            0x1c8: 0x100401,
            0x1d8: 0x400,
            0x1e8: 0x2000400,
            0x1f8: 0x100001
        },
        {
            0x0: 0x8000820,
            0x1: 0x20000,
            0x2: 0x8000000,
            0x3: 0x20,
            0x4: 0x20020,
            0x5: 0x8020820,
            0x6: 0x8020800,
            0x7: 0x800,
            0x8: 0x8020000,
            0x9: 0x8000800,
            0xa: 0x20800,
            0xb: 0x8020020,
            0xc: 0x820,
            0xd: 0x0,
            0xe: 0x8000020,
            0xf: 0x20820,
            0x80000000: 0x800,
            0x80000001: 0x8020820,
            0x80000002: 0x8000820,
            0x80000003: 0x8000000,
            0x80000004: 0x8020000,
            0x80000005: 0x20800,
            0x80000006: 0x20820,
            0x80000007: 0x20,
            0x80000008: 0x8000020,
            0x80000009: 0x820,
            0x8000000a: 0x20020,
            0x8000000b: 0x8020800,
            0x8000000c: 0x0,
            0x8000000d: 0x8020020,
            0x8000000e: 0x8000800,
            0x8000000f: 0x20000,
            0x10: 0x20820,
            0x11: 0x8020800,
            0x12: 0x20,
            0x13: 0x800,
            0x14: 0x8000800,
            0x15: 0x8000020,
            0x16: 0x8020020,
            0x17: 0x20000,
            0x18: 0x0,
            0x19: 0x20020,
            0x1a: 0x8020000,
            0x1b: 0x8000820,
            0x1c: 0x8020820,
            0x1d: 0x20800,
            0x1e: 0x820,
            0x1f: 0x8000000,
            0x80000010: 0x20000,
            0x80000011: 0x800,
            0x80000012: 0x8020020,
            0x80000013: 0x20820,
            0x80000014: 0x20,
            0x80000015: 0x8020000,
            0x80000016: 0x8000000,
            0x80000017: 0x8000820,
            0x80000018: 0x8020820,
            0x80000019: 0x8000020,
            0x8000001a: 0x8000800,
            0x8000001b: 0x0,
            0x8000001c: 0x20800,
            0x8000001d: 0x820,
            0x8000001e: 0x20020,
            0x8000001f: 0x8020800
        }
    ];

    // Masks that select the SBOX input
    var SBOX_MASK = [
        0xf8000001, 0x1f800000, 0x01f80000, 0x001f8000,
        0x0001f800, 0x00001f80, 0x000001f8, 0x8000001f
    ];

    /**
     * DES block cipher algorithm.
     */
    var DES = C_algo.DES = BlockCipher.extend({
        _doReset: function () {
            // Shortcuts
            var key = this._key;
            var keyWords = key.words;

            // Select 56 bits according to PC1
            var keyBits = [];
            for (var i = 0; i < 56; i++) {
                var keyBitPos = PC1[i] - 1;
                keyBits[i] = (keyWords[keyBitPos >>> 5] >>> (31 - keyBitPos % 32)) & 1;
            }

            // Assemble 16 subkeys
            var subKeys = this._subKeys = [];
            for (var nSubKey = 0; nSubKey < 16; nSubKey++) {
                // Create subkey
                var subKey = subKeys[nSubKey] = [];

                // Shortcut
                var bitShift = BIT_SHIFTS[nSubKey];

                // Select 48 bits according to PC2
                for (var i = 0; i < 24; i++) {
                    // Select from the left 28 key bits
                    subKey[(i / 6) | 0] |= keyBits[((PC2[i] - 1) + bitShift) % 28] << (31 - i % 6);

                    // Select from the right 28 key bits
                    subKey[4 + ((i / 6) | 0)] |= keyBits[28 + (((PC2[i + 24] - 1) + bitShift) % 28)] << (31 - i % 6);
                }

                // Since each subkey is applied to an expanded 32-bit input,
                // the subkey can be broken into 8 values scaled to 32-bits,
                // which allows the key to be used without expansion
                subKey[0] = (subKey[0] << 1) | (subKey[0] >>> 31);
                for (var i = 1; i < 7; i++) {
                    subKey[i] = subKey[i] >>> ((i - 1) * 4 + 3);
                }
                subKey[7] = (subKey[7] << 5) | (subKey[7] >>> 27);
            }

            // Compute inverse subkeys
            var invSubKeys = this._invSubKeys = [];
            for (var i = 0; i < 16; i++) {
                invSubKeys[i] = subKeys[15 - i];
            }
        },

        encryptBlock: function (M, offset) {
            this._doCryptBlock(M, offset, this._subKeys);
        },

        decryptBlock: function (M, offset) {
            this._doCryptBlock(M, offset, this._invSubKeys);
        },

        _doCryptBlock: function (M, offset, subKeys) {
            // Get input
            this._lBlock = M[offset];
            this._rBlock = M[offset + 1];

            // Initial permutation
            exchangeLR.call(this, 4,  0x0f0f0f0f);
            exchangeLR.call(this, 16, 0x0000ffff);
            exchangeRL.call(this, 2,  0x33333333);
            exchangeRL.call(this, 8,  0x00ff00ff);
            exchangeLR.call(this, 1,  0x55555555);

            // Rounds
            for (var round = 0; round < 16; round++) {
                // Shortcuts
                var subKey = subKeys[round];
                var lBlock = this._lBlock;
                var rBlock = this._rBlock;

                // Feistel function
                var f = 0;
                for (var i = 0; i < 8; i++) {
                    f |= SBOX_P[i][((rBlock ^ subKey[i]) & SBOX_MASK[i]) >>> 0];
                }
                this._lBlock = rBlock;
                this._rBlock = lBlock ^ f;
            }

            // Undo swap from last round
            var t = this._lBlock;
            this._lBlock = this._rBlock;
            this._rBlock = t;

            // Final permutation
            exchangeLR.call(this, 1,  0x55555555);
            exchangeRL.call(this, 8,  0x00ff00ff);
            exchangeRL.call(this, 2,  0x33333333);
            exchangeLR.call(this, 16, 0x0000ffff);
            exchangeLR.call(this, 4,  0x0f0f0f0f);

            // Set output
            M[offset] = this._lBlock;
            M[offset + 1] = this._rBlock;
        },

        keySize: 64/32,

        ivSize: 64/32,

        blockSize: 64/32
    });

    // Swap bits across the left and right words
    function exchangeLR(offset, mask) {
        var t = ((this._lBlock >>> offset) ^ this._rBlock) & mask;
        this._rBlock ^= t;
        this._lBlock ^= t << offset;
    }

    function exchangeRL(offset, mask) {
        var t = ((this._rBlock >>> offset) ^ this._lBlock) & mask;
        this._lBlock ^= t;
        this._rBlock ^= t << offset;
    }

    /**
     * Shortcut functions to the cipher's object interface.
     *
     * @example
     *
     *     var ciphertext = CryptoJS.DES.encrypt(message, key, cfg);
     *     var plaintext  = CryptoJS.DES.decrypt(ciphertext, key, cfg);
     */
    C.DES = BlockCipher._createHelper(DES);

    /**
     * Triple-DES block cipher algorithm.
     */
    var TripleDES = C_algo.TripleDES = BlockCipher.extend({
        _doReset: function () {
            // Shortcuts
            var key = this._key;
            var keyWords = key.words;

            // Create DES instances
            this._des1 = DES.createEncryptor(WordArray.create(keyWords.slice(0, 2)));
            this._des2 = DES.createEncryptor(WordArray.create(keyWords.slice(2, 4)));
            this._des3 = DES.createEncryptor(WordArray.create(keyWords.slice(4, 6)));
        },

        encryptBlock: function (M, offset) {
            this._des1.encryptBlock(M, offset);
            this._des2.decryptBlock(M, offset);
            this._des3.encryptBlock(M, offset);
        },

        decryptBlock: function (M, offset) {
            this._des3.decryptBlock(M, offset);
            this._des2.encryptBlock(M, offset);
            this._des1.decryptBlock(M, offset);
        },

        keySize: 192/32,

        ivSize: 64/32,

        blockSize: 64/32
    });

    /**
     * Shortcut functions to the cipher's object interface.
     *
     * @example
     *
     *     var ciphertext = CryptoJS.TripleDES.encrypt(message, key, cfg);
     *     var plaintext  = CryptoJS.TripleDES.decrypt(ciphertext, key, cfg);
     */
    C.TripleDES = BlockCipher._createHelper(TripleDES);
}());


//MD5 Algo (md5.js)

(function (Math) {
    // Shortcuts
    var C = CryptoJS;
    var C_lib = C.lib;
    var WordArray = C_lib.WordArray;
    var Hasher = C_lib.Hasher;
    var C_algo = C.algo;

    // Constants table
    var T = [];

    // Compute constants
    (function () {
        for (var i = 0; i < 64; i++) {
            T[i] = (Math.abs(Math.sin(i + 1)) * 0x100000000) | 0;
        }
    }());

    /**
     * MD5 hash algorithm.
     */
    var MD5 = C_algo.MD5 = Hasher.extend({
        _doReset: function () {
            this._hash = new WordArray.init([
                0x67452301, 0xefcdab89,
                0x98badcfe, 0x10325476
            ]);
        },

        _doProcessBlock: function (M, offset) {
            // Swap endian
            for (var i = 0; i < 16; i++) {
                // Shortcuts
                var offset_i = offset + i;
                var M_offset_i = M[offset_i];

                M[offset_i] = (
                    (((M_offset_i << 8)  | (M_offset_i >>> 24)) & 0x00ff00ff) |
                    (((M_offset_i << 24) | (M_offset_i >>> 8))  & 0xff00ff00)
                );
            }

            // Shortcuts
            var H = this._hash.words;

            var M_offset_0  = M[offset + 0];
            var M_offset_1  = M[offset + 1];
            var M_offset_2  = M[offset + 2];
            var M_offset_3  = M[offset + 3];
            var M_offset_4  = M[offset + 4];
            var M_offset_5  = M[offset + 5];
            var M_offset_6  = M[offset + 6];
            var M_offset_7  = M[offset + 7];
            var M_offset_8  = M[offset + 8];
            var M_offset_9  = M[offset + 9];
            var M_offset_10 = M[offset + 10];
            var M_offset_11 = M[offset + 11];
            var M_offset_12 = M[offset + 12];
            var M_offset_13 = M[offset + 13];
            var M_offset_14 = M[offset + 14];
            var M_offset_15 = M[offset + 15];

            // Working varialbes
            var a = H[0];
            var b = H[1];
            var c = H[2];
            var d = H[3];

            // Computation
            a = FF(a, b, c, d, M_offset_0,  7,  T[0]);
            d = FF(d, a, b, c, M_offset_1,  12, T[1]);
            c = FF(c, d, a, b, M_offset_2,  17, T[2]);
            b = FF(b, c, d, a, M_offset_3,  22, T[3]);
            a = FF(a, b, c, d, M_offset_4,  7,  T[4]);
            d = FF(d, a, b, c, M_offset_5,  12, T[5]);
            c = FF(c, d, a, b, M_offset_6,  17, T[6]);
            b = FF(b, c, d, a, M_offset_7,  22, T[7]);
            a = FF(a, b, c, d, M_offset_8,  7,  T[8]);
            d = FF(d, a, b, c, M_offset_9,  12, T[9]);
            c = FF(c, d, a, b, M_offset_10, 17, T[10]);
            b = FF(b, c, d, a, M_offset_11, 22, T[11]);
            a = FF(a, b, c, d, M_offset_12, 7,  T[12]);
            d = FF(d, a, b, c, M_offset_13, 12, T[13]);
            c = FF(c, d, a, b, M_offset_14, 17, T[14]);
            b = FF(b, c, d, a, M_offset_15, 22, T[15]);

            a = GG(a, b, c, d, M_offset_1,  5,  T[16]);
            d = GG(d, a, b, c, M_offset_6,  9,  T[17]);
            c = GG(c, d, a, b, M_offset_11, 14, T[18]);
            b = GG(b, c, d, a, M_offset_0,  20, T[19]);
            a = GG(a, b, c, d, M_offset_5,  5,  T[20]);
            d = GG(d, a, b, c, M_offset_10, 9,  T[21]);
            c = GG(c, d, a, b, M_offset_15, 14, T[22]);
            b = GG(b, c, d, a, M_offset_4,  20, T[23]);
            a = GG(a, b, c, d, M_offset_9,  5,  T[24]);
            d = GG(d, a, b, c, M_offset_14, 9,  T[25]);
            c = GG(c, d, a, b, M_offset_3,  14, T[26]);
            b = GG(b, c, d, a, M_offset_8,  20, T[27]);
            a = GG(a, b, c, d, M_offset_13, 5,  T[28]);
            d = GG(d, a, b, c, M_offset_2,  9,  T[29]);
            c = GG(c, d, a, b, M_offset_7,  14, T[30]);
            b = GG(b, c, d, a, M_offset_12, 20, T[31]);

            a = HH(a, b, c, d, M_offset_5,  4,  T[32]);
            d = HH(d, a, b, c, M_offset_8,  11, T[33]);
            c = HH(c, d, a, b, M_offset_11, 16, T[34]);
            b = HH(b, c, d, a, M_offset_14, 23, T[35]);
            a = HH(a, b, c, d, M_offset_1,  4,  T[36]);
            d = HH(d, a, b, c, M_offset_4,  11, T[37]);
            c = HH(c, d, a, b, M_offset_7,  16, T[38]);
            b = HH(b, c, d, a, M_offset_10, 23, T[39]);
            a = HH(a, b, c, d, M_offset_13, 4,  T[40]);
            d = HH(d, a, b, c, M_offset_0,  11, T[41]);
            c = HH(c, d, a, b, M_offset_3,  16, T[42]);
            b = HH(b, c, d, a, M_offset_6,  23, T[43]);
            a = HH(a, b, c, d, M_offset_9,  4,  T[44]);
            d = HH(d, a, b, c, M_offset_12, 11, T[45]);
            c = HH(c, d, a, b, M_offset_15, 16, T[46]);
            b = HH(b, c, d, a, M_offset_2,  23, T[47]);

            a = II(a, b, c, d, M_offset_0,  6,  T[48]);
            d = II(d, a, b, c, M_offset_7,  10, T[49]);
            c = II(c, d, a, b, M_offset_14, 15, T[50]);
            b = II(b, c, d, a, M_offset_5,  21, T[51]);
            a = II(a, b, c, d, M_offset_12, 6,  T[52]);
            d = II(d, a, b, c, M_offset_3,  10, T[53]);
            c = II(c, d, a, b, M_offset_10, 15, T[54]);
            b = II(b, c, d, a, M_offset_1,  21, T[55]);
            a = II(a, b, c, d, M_offset_8,  6,  T[56]);
            d = II(d, a, b, c, M_offset_15, 10, T[57]);
            c = II(c, d, a, b, M_offset_6,  15, T[58]);
            b = II(b, c, d, a, M_offset_13, 21, T[59]);
            a = II(a, b, c, d, M_offset_4,  6,  T[60]);
            d = II(d, a, b, c, M_offset_11, 10, T[61]);
            c = II(c, d, a, b, M_offset_2,  15, T[62]);
            b = II(b, c, d, a, M_offset_9,  21, T[63]);

            // Intermediate hash value
            H[0] = (H[0] + a) | 0;
            H[1] = (H[1] + b) | 0;
            H[2] = (H[2] + c) | 0;
            H[3] = (H[3] + d) | 0;
        },

        _doFinalize: function () {
            // Shortcuts
            var data = this._data;
            var dataWords = data.words;

            var nBitsTotal = this._nDataBytes * 8;
            var nBitsLeft = data.sigBytes * 8;

            // Add padding
            dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);

            var nBitsTotalH = Math.floor(nBitsTotal / 0x100000000);
            var nBitsTotalL = nBitsTotal;
            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 15] = (
                (((nBitsTotalH << 8)  | (nBitsTotalH >>> 24)) & 0x00ff00ff) |
                (((nBitsTotalH << 24) | (nBitsTotalH >>> 8))  & 0xff00ff00)
            );
            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = (
                (((nBitsTotalL << 8)  | (nBitsTotalL >>> 24)) & 0x00ff00ff) |
                (((nBitsTotalL << 24) | (nBitsTotalL >>> 8))  & 0xff00ff00)
            );

            data.sigBytes = (dataWords.length + 1) * 4;

            // Hash final blocks
            this._process();

            // Shortcuts
            var hash = this._hash;
            var H = hash.words;

            // Swap endian
            for (var i = 0; i < 4; i++) {
                // Shortcut
                var H_i = H[i];

                H[i] = (((H_i << 8)  | (H_i >>> 24)) & 0x00ff00ff) |
                       (((H_i << 24) | (H_i >>> 8))  & 0xff00ff00);
            }

            // Return final computed hash
            return hash;
        },

        clone: function () {
            var clone = Hasher.clone.call(this);
            clone._hash = this._hash.clone();

            return clone;
        }
    });

    function FF(a, b, c, d, x, s, t) {
        var n = a + ((b & c) | (~b & d)) + x + t;
        return ((n << s) | (n >>> (32 - s))) + b;
    }

    function GG(a, b, c, d, x, s, t) {
        var n = a + ((b & d) | (c & ~d)) + x + t;
        return ((n << s) | (n >>> (32 - s))) + b;
    }

    function HH(a, b, c, d, x, s, t) {
        var n = a + (b ^ c ^ d) + x + t;
        return ((n << s) | (n >>> (32 - s))) + b;
    }

    function II(a, b, c, d, x, s, t) {
        var n = a + (c ^ (b | ~d)) + x + t;
        return ((n << s) | (n >>> (32 - s))) + b;
    }

    /**
     * Shortcut function to the hasher's object interface.
     *
     * @param {WordArray|string} message The message to hash.
     *
     * @return {WordArray} The hash.
     *
     * @static
     *
     * @example
     *
     *     var hash = CryptoJS.MD5('message');
     *     var hash = CryptoJS.MD5(wordArray);
     */
    C.MD5 = Hasher._createHelper(MD5);

    /**
     * Shortcut function to the HMAC's object interface.
     *
     * @param {WordArray|string} message The message to hash.
     * @param {WordArray|string} key The secret key.
     *
     * @return {WordArray} The HMAC.
     *
     * @static
     *
     * @example
     *
     *     var hmac = CryptoJS.HmacMD5(message, key);
     */
    C.HmacMD5 = Hasher._createHmacHelper(MD5);
}(Math));

//x64

(function (undefined) {
    // Shortcuts
    var C = CryptoJS;
    var C_lib = C.lib;
    var Base = C_lib.Base;
    var X32WordArray = C_lib.WordArray;

    /**
     * x64 namespace.
     */
    var C_x64 = C.x64 = {};

    /**
     * A 64-bit word.
     */
    var X64Word = C_x64.Word = Base.extend({
        /**
         * Initializes a newly created 64-bit word.
         *
         * @param {number} high The high 32 bits.
         * @param {number} low The low 32 bits.
         *
         * @example
         *
         *     var x64Word = CryptoJS.x64.Word.create(0x00010203, 0x04050607);
         */
        init: function (high, low) {
            this.high = high;
            this.low = low;
        }

        /**
         * Bitwise NOTs this word.
         *
         * @return {X64Word} A new x64-Word object after negating.
         *
         * @example
         *
         *     var negated = x64Word.not();
         */
        // not: function () {
            // var high = ~this.high;
            // var low = ~this.low;

            // return X64Word.create(high, low);
        // },

        /**
         * Bitwise ANDs this word with the passed word.
         *
         * @param {X64Word} word The x64-Word to AND with this word.
         *
         * @return {X64Word} A new x64-Word object after ANDing.
         *
         * @example
         *
         *     var anded = x64Word.and(anotherX64Word);
         */
        // and: function (word) {
            // var high = this.high & word.high;
            // var low = this.low & word.low;

            // return X64Word.create(high, low);
        // },

        /**
         * Bitwise ORs this word with the passed word.
         *
         * @param {X64Word} word The x64-Word to OR with this word.
         *
         * @return {X64Word} A new x64-Word object after ORing.
         *
         * @example
         *
         *     var ored = x64Word.or(anotherX64Word);
         */
        // or: function (word) {
            // var high = this.high | word.high;
            // var low = this.low | word.low;

            // return X64Word.create(high, low);
        // },

        /**
         * Bitwise XORs this word with the passed word.
         *
         * @param {X64Word} word The x64-Word to XOR with this word.
         *
         * @return {X64Word} A new x64-Word object after XORing.
         *
         * @example
         *
         *     var xored = x64Word.xor(anotherX64Word);
         */
        // xor: function (word) {
            // var high = this.high ^ word.high;
            // var low = this.low ^ word.low;

            // return X64Word.create(high, low);
        // },

        /**
         * Shifts this word n bits to the left.
         *
         * @param {number} n The number of bits to shift.
         *
         * @return {X64Word} A new x64-Word object after shifting.
         *
         * @example
         *
         *     var shifted = x64Word.shiftL(25);
         */
        // shiftL: function (n) {
            // if (n < 32) {
                // var high = (this.high << n) | (this.low >>> (32 - n));
                // var low = this.low << n;
            // } else {
                // var high = this.low << (n - 32);
                // var low = 0;
            // }

            // return X64Word.create(high, low);
        // },

        /**
         * Shifts this word n bits to the right.
         *
         * @param {number} n The number of bits to shift.
         *
         * @return {X64Word} A new x64-Word object after shifting.
         *
         * @example
         *
         *     var shifted = x64Word.shiftR(7);
         */
        // shiftR: function (n) {
            // if (n < 32) {
                // var low = (this.low >>> n) | (this.high << (32 - n));
                // var high = this.high >>> n;
            // } else {
                // var low = this.high >>> (n - 32);
                // var high = 0;
            // }

            // return X64Word.create(high, low);
        // },

        /**
         * Rotates this word n bits to the left.
         *
         * @param {number} n The number of bits to rotate.
         *
         * @return {X64Word} A new x64-Word object after rotating.
         *
         * @example
         *
         *     var rotated = x64Word.rotL(25);
         */
        // rotL: function (n) {
            // return this.shiftL(n).or(this.shiftR(64 - n));
        // },

        /**
         * Rotates this word n bits to the right.
         *
         * @param {number} n The number of bits to rotate.
         *
         * @return {X64Word} A new x64-Word object after rotating.
         *
         * @example
         *
         *     var rotated = x64Word.rotR(7);
         */
        // rotR: function (n) {
            // return this.shiftR(n).or(this.shiftL(64 - n));
        // },

        /**
         * Adds this word with the passed word.
         *
         * @param {X64Word} word The x64-Word to add with this word.
         *
         * @return {X64Word} A new x64-Word object after adding.
         *
         * @example
         *
         *     var added = x64Word.add(anotherX64Word);
         */
        // add: function (word) {
            // var low = (this.low + word.low) | 0;
            // var carry = (low >>> 0) < (this.low >>> 0) ? 1 : 0;
            // var high = (this.high + word.high + carry) | 0;

            // return X64Word.create(high, low);
        // }
    });

    /**
     * An array of 64-bit words.
     *
     * @property {Array} words The array of CryptoJS.x64.Word objects.
     * @property {number} sigBytes The number of significant bytes in this word array.
     */
    var X64WordArray = C_x64.WordArray = Base.extend({
        /**
         * Initializes a newly created word array.
         *
         * @param {Array} words (Optional) An array of CryptoJS.x64.Word objects.
         * @param {number} sigBytes (Optional) The number of significant bytes in the words.
         *
         * @example
         *
         *     var wordArray = CryptoJS.x64.WordArray.create();
         *
         *     var wordArray = CryptoJS.x64.WordArray.create([
         *         CryptoJS.x64.Word.create(0x00010203, 0x04050607),
         *         CryptoJS.x64.Word.create(0x18191a1b, 0x1c1d1e1f)
         *     ]);
         *
         *     var wordArray = CryptoJS.x64.WordArray.create([
         *         CryptoJS.x64.Word.create(0x00010203, 0x04050607),
         *         CryptoJS.x64.Word.create(0x18191a1b, 0x1c1d1e1f)
         *     ], 10);
         */
        init: function (words, sigBytes) {
            words = this.words = words || [];

            if (sigBytes != undefined) {
                this.sigBytes = sigBytes;
            } else {
                this.sigBytes = words.length * 8;
            }
        },

        /**
         * Converts this 64-bit word array to a 32-bit word array.
         *
         * @return {CryptoJS.lib.WordArray} This word array's data as a 32-bit word array.
         *
         * @example
         *
         *     var x32WordArray = x64WordArray.toX32();
         */
        toX32: function () {
            // Shortcuts
            var x64Words = this.words;
            var x64WordsLength = x64Words.length;

            // Convert
            var x32Words = [];
            for (var i = 0; i < x64WordsLength; i++) {
                var x64Word = x64Words[i];
                x32Words.push(x64Word.high);
                x32Words.push(x64Word.low);
            }

            return X32WordArray.create(x32Words, this.sigBytes);
        },

        /**
         * Creates a copy of this word array.
         *
         * @return {X64WordArray} The clone.
         *
         * @example
         *
         *     var clone = x64WordArray.clone();
         */
        clone: function () {
            var clone = Base.clone.call(this);

            // Clone "words" array
            var words = clone.words = this.words.slice(0);

            // Clone each X64Word object
            var wordsLength = words.length;
            for (var i = 0; i < wordsLength; i++) {
                words[i] = words[i].clone();
            }

            return clone;
        }
    });
}());

//sha1 Algo (sha1.js)

(function () {
    // Shortcuts
    var C = CryptoJS;
    var C_lib = C.lib;
    var WordArray = C_lib.WordArray;
    var Hasher = C_lib.Hasher;
    var C_algo = C.algo;

    // Reusable object
    var W = [];

    /**
     * SHA-1 hash algorithm.
     */
    var SHA1 = C_algo.SHA1 = Hasher.extend({
        _doReset: function () {
            this._hash = new WordArray.init([
                0x67452301, 0xefcdab89,
                0x98badcfe, 0x10325476,
                0xc3d2e1f0
            ]);
        },

        _doProcessBlock: function (M, offset) {
            // Shortcut
            var H = this._hash.words;

            // Working variables
            var a = H[0];
            var b = H[1];
            var c = H[2];
            var d = H[3];
            var e = H[4];

            // Computation
            for (var i = 0; i < 80; i++) {
                if (i < 16) {
                    W[i] = M[offset + i] | 0;
                } else {
                    var n = W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16];
                    W[i] = (n << 1) | (n >>> 31);
                }

                var t = ((a << 5) | (a >>> 27)) + e + W[i];
                if (i < 20) {
                    t += ((b & c) | (~b & d)) + 0x5a827999;
                } else if (i < 40) {
                    t += (b ^ c ^ d) + 0x6ed9eba1;
                } else if (i < 60) {
                    t += ((b & c) | (b & d) | (c & d)) - 0x70e44324;
                } else /* if (i < 80) */ {
                    t += (b ^ c ^ d) - 0x359d3e2a;
                }

                e = d;
                d = c;
                c = (b << 30) | (b >>> 2);
                b = a;
                a = t;
            }

            // Intermediate hash value
            H[0] = (H[0] + a) | 0;
            H[1] = (H[1] + b) | 0;
            H[2] = (H[2] + c) | 0;
            H[3] = (H[3] + d) | 0;
            H[4] = (H[4] + e) | 0;
        },

        _doFinalize: function () {
            // Shortcuts
            var data = this._data;
            var dataWords = data.words;

            var nBitsTotal = this._nDataBytes * 8;
            var nBitsLeft = data.sigBytes * 8;

            // Add padding
            dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);
            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = Math.floor(nBitsTotal / 0x100000000);
            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 15] = nBitsTotal;
            data.sigBytes = dataWords.length * 4;

            // Hash final blocks
            this._process();

            // Return final computed hash
            return this._hash;
        },

        clone: function () {
            var clone = Hasher.clone.call(this);
            clone._hash = this._hash.clone();

            return clone;
        }
    });

    /**
     * Shortcut function to the hasher's object interface.
     *
     * @param {WordArray|string} message The message to hash.
     *
     * @return {WordArray} The hash.
     *
     * @static
     *
     * @example
     *
     *     var hash = CryptoJS.SHA1('message');
     *     var hash = CryptoJS.SHA1(wordArray);
     */
    C.SHA1 = Hasher._createHelper(SHA1);

    /**
     * Shortcut function to the HMAC's object interface.
     *
     * @param {WordArray|string} message The message to hash.
     * @param {WordArray|string} key The secret key.
     *
     * @return {WordArray} The HMAC.
     *
     * @static
     *
     * @example
     *
     *     var hmac = CryptoJS.HmacSHA1(message, key);
     */
    C.HmacSHA1 = Hasher._createHmacHelper(SHA1);
}());

//sha256 Algo (sha256.js)

(function (Math) {
    // Shortcuts
    var C = CryptoJS;
    var C_lib = C.lib;
    var WordArray = C_lib.WordArray;
    var Hasher = C_lib.Hasher;
    var C_algo = C.algo;

    // Initialization and round constants tables
    var H = [];
    var K = [];

    // Compute constants
    (function () {
        function isPrime(n) {
            var sqrtN = Math.sqrt(n);
            for (var factor = 2; factor <= sqrtN; factor++) {
                if (!(n % factor)) {
                    return false;
                }
            }

            return true;
        }

        function getFractionalBits(n) {
            return ((n - (n | 0)) * 0x100000000) | 0;
        }

        var n = 2;
        var nPrime = 0;
        while (nPrime < 64) {
            if (isPrime(n)) {
                if (nPrime < 8) {
                    H[nPrime] = getFractionalBits(Math.pow(n, 1 / 2));
                }
                K[nPrime] = getFractionalBits(Math.pow(n, 1 / 3));

                nPrime++;
            }

            n++;
        }
    }());

    // Reusable object
    var W = [];

    /**
     * SHA-256 hash algorithm.
     */
    var SHA256 = C_algo.SHA256 = Hasher.extend({
        _doReset: function () {
            this._hash = new WordArray.init(H.slice(0));
        },

        _doProcessBlock: function (M, offset) {
            // Shortcut
            var H = this._hash.words;

            // Working variables
            var a = H[0];
            var b = H[1];
            var c = H[2];
            var d = H[3];
            var e = H[4];
            var f = H[5];
            var g = H[6];
            var h = H[7];

            // Computation
            for (var i = 0; i < 64; i++) {
                if (i < 16) {
                    W[i] = M[offset + i] | 0;
                } else {
                    var gamma0x = W[i - 15];
                    var gamma0  = ((gamma0x << 25) | (gamma0x >>> 7))  ^
                                  ((gamma0x << 14) | (gamma0x >>> 18)) ^
                                   (gamma0x >>> 3);

                    var gamma1x = W[i - 2];
                    var gamma1  = ((gamma1x << 15) | (gamma1x >>> 17)) ^
                                  ((gamma1x << 13) | (gamma1x >>> 19)) ^
                                   (gamma1x >>> 10);

                    W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16];
                }

                var ch  = (e & f) ^ (~e & g);
                var maj = (a & b) ^ (a & c) ^ (b & c);

                var sigma0 = ((a << 30) | (a >>> 2)) ^ ((a << 19) | (a >>> 13)) ^ ((a << 10) | (a >>> 22));
                var sigma1 = ((e << 26) | (e >>> 6)) ^ ((e << 21) | (e >>> 11)) ^ ((e << 7)  | (e >>> 25));

                var t1 = h + sigma1 + ch + K[i] + W[i];
                var t2 = sigma0 + maj;

                h = g;
                g = f;
                f = e;
                e = (d + t1) | 0;
                d = c;
                c = b;
                b = a;
                a = (t1 + t2) | 0;
            }

            // Intermediate hash value
            H[0] = (H[0] + a) | 0;
            H[1] = (H[1] + b) | 0;
            H[2] = (H[2] + c) | 0;
            H[3] = (H[3] + d) | 0;
            H[4] = (H[4] + e) | 0;
            H[5] = (H[5] + f) | 0;
            H[6] = (H[6] + g) | 0;
            H[7] = (H[7] + h) | 0;
        },

        _doFinalize: function () {
            // Shortcuts
            var data = this._data;
            var dataWords = data.words;

            var nBitsTotal = this._nDataBytes * 8;
            var nBitsLeft = data.sigBytes * 8;

            // Add padding
            dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);
            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = Math.floor(nBitsTotal / 0x100000000);
            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 15] = nBitsTotal;
            data.sigBytes = dataWords.length * 4;

            // Hash final blocks
            this._process();

            // Return final computed hash
            return this._hash;
        },

        clone: function () {
            var clone = Hasher.clone.call(this);
            clone._hash = this._hash.clone();

            return clone;
        }
    });

    /**
     * Shortcut function to the hasher's object interface.
     *
     * @param {WordArray|string} message The message to hash.
     *
     * @return {WordArray} The hash.
     *
     * @static
     *
     * @example
     *
     *     var hash = CryptoJS.SHA256('message');
     *     var hash = CryptoJS.SHA256(wordArray);
     */
    C.SHA256 = Hasher._createHelper(SHA256);

    /**
     * Shortcut function to the HMAC's object interface.
     *
     * @param {WordArray|string} message The message to hash.
     * @param {WordArray|string} key The secret key.
     *
     * @return {WordArray} The HMAC.
     *
     * @static
     *
     * @example
     *
     *     var hmac = CryptoJS.HmacSHA256(message, key);
     */
    C.HmacSHA256 = Hasher._createHmacHelper(SHA256);
}(Math));

//sha512 Algo (sha512.js)

(function () {
    // Shortcuts
    var C = CryptoJS;
    var C_lib = C.lib;
    var Hasher = C_lib.Hasher;
    var C_x64 = C.x64;
    var X64Word = C_x64.Word;
    var X64WordArray = C_x64.WordArray;
    var C_algo = C.algo;

    function X64Word_create() {
        return X64Word.create.apply(X64Word, arguments);
    }

    // Constants
    var K = [
        X64Word_create(0x428a2f98, 0xd728ae22), X64Word_create(0x71374491, 0x23ef65cd),
        X64Word_create(0xb5c0fbcf, 0xec4d3b2f), X64Word_create(0xe9b5dba5, 0x8189dbbc),
        X64Word_create(0x3956c25b, 0xf348b538), X64Word_create(0x59f111f1, 0xb605d019),
        X64Word_create(0x923f82a4, 0xaf194f9b), X64Word_create(0xab1c5ed5, 0xda6d8118),
        X64Word_create(0xd807aa98, 0xa3030242), X64Word_create(0x12835b01, 0x45706fbe),
        X64Word_create(0x243185be, 0x4ee4b28c), X64Word_create(0x550c7dc3, 0xd5ffb4e2),
        X64Word_create(0x72be5d74, 0xf27b896f), X64Word_create(0x80deb1fe, 0x3b1696b1),
        X64Word_create(0x9bdc06a7, 0x25c71235), X64Word_create(0xc19bf174, 0xcf692694),
        X64Word_create(0xe49b69c1, 0x9ef14ad2), X64Word_create(0xefbe4786, 0x384f25e3),
        X64Word_create(0x0fc19dc6, 0x8b8cd5b5), X64Word_create(0x240ca1cc, 0x77ac9c65),
        X64Word_create(0x2de92c6f, 0x592b0275), X64Word_create(0x4a7484aa, 0x6ea6e483),
        X64Word_create(0x5cb0a9dc, 0xbd41fbd4), X64Word_create(0x76f988da, 0x831153b5),
        X64Word_create(0x983e5152, 0xee66dfab), X64Word_create(0xa831c66d, 0x2db43210),
        X64Word_create(0xb00327c8, 0x98fb213f), X64Word_create(0xbf597fc7, 0xbeef0ee4),
        X64Word_create(0xc6e00bf3, 0x3da88fc2), X64Word_create(0xd5a79147, 0x930aa725),
        X64Word_create(0x06ca6351, 0xe003826f), X64Word_create(0x14292967, 0x0a0e6e70),
        X64Word_create(0x27b70a85, 0x46d22ffc), X64Word_create(0x2e1b2138, 0x5c26c926),
        X64Word_create(0x4d2c6dfc, 0x5ac42aed), X64Word_create(0x53380d13, 0x9d95b3df),
        X64Word_create(0x650a7354, 0x8baf63de), X64Word_create(0x766a0abb, 0x3c77b2a8),
        X64Word_create(0x81c2c92e, 0x47edaee6), X64Word_create(0x92722c85, 0x1482353b),
        X64Word_create(0xa2bfe8a1, 0x4cf10364), X64Word_create(0xa81a664b, 0xbc423001),
        X64Word_create(0xc24b8b70, 0xd0f89791), X64Word_create(0xc76c51a3, 0x0654be30),
        X64Word_create(0xd192e819, 0xd6ef5218), X64Word_create(0xd6990624, 0x5565a910),
        X64Word_create(0xf40e3585, 0x5771202a), X64Word_create(0x106aa070, 0x32bbd1b8),
        X64Word_create(0x19a4c116, 0xb8d2d0c8), X64Word_create(0x1e376c08, 0x5141ab53),
        X64Word_create(0x2748774c, 0xdf8eeb99), X64Word_create(0x34b0bcb5, 0xe19b48a8),
        X64Word_create(0x391c0cb3, 0xc5c95a63), X64Word_create(0x4ed8aa4a, 0xe3418acb),
        X64Word_create(0x5b9cca4f, 0x7763e373), X64Word_create(0x682e6ff3, 0xd6b2b8a3),
        X64Word_create(0x748f82ee, 0x5defb2fc), X64Word_create(0x78a5636f, 0x43172f60),
        X64Word_create(0x84c87814, 0xa1f0ab72), X64Word_create(0x8cc70208, 0x1a6439ec),
        X64Word_create(0x90befffa, 0x23631e28), X64Word_create(0xa4506ceb, 0xde82bde9),
        X64Word_create(0xbef9a3f7, 0xb2c67915), X64Word_create(0xc67178f2, 0xe372532b),
        X64Word_create(0xca273ece, 0xea26619c), X64Word_create(0xd186b8c7, 0x21c0c207),
        X64Word_create(0xeada7dd6, 0xcde0eb1e), X64Word_create(0xf57d4f7f, 0xee6ed178),
        X64Word_create(0x06f067aa, 0x72176fba), X64Word_create(0x0a637dc5, 0xa2c898a6),
        X64Word_create(0x113f9804, 0xbef90dae), X64Word_create(0x1b710b35, 0x131c471b),
        X64Word_create(0x28db77f5, 0x23047d84), X64Word_create(0x32caab7b, 0x40c72493),
        X64Word_create(0x3c9ebe0a, 0x15c9bebc), X64Word_create(0x431d67c4, 0x9c100d4c),
        X64Word_create(0x4cc5d4be, 0xcb3e42b6), X64Word_create(0x597f299c, 0xfc657e2a),
        X64Word_create(0x5fcb6fab, 0x3ad6faec), X64Word_create(0x6c44198c, 0x4a475817)
    ];

    // Reusable objects
    var W = [];
    (function () {
        for (var i = 0; i < 80; i++) {
            W[i] = X64Word_create();
        }
    }());

    /**
     * SHA-512 hash algorithm.
     */
    var SHA512 = C_algo.SHA512 = Hasher.extend({
        _doReset: function () {
            this._hash = new X64WordArray.init([
                new X64Word.init(0x6a09e667, 0xf3bcc908), new X64Word.init(0xbb67ae85, 0x84caa73b),
                new X64Word.init(0x3c6ef372, 0xfe94f82b), new X64Word.init(0xa54ff53a, 0x5f1d36f1),
                new X64Word.init(0x510e527f, 0xade682d1), new X64Word.init(0x9b05688c, 0x2b3e6c1f),
                new X64Word.init(0x1f83d9ab, 0xfb41bd6b), new X64Word.init(0x5be0cd19, 0x137e2179)
            ]);
        },

        _doProcessBlock: function (M, offset) {
            // Shortcuts
            var H = this._hash.words;

            var H0 = H[0];
            var H1 = H[1];
            var H2 = H[2];
            var H3 = H[3];
            var H4 = H[4];
            var H5 = H[5];
            var H6 = H[6];
            var H7 = H[7];

            var H0h = H0.high;
            var H0l = H0.low;
            var H1h = H1.high;
            var H1l = H1.low;
            var H2h = H2.high;
            var H2l = H2.low;
            var H3h = H3.high;
            var H3l = H3.low;
            var H4h = H4.high;
            var H4l = H4.low;
            var H5h = H5.high;
            var H5l = H5.low;
            var H6h = H6.high;
            var H6l = H6.low;
            var H7h = H7.high;
            var H7l = H7.low;

            // Working variables
            var ah = H0h;
            var al = H0l;
            var bh = H1h;
            var bl = H1l;
            var ch = H2h;
            var cl = H2l;
            var dh = H3h;
            var dl = H3l;
            var eh = H4h;
            var el = H4l;
            var fh = H5h;
            var fl = H5l;
            var gh = H6h;
            var gl = H6l;
            var hh = H7h;
            var hl = H7l;

            // Rounds
            for (var i = 0; i < 80; i++) {
                // Shortcut
                var Wi = W[i];

                // Extend message
                if (i < 16) {
                    var Wih = Wi.high = M[offset + i * 2]     | 0;
                    var Wil = Wi.low  = M[offset + i * 2 + 1] | 0;
                } else {
                    // Gamma0
                    var gamma0x  = W[i - 15];
                    var gamma0xh = gamma0x.high;
                    var gamma0xl = gamma0x.low;
                    var gamma0h  = ((gamma0xh >>> 1) | (gamma0xl << 31)) ^ ((gamma0xh >>> 8) | (gamma0xl << 24)) ^ (gamma0xh >>> 7);
                    var gamma0l  = ((gamma0xl >>> 1) | (gamma0xh << 31)) ^ ((gamma0xl >>> 8) | (gamma0xh << 24)) ^ ((gamma0xl >>> 7) | (gamma0xh << 25));

                    // Gamma1
                    var gamma1x  = W[i - 2];
                    var gamma1xh = gamma1x.high;
                    var gamma1xl = gamma1x.low;
                    var gamma1h  = ((gamma1xh >>> 19) | (gamma1xl << 13)) ^ ((gamma1xh << 3) | (gamma1xl >>> 29)) ^ (gamma1xh >>> 6);
                    var gamma1l  = ((gamma1xl >>> 19) | (gamma1xh << 13)) ^ ((gamma1xl << 3) | (gamma1xh >>> 29)) ^ ((gamma1xl >>> 6) | (gamma1xh << 26));

                    // W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16]
                    var Wi7  = W[i - 7];
                    var Wi7h = Wi7.high;
                    var Wi7l = Wi7.low;

                    var Wi16  = W[i - 16];
                    var Wi16h = Wi16.high;
                    var Wi16l = Wi16.low;

                    var Wil = gamma0l + Wi7l;
                    var Wih = gamma0h + Wi7h + ((Wil >>> 0) < (gamma0l >>> 0) ? 1 : 0);
                    var Wil = Wil + gamma1l;
                    var Wih = Wih + gamma1h + ((Wil >>> 0) < (gamma1l >>> 0) ? 1 : 0);
                    var Wil = Wil + Wi16l;
                    var Wih = Wih + Wi16h + ((Wil >>> 0) < (Wi16l >>> 0) ? 1 : 0);

                    Wi.high = Wih;
                    Wi.low  = Wil;
                }

                var chh  = (eh & fh) ^ (~eh & gh);
                var chl  = (el & fl) ^ (~el & gl);
                var majh = (ah & bh) ^ (ah & ch) ^ (bh & ch);
                var majl = (al & bl) ^ (al & cl) ^ (bl & cl);

                var sigma0h = ((ah >>> 28) | (al << 4))  ^ ((ah << 30)  | (al >>> 2)) ^ ((ah << 25) | (al >>> 7));
                var sigma0l = ((al >>> 28) | (ah << 4))  ^ ((al << 30)  | (ah >>> 2)) ^ ((al << 25) | (ah >>> 7));
                var sigma1h = ((eh >>> 14) | (el << 18)) ^ ((eh >>> 18) | (el << 14)) ^ ((eh << 23) | (el >>> 9));
                var sigma1l = ((el >>> 14) | (eh << 18)) ^ ((el >>> 18) | (eh << 14)) ^ ((el << 23) | (eh >>> 9));

                // t1 = h + sigma1 + ch + K[i] + W[i]
                var Ki  = K[i];
                var Kih = Ki.high;
                var Kil = Ki.low;

                var t1l = hl + sigma1l;
                var t1h = hh + sigma1h + ((t1l >>> 0) < (hl >>> 0) ? 1 : 0);
                var t1l = t1l + chl;
                var t1h = t1h + chh + ((t1l >>> 0) < (chl >>> 0) ? 1 : 0);
                var t1l = t1l + Kil;
                var t1h = t1h + Kih + ((t1l >>> 0) < (Kil >>> 0) ? 1 : 0);
                var t1l = t1l + Wil;
                var t1h = t1h + Wih + ((t1l >>> 0) < (Wil >>> 0) ? 1 : 0);

                // t2 = sigma0 + maj
                var t2l = sigma0l + majl;
                var t2h = sigma0h + majh + ((t2l >>> 0) < (sigma0l >>> 0) ? 1 : 0);

                // Update working variables
                hh = gh;
                hl = gl;
                gh = fh;
                gl = fl;
                fh = eh;
                fl = el;
                el = (dl + t1l) | 0;
                eh = (dh + t1h + ((el >>> 0) < (dl >>> 0) ? 1 : 0)) | 0;
                dh = ch;
                dl = cl;
                ch = bh;
                cl = bl;
                bh = ah;
                bl = al;
                al = (t1l + t2l) | 0;
                ah = (t1h + t2h + ((al >>> 0) < (t1l >>> 0) ? 1 : 0)) | 0;
            }

            // Intermediate hash value
            H0l = H0.low  = (H0l + al);
            H0.high = (H0h + ah + ((H0l >>> 0) < (al >>> 0) ? 1 : 0));
            H1l = H1.low  = (H1l + bl);
            H1.high = (H1h + bh + ((H1l >>> 0) < (bl >>> 0) ? 1 : 0));
            H2l = H2.low  = (H2l + cl);
            H2.high = (H2h + ch + ((H2l >>> 0) < (cl >>> 0) ? 1 : 0));
            H3l = H3.low  = (H3l + dl);
            H3.high = (H3h + dh + ((H3l >>> 0) < (dl >>> 0) ? 1 : 0));
            H4l = H4.low  = (H4l + el);
            H4.high = (H4h + eh + ((H4l >>> 0) < (el >>> 0) ? 1 : 0));
            H5l = H5.low  = (H5l + fl);
            H5.high = (H5h + fh + ((H5l >>> 0) < (fl >>> 0) ? 1 : 0));
            H6l = H6.low  = (H6l + gl);
            H6.high = (H6h + gh + ((H6l >>> 0) < (gl >>> 0) ? 1 : 0));
            H7l = H7.low  = (H7l + hl);
            H7.high = (H7h + hh + ((H7l >>> 0) < (hl >>> 0) ? 1 : 0));
        },

        _doFinalize: function () {
            // Shortcuts
            var data = this._data;
            var dataWords = data.words;

            var nBitsTotal = this._nDataBytes * 8;
            var nBitsLeft = data.sigBytes * 8;

            // Add padding
            dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);
            dataWords[(((nBitsLeft + 128) >>> 10) << 5) + 30] = Math.floor(nBitsTotal / 0x100000000);
            dataWords[(((nBitsLeft + 128) >>> 10) << 5) + 31] = nBitsTotal;
            data.sigBytes = dataWords.length * 4;

            // Hash final blocks
            this._process();

            // Convert hash to 32-bit word array before returning
            var hash = this._hash.toX32();

            // Return final computed hash
            return hash;
        },

        clone: function () {
            var clone = Hasher.clone.call(this);
            clone._hash = this._hash.clone();

            return clone;
        },

        blockSize: 1024/32
    });

    /**
     * Shortcut function to the hasher's object interface.
     *
     * @param {WordArray|string} message The message to hash.
     *
     * @return {WordArray} The hash.
     *
     * @static
     *
     * @example
     *
     *     var hash = CryptoJS.SHA512('message');
     *     var hash = CryptoJS.SHA512(wordArray);
     */
    C.SHA512 = Hasher._createHelper(SHA512);

    /**
     * Shortcut function to the HMAC's object interface.
     *
     * @param {WordArray|string} message The message to hash.
     * @param {WordArray|string} key The secret key.
     *
     * @return {WordArray} The HMAC.
     *
     * @static
     *
     * @example
     *
     *     var hmac = CryptoJS.HmacSHA512(message, key);
     */
    C.HmacSHA512 = Hasher._createHmacHelper(SHA512);
}());

//CFB Mode (mode-cfb.js) Cipher Feedback block mode.

 CryptoJS.mode.CFB = (function () {
    var CFB = CryptoJS.lib.BlockCipherMode.extend();

    CFB.Encryptor = CFB.extend({
        processBlock: function (words, offset) {
            // Shortcuts
            var cipher = this._cipher;
            var blockSize = cipher.blockSize;

            generateKeystreamAndEncrypt.call(this, words, offset, blockSize, cipher);

            // Remember this block to use with next block
            this._prevBlock = words.slice(offset, offset + blockSize);
        }
    });

    CFB.Decryptor = CFB.extend({
        processBlock: function (words, offset) {
            // Shortcuts
            var cipher = this._cipher;
            var blockSize = cipher.blockSize;

            // Remember this block to use with next block
            var thisBlock = words.slice(offset, offset + blockSize);

            generateKeystreamAndEncrypt.call(this, words, offset, blockSize, cipher);

            // This block becomes the previous block
            this._prevBlock = thisBlock;
        }
    });

    function generateKeystreamAndEncrypt(words, offset, blockSize, cipher) {
        // Shortcut
        var iv = this._iv;

        // Generate keystream
        if (iv) {
            var keystream = iv.slice(0);

            // Remove IV for subsequent blocks
            this._iv = undefined;
        } else {
            var keystream = this._prevBlock;
        }
        cipher.encryptBlock(keystream, 0);

        // Encrypt
        for (var i = 0; i < blockSize; i++) {
            words[offset + i] ^= keystream[i];
        }
    }

    return CFB;
}());

//ECB mode (mode-ecb.js)  Electronic Codebook block mode.

 CryptoJS.mode.ECB = (function () {
    var ECB = CryptoJS.lib.BlockCipherMode.extend();

    ECB.Encryptor = ECB.extend({
        processBlock: function (words, offset) {
            this._cipher.encryptBlock(words, offset);
        }
    });

    ECB.Decryptor = ECB.extend({
        processBlock: function (words, offset) {
            this._cipher.decryptBlock(words, offset);
        }
    });

    return ECB;
}());

//OFB mode (mode-ofb.js)  Output Feedback block mode

 CryptoJS.mode.OFB = (function () {
    var OFB = CryptoJS.lib.BlockCipherMode.extend();

    var Encryptor = OFB.Encryptor = OFB.extend({
        processBlock: function (words, offset) {
            // Shortcuts
            var cipher = this._cipher
            var blockSize = cipher.blockSize;
            var iv = this._iv;
            var keystream = this._keystream;

            // Generate keystream
            if (iv) {
                keystream = this._keystream = iv.slice(0);

                // Remove IV for subsequent blocks
                this._iv = undefined;
            }
            cipher.encryptBlock(keystream, 0);

            // Encrypt
            for (var i = 0; i < blockSize; i++) {
                words[offset + i] ^= keystream[i];
            }
        }
    });

    OFB.Decryptor = Encryptor;

    return OFB;
}());

//CTR mode
 CryptoJS.mode.CTR = (function () {
    var CTR = CryptoJS.lib.BlockCipherMode.extend();

    var Encryptor = CTR.Encryptor = CTR.extend({
        processBlock: function (words, offset) {
            // Shortcuts
            var cipher = this._cipher
            var blockSize = cipher.blockSize;
            var iv = this._iv;
            var counter = this._counter;

            // Generate keystream
            if (iv) {
                counter = this._counter = iv.slice(0);

                // Remove IV for subsequent blocks
                this._iv = undefined;
            }
            var keystream = counter.slice(0);
            cipher.encryptBlock(keystream, 0);

            // Increment counter
            counter[blockSize - 1] = (counter[blockSize - 1] + 1) | 0

            // Encrypt
            for (var i = 0; i < blockSize; i++) {
                words[offset + i] ^= keystream[i];
            }
        }
    });

    CTR.Decryptor = Encryptor;

    return CTR;
}());


//Zero padding strategy.
CryptoJS.pad.ZeroPadding = {
    pad: function (data, blockSize) {
        // Shortcut
        var blockSizeBytes = blockSize * 4;

        // Pad
        data.clamp();
        data.sigBytes += blockSizeBytes - ((data.sigBytes % blockSizeBytes) || blockSizeBytes);
    },

    unpad: function (data) {
        // Shortcut
        var dataWords = data.words;

        // Unpad
        var i = data.sigBytes - 1;
        while (!((dataWords[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff)) {
            i--;
        }
        data.sigBytes = i + 1;
    }
};

//No Padding :A noop padding strategy.

 CryptoJS.pad.NoPadding = {
    pad: function () {
    },

    unpad: function () {
    }
};

// ISO/IEC 9797-1 Padding Method 2.

 CryptoJS.pad.Iso97971 = {
    pad: function (data, blockSize) {
        // Add 0x80 byte
        data.concat(CryptoJS.lib.WordArray.create([0x80000000], 1));

        // Zero pad the rest
        CryptoJS.pad.ZeroPadding.pad(data, blockSize);
    },

    unpad: function (data) {
        // Remove zero padding
        CryptoJS.pad.ZeroPadding.unpad(data);

        // Remove one more byte -- the 0x80 byte
        data.sigBytes--;
    }
};

// ISO 10126 padding strategy.

 CryptoJS.pad.Iso10126 = {
    pad: function (data, blockSize) {
        // Shortcut
        var blockSizeBytes = blockSize * 4;

        // Count padding bytes
        var nPaddingBytes = blockSizeBytes - data.sigBytes % blockSizeBytes;

        // Pad
        data.concat(CryptoJS.lib.WordArray.random(nPaddingBytes - 1)).
             concat(CryptoJS.lib.WordArray.create([nPaddingBytes << 24], 1));
    },

    unpad: function (data) {
        // Get number of padding bytes from last byte
        var nPaddingBytes = data.words[(data.sigBytes - 1) >>> 2] & 0xff;

        // Remove padding
        data.sigBytes -= nPaddingBytes;
    }
};

//HMAC

(function () {
    // Shortcuts
    var C = CryptoJS;
    var C_lib = C.lib;
    var Base = C_lib.Base;
    var C_enc = C.enc;
    var Utf8 = C_enc.Utf8;
    var C_algo = C.algo;

    /**
     * HMAC algorithm.
     */
    var HMAC = C_algo.HMAC = Base.extend({
        /**
         * Initializes a newly created HMAC.
         *
         * @param {Hasher} hasher The hash algorithm to use.
         * @param {WordArray|string} key The secret key.
         *
         * @example
         *
         *     var hmacHasher = CryptoJS.algo.HMAC.create(CryptoJS.algo.SHA256, key);
         */
        init: function (hasher, key) {
            // Init hasher
            hasher = this._hasher = new hasher.init();

            // Convert string to WordArray, else assume WordArray already
            if (typeof key == 'string') {
                key = Utf8.parse(key);
            }

            // Shortcuts
            var hasherBlockSize = hasher.blockSize;
            var hasherBlockSizeBytes = hasherBlockSize * 4;

            // Allow arbitrary length keys
            if (key.sigBytes > hasherBlockSizeBytes) {
                key = hasher.finalize(key);
            }

            // Clamp excess bits
            key.clamp();

            // Clone key for inner and outer pads
            var oKey = this._oKey = key.clone();
            var iKey = this._iKey = key.clone();

            // Shortcuts
            var oKeyWords = oKey.words;
            var iKeyWords = iKey.words;

            // XOR keys with pad constants
            for (var i = 0; i < hasherBlockSize; i++) {
                oKeyWords[i] ^= 0x5c5c5c5c;
                iKeyWords[i] ^= 0x36363636;
            }
            oKey.sigBytes = iKey.sigBytes = hasherBlockSizeBytes;

            // Set initial values
            this.reset();
        },

        /**
         * Resets this HMAC to its initial state.
         *
         * @example
         *
         *     hmacHasher.reset();
         */
        reset: function () {
            // Shortcut
            var hasher = this._hasher;

            // Reset
            hasher.reset();
            hasher.update(this._iKey);
        },

        /**
         * Updates this HMAC with a message.
         *
         * @param {WordArray|string} messageUpdate The message to append.
         *
         * @return {HMAC} This HMAC instance.
         *
         * @example
         *
         *     hmacHasher.update('message');
         *     hmacHasher.update(wordArray);
         */
        update: function (messageUpdate) {
            this._hasher.update(messageUpdate);

            // Chainable
            return this;
        },

        /**
         * Finalizes the HMAC computation.
         * Note that the finalize operation is effectively a destructive, read-once operation.
         *
         * @param {WordArray|string} messageUpdate (Optional) A final message update.
         *
         * @return {WordArray} The HMAC.
         *
         * @example
         *
         *     var hmac = hmacHasher.finalize();
         *     var hmac = hmacHasher.finalize('message');
         *     var hmac = hmacHasher.finalize(wordArray);
         */
        finalize: function (messageUpdate) {
            // Shortcut
            var hasher = this._hasher;

            // Compute HMAC
            var innerHash = hasher.finalize(messageUpdate);
            hasher.reset();
            var hmac = hasher.finalize(this._oKey.clone().concat(innerHash));

            return hmac;
        }
    });
}());

//PBKDF2

(function () {
    // Shortcuts
    var C = CryptoJS;
    var C_lib = C.lib;
    var Base = C_lib.Base;
    var WordArray = C_lib.WordArray;
    var C_algo = C.algo;
    var SHA1 = C_algo.SHA1;
    var HMAC = C_algo.HMAC;

    /**
     * Password-Based Key Derivation Function 2 algorithm.
     */
    var PBKDF2 = C_algo.PBKDF2 = Base.extend({
        /**
         * Configuration options.
         *
         * @property {number} keySize The key size in words to generate. Default: 4 (128 bits)
         * @property {Hasher} hasher The hasher to use. Default: SHA1
         * @property {number} iterations The number of iterations to perform. Default: 1
         */
        cfg: Base.extend({
            keySize: 128/32,
            hasher: SHA1,
            iterations: 1
        }),

        /**
         * Initializes a newly created key derivation function.
         *
         * @param {Object} cfg (Optional) The configuration options to use for the derivation.
         *
         * @example
         *
         *     var kdf = CryptoJS.algo.PBKDF2.create();
         *     var kdf = CryptoJS.algo.PBKDF2.create({ keySize: 8 });
         *     var kdf = CryptoJS.algo.PBKDF2.create({ keySize: 8, iterations: 1000 });
         */
        init: function (cfg) {
            this.cfg = this.cfg.extend(cfg);
        },

        /**
         * Computes the Password-Based Key Derivation Function 2.
         *
         * @param {WordArray|string} password The password.
         * @param {WordArray|string} salt A salt.
         *
         * @return {WordArray} The derived key.
         *
         * @example
         *
         *     var key = kdf.compute(password, salt);
         */
        compute: function (password, salt) {
            // Shortcut
            var cfg = this.cfg;

            // Init HMAC
            var hmac = HMAC.create(cfg.hasher, password);

            // Initial values
            var derivedKey = WordArray.create();
            var blockIndex = WordArray.create([0x00000001]);

            // Shortcuts
            var derivedKeyWords = derivedKey.words;
            var blockIndexWords = blockIndex.words;
            var keySize = cfg.keySize;
            var iterations = cfg.iterations;

            // Generate key
            while (derivedKeyWords.length < keySize) {
                var block = hmac.update(salt).finalize(blockIndex);
                hmac.reset();

                // Shortcuts
                var blockWords = block.words;
                var blockWordsLength = blockWords.length;

                // Iterations
                var intermediate = block;
                for (var i = 1; i < iterations; i++) {
                    intermediate = hmac.finalize(intermediate);
                    hmac.reset();

                    // Shortcut
                    var intermediateWords = intermediate.words;

                    // XOR intermediate with block
                    for (var j = 0; j < blockWordsLength; j++) {
                        blockWords[j] ^= intermediateWords[j];
                    }
                }

                derivedKey.concat(block);
                blockIndexWords[0]++;
            }
            derivedKey.sigBytes = keySize * 4;

            return derivedKey;
        }
    });

    /**
     * Computes the Password-Based Key Derivation Function 2.
     *
     * @param {WordArray|string} password The password.
     * @param {WordArray|string} salt A salt.
     * @param {Object} cfg (Optional) The configuration options to use for this computation.
     *
     * @return {WordArray} The derived key.
     *
     * @static
     *
     * @example
     *
     *     var key = CryptoJS.PBKDF2(password, salt);
     *     var key = CryptoJS.PBKDF2(password, salt, { keySize: 8 });
     *     var key = CryptoJS.PBKDF2(password, salt, { keySize: 8, iterations: 1000 });
     */
    C.PBKDF2 = function (password, salt, cfg) {
        return PBKDF2.create(cfg).compute(password, salt);
    };
}());

/* FilePath: lib/apis/kony.js */
/* Version: 202305.0.0 */
/* TimeStamp: Fri Apr 14 2023 18:32:27 */
(function() {
    var $K = kony.$kwebfw$;

    //Available on SPA and DesktopWeb
    var _convertToBase64 = function kony_convertToBase64(rawbytes) {
        var $K = kony.$kwebfw$, $KU = $K.utils;
        var b64 = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
        var o1, o2, o3, h1, h2, h3, h4, bits, i = 0, ac = 0, enc='', tmp_arr = [];

        $KU.log({api:'kony.convertToBase64', enter:true});

        if(!rawbytes) {
            enc = rawbytes;
        } else if('btoa' in window) {
            enc = window.btoa(unescape(encodeURIComponent(rawbytes)));
        } else {
            do{ //Pack three octets into four hexets
                o1 = rawbytes.charCodeAt(i++) & 0xff;
                o2 = rawbytes.charCodeAt(i++) & 0xff;
                o3 = rawbytes.charCodeAt(i++) & 0xff;

                bits = o1<<16 | o2<<8 | o3;

                h1 = bits>>18 & 0x3f;
                h2 = bits>>12 & 0x3f;
                h3 = bits>>6 & 0x3f;
                h4 = bits & 0x3f;

                tmp_arr[ac++] = b64.charAt(h1) + b64.charAt(h2) + b64.charAt(h3) + b64.charAt(h4);
            } while(i < rawbytes.length);

            enc = tmp_arr.join('');

            switch(rawbytes.length % 3) {
                case 1: enc = enc.slice(0, -2) + '==';
                    break;
                case 2: enc = enc.slice(0, -1) + '=';
                    break;
                default: break;
            }
        }

        $KU.log({api:'kony.convertToBase64', exit:true});

        return enc;
    };


    var _print = function kony_print(str) {
        //eslint-disable-next-line no-console
        if(console && typeof console.log === 'function'
        && constants.PRINTSTUB !== 'true') {
            if(typeof str === 'string'
            || typeof str === 'number'
            || typeof str === 'boolean'
            || str === null || str === undefined) {
                //eslint-disable-next-line no-console
                console.log(str);
            } else if(typeof str === 'object' && str) {
                if(JSON) {
                    //eslint-disable-next-line no-console
                    console.log(JSON.stringify(str));
                } else if(typeof str.toString === 'function') {
                    //eslint-disable-next-line no-console
                    console.log(str.toString());
                }
            }
        }
    };


    var _type = function kony_type(variable) {
        var $K = kony.$kwebfw$, $KU = $K.utils, $KW = $K.widget, datatype = '';

        $KU.log({api:'kony.type', enter:true});

        if($KU.is(variable, 'string')) {
            datatype = 'string';
        } else if($KU.is(variable, 'number')) {
            datatype = 'number';
        } else if($KU.is(variable, 'function')) {
            datatype = 'function';
        } else if($KU.is(variable, 'null')) {
            datatype = 'null';
        } else if($KU.is(variable, 'widget')) {
            variable = $KW.proxy(variable);
            datatype = (variable) ? variable._kwebfw_.ns : 'userdata';
        } else {
            datatype = 'userdata';
        }

        $KU.log({api:'kony.type', exit:true});

        return datatype;
    };


    $K.defKonyProp(kony, [
        {keey:'convertToBase64', value:_convertToBase64},
        {keey:'print', value:_print},
        {keey:'type', value:_type}
    ]);

}());

/* FilePath: lib/apis/konyapplication.js */
/* Version: 202305.0.0 */
/* TimeStamp: Fri Apr 14 2023 18:32:27 */
Object.defineProperty(kony, 'application', {configurable:false, enumerable:false, writable:false, value:(function() {
    var _ns = {}, $K = kony.$kwebfw$, _lastFocusedElement = null;


    var _addApplicationCallbacks = function $KAPP_addApplicationCallbacks() {
        //
    };

    var _getBaseURL = function $KAPP_getBaseURL() {
        var $K = kony.$kwebfw$, $KU = $K.utils;
        $KU.log({api:'kony.application.getBaseURL', enter:true});
        $KU.log({api:'kony.application.getBaseURL', exit:true});

        return window.location.host + window.location.pathname;
    };


    var _getBrowserProtocol = function $KAPP_getBrowserProtocol() {
        var $K = kony.$kwebfw$, $KU = $K.utils;
        $KU.log({api:'kony.application.getBrowserProtocol', enter:true});
        $KU.log({api:'kony.application.getBrowserProtocol', exit:true});
        return window.location.protocol;
    };



    var _getCurrentForm = function $KAPP_getCurrentForm() {
    };



    var _openURLAsync = function $KAPP_openURLAsync(config) {
        var $K = kony.$kwebfw$, $KU = $K.utils;

        $KU.log({api:'kony.application.openURLAsync', enter:true});

        if(config.isSameWindow === true) {
            return window.open(config.url, '_self');
        } else if(config.isSameWindow === false) {
            return window.open(config.url, '_blank');
        }
        window.open(config.url, '_blank');


        if($KU.is(config.callback, 'function')) {
            config.callback(constants.OPEN_URL_UNKNOWN);
        }

        $KU.log({api:'kony.application.openURLAsync', exit:true});
    };




    var _removeQueryParamsByKey = function $KAPP_removeQueryParamsByKey(param) {
        var $K = kony.$kwebfw$, $KU = $K.utils,
            baseURL, path, hashValue, searchstring,
            queryParams, finalParams, i, finalurl;

        $KU.log({api:'kony.application.removeQueryParamsByKey', enter:true});

        if(window.location.search.length > 0) {
            baseURL = window.location.href.split('?')[0];
            path = window.location.href.split('?')[1];
            hashValue = path.split('#')[1];
            searchstring = window.location.search.slice(1);
            queryParams = searchstring.split('&');
            finalParams = '';
            for(i = queryParams.length-1; i >= 0; i--) {
                if(queryParams[i].indexOf(param) !== -1) {
                    queryParams.splice(i, 1);
                }
            }

            finalParams = queryParams.join('&');
            if(hashValue) {
                if(queryParams.length === 0) {
                    finalurl = baseURL + '#' + hashValue;
                } else {
                    finalurl = baseURL + '?' + finalParams + '#' + hashValue;
                }
            } else {
                if(queryParams.length === 0) {
                    finalurl = baseURL;
                } else {
                    finalurl = baseURL + '?' + finalParams;
                }
            }
            history.replaceState(null, '', finalurl);
        }

        $KU.log({api:'kony.application.removeQueryParamsByKey', exit:true});
    };



    var _setApplicationInitializationEvents = function $KAPP_setApplicationInitializationEvents(evt) {
    };


    $K.defKonyProp(_ns, [
        {keey:'addApplicationCallbacks', value:_addApplicationCallbacks},
        {keey:'getBaseURL', value: _getBaseURL},
        {keey:'getBrowserProtocol', value:_getBrowserProtocol},
        {keey:'getCurrentForm', value:_getCurrentForm},
        {keey:'openURLAsync', value:_openURLAsync},
        {keey:'removeQueryParamsByKey', value:_removeQueryParamsByKey},
        {keey:'setApplicationInitializationEvents', value:_setApplicationInitializationEvents, writable:true}
    ]);
    return _ns;
}())});

/* FilePath: lib/apis/konyconstants.js */
/* Version: 202305.0.0 */
/* TimeStamp: Fri Apr 14 2023 18:32:27 */
Object.defineProperty(window, 'constants', {configurable:false, enumerable:false, writable:true, value:(function() {
    var _ns = {}, $K = kony.$kwebfw$;

    $K.defKonyProp(_ns, [
        {keey:'ALERT_TYPE_CONFIRMATION', value:'confirmation'},
        {keey:'ALERT_TYPE_ERROR', value:'error'},
        {keey:'ALERT_TYPE_INFO', value:'info'},
        {keey:'API_LEVEL', value:'APILevel'},
        {keey:'API_LEVEL_8200', value:8200},
        {keey:'API_LEVEL_8300', value:8300},
        {keey:'API_LEVEL_8400', value:8400},
        {keey:'API_LEVEL_9200', value:9200},
        {keey:'APPLICATION_MODE_HYBRID', value:'hybrid'},
        {keey:'APPLICATION_MODE_NATIVE', value:'native'},
        {keey:'APPLICATION_MODE_WRAPPER', value:'wrapper'},
        {keey:'BREAKPOINT_MAX_VALUE', value:Number.MAX_VALUE},
        {keey:'BROWSER_REQUEST_METHOD_GET', value:'get'},
        {keey:'BROWSER_REQUEST_METHOD_POST', value:'post'},
        {keey:'CALENDAR_DATE_FORMAT_DEFAULT', value:'dd/MM/yyyy'},
        {keey:'CALENDAR_ICON_ALIGN_AUTO', value:'auto'},
        {keey:'CALENDAR_ICON_ALIGN_LEFT', value:'left'},
        {keey:'CALENDAR_ICON_ALIGN_RIGHT', value:'right'},
        {keey:'CALENDAR_SELECTION_TYPE_MULTI_SELECT', value:'multiselect'},
        {keey:'CALENDAR_SELECTION_TYPE_RANGE_SELECT', value:'rangeselect'},
        {keey:'CALENDAR_SELECTION_TYPE_SINGLE_SELECT', value:'singleselect'},
        {keey:'CALENDAR_VIEW_TYPE_DEFAULT', value:'default'},
        {keey:'CALENDAR_VIEW_TYPE_GRID_ONSCREEN', value:'onscreen'},
        {keey:'CALENDAR_VIEW_TYPE_GRID_POPUP', value:'popup'},
        {keey:'CAMERA_CAPTURE_FAILED', value:'capturefailed'},
        {keey:'CAMERA_NOT_SUPPORTED', value:'notsupported'},
        {keey:'CAMERA_PERMISSION_DENIED', value:'permissiondenied'},
        {keey:'CAMERA_SOURCE_DEFAULT', value:'front'},
        {keey:'CAMERA_SOURCE_FRONT', value:'front'},
        {keey:'CAMERA_SOURCE_FRONT_UNAVAILABLE', value:'frontunavailable'},
        {keey:'CAMERA_SOURCE_REAR', value:'rear'},
        {keey:'CAMERA_SOURCE_REAR_UNAVAILABLE', value:'rearunavailable'},
        {keey:'CAMERA_VIDEO_RECORDING_FAILED', value:'recordingfailed'},
        {keey:'CHECKBOX_ITEM_ORIENTATION_HORIZONTAL', value:'horizontal'},
        {keey:'CHECKBOX_ITEM_ORIENTATION_VERTICAL', value:'vertical'},
        {keey:'CHECKBOX_VIEW_TYPE_CUSTOMVIEW', value:'customview'},
        {keey:'CHECKBOX_VIEW_TYPE_DEFAULTTVIEW', value:'defaultview'},
        {keey:'CHECKBOX_VIEW_TYPE_LISTVIEW', value:'listview'},
        {keey:'CHECKBOX_VIEW_TYPE_ONSCREENWHEEL', value:'onscreenwheel'},
        {keey:'CHECKBOX_VIEW_TYPE_TABLEVIEW', value:'tableview'},
        {keey:'CHECKBOX_VIEW_TYPE_TOGGLEVIEW', value:'toggleview'},
        {keey:'CONTENT_ALIGN_BOTTOM_CENTER', value:'bottomcenter'},
        {keey:'CONTENT_ALIGN_BOTTOM_LEFT', value:'bottomleft'},
        {keey:'CONTENT_ALIGN_BOTTOM_RIGHT', value:'bottomright'},
        {keey:'CONTENT_ALIGN_MIDDLE_LEFT', value:'middleleft'},
        {keey:'CONTENT_ALIGN_MIDDLE_RIGHT', value:'middleright'},
        {keey:'CONTENT_ALIGN_TOP_CENTER', value:'topcenter'},
        {keey:'CONTENT_ALIGN_TOP_LEFT', value:'topleft'},
        {keey:'CONTENT_ALIGN_TOP_RIGHT', value:'topright'},
        {keey:'CONTENT_ALIGN_CENTER', value:'middlecenter'},
        {keey:'DATAGRID_COLUMN_TYPE_IMAGE', value:'image'},
        {keey:'DATAGRID_COLUMN_TYPE_TEMPLATE', value:'template'},
        {keey:'DATAGRID_COLUMN_TYPE_TEXT', value:'text'},
        {keey:'DATAGRID_SCROLLBAR_NONE', value:'none'},
        {keey:'DATAGRID_SCROLLBAR_VERTICAL', value:'vertical'},
        {keey:'DEVICE_ORIENTATION_LANDSCAPE', value:'landscape'},
        {keey:'DEVICE_ORIENTATION_PORTRAIT', value:'portrait'},
        {keey:'DEVICE_OSNAME_ANDROID', value:'android'},
        {keey:'DEVICE_OSNAME_ANDROIDTABLET', value:'androidtablet'},
        {keey:'DEVICE_OSNAME_IPHONE', value:'iPhone'},
        {keey:'DEVICE_OSNAME_IPAD', value:'iPad'},
        {keey:'DEVICE_OSNAME_MACINTOSH', value:'Macintosh'},
        {keey:'DEVICE_OSNAME_WINDOWS', value:'windows'},
        {keey:'DEVICE_OSNAME_WINDOWSTABLET', value:'windowstablet'},
        {keey:'DEVICE_OSNAME_WINDOWPHONE', value:'windowsphone'},
        {keey:'DEVICE_OSNAME_LINUX', value:'Linux'},
        {keey:'FILE_UPLOAD_COMPLETE_STATE', value:'complete'},
        {keey:'FILE_UPLOAD_ERROR_STATE', value:'error'},
        {keey:'FILE_UPLOAD_PROGRESS_STATE', value:'progress'},
        {keey:'FILE_UPLOAD_START_STATE', value:'start'},
        {keey:'FORM_ADJUST_RESIZE', value:'resize'},
        {keey:'FORM_ADJUST_PAN', value:'pan'},
        {keey:'FORM_DEVICE_ORIENTATION_LANDSCAPE', value:'landscape'},
        {keey:'FORM_DEVICE_ORIENTATION_PORTRAIT', value:'portrait'},
        {keey:'FORM_DISPLAY_ORIENTATION_BOTH', value:'both'},
        {keey:'FORM_DISPLAY_ORIENTATION_LANDSCAPE', value:'landscape'},
        {keey:'FORM_DISPLAY_ORIENTATION_PORTRAIT', value:'portrait'},
        {keey:'FORM_FORWARD_NAVIGATION', value:'forward'},
        {keey:'FORM_TYPE_DYNAMIC', value:'dynamic'},
        {keey:'FORM_TYPE_NATIVE', value:'native'},
        {keey:'FORM_TYPE_STATIC', value:'static'},
        {keey:'GESTURE_TYPE_LONGPRESS', value:'longpress'},
        {keey:'GESTURE_TYPE_PAN', value:'pan'},
        {keey:'GESTURE_TYPE_PINCH', value:'pinch'},
        {keey:'GESTURE_TYPE_ROTATION', value:'rotation'},
        {keey:'GESTURE_TYPE_SWIPE', value:'swipe'},
        {keey:'GESTURE_TYPE_TAP', value:'tap'},
        {keey:'HTTP_INTEGRITY_CHECK_FAILED', value:2},
        {keey:'HTTP_INTEGRITY_CHECK_NOT_DONE', value:0},
        {keey:'HTTP_INTEGRITY_CHECK_SUCCESSFUL', value:1},
        {keey:'HTTP_METHOD_GET', value:'get'},
        {keey:'HTTP_METHOD_POST', value:'post'},
        {keey:'HTTP_RESPONSE_TYPE_ARRAYBUFFER', value:'arraybuffer'},
        {keey:'HTTP_RESPONSE_TYPE_BLOB', value:'blob'},
        {keey:'HTTP_RESPONSE_TYPE_DOCUMENT', value:'document'},
        {keey:'HTTP_RESPONSE_TYPE_JSON', value:'json'},
        {keey:'HTTP_RESPONSE_TYPE_RAWDATA', value:'image/png'},
        {keey:'HTTP_RESPONSE_TYPE_TEXT', value:'text'},
        {keey:'HTTP_READY_STATE_DONE', value:'done'},
        {keey:'HTTP_READY_STATE_HEADERS_RECEIVED', value:'headersreceived'},
        {keey:'HTTP_READY_STATE_LOADING', value:'loading'},
        {keey:'HTTP_READY_STATE_OPENED', value:'opened'},
        {keey:'HTTP_READY_STATE_UNSENT', value:'unsent'},
        {keey:'IMAGE_GALLERY_VIEW_TYPE_PAGEVIEW', value:'pageview'},
        {keey:'IMAGE_GLOSSY_EFFECT_DEFAULT', value:'default'},
        {keey:'IMAGE_GLOSSY_EFFECT_LINEAR', value:'linear'},
        {keey:'IMAGE_GLOSSY_EFFECT_RADIAL', value:'radial'},
        {keey:'IMAGE_SCALE_MODE_CROP', value:'crop'},
        {keey:'IMAGE_SCALE_MODE_FIT_TO_DIMENSIONS', value:'fittodimensions'},
        {keey:'IMAGE_SCALE_MODE_MAINTAIN_ASPECT_RATIO', value:'maintainaspectratio'},
        {keey:'LISTBOX_VIEW_TYPE_EDITVIEW', value:'editableview'},
        {keey:'LISTBOX_VIEW_TYPE_LISTVIEW', value:'listview'},
        {keey:'LISTBOX_VIEW_TYPE_ONSCREENWHEEL', value:'onscreenwheel'},
        {keey:'LISTBOX_VIEW_TYPE_TABLEVIEW', value:'tableview'},
        {keey:'LISTBOX_VIEW_TYPE_TOGGLEVIEW', value:'toggleview'},
        {keey:'LISTBOX_VIEW_TYPE_SPINNER', value:'spinner'},
        {keey:'LOADING_SCREEN_POSITION_FULL_SCREEN', value:'fullscreen'},
        {keey:'LOADING_SCREEN_POSITION_ONLY_CENTER', value:'center'},
        {keey:'MAP_PROVIDER_GOOGLE', value:'google'},
        {keey:'MAP_SOURCE_NATIVE', value:'native'},
        {keey:'MAP_SOURCE_NON_NATIVE', value:'non-native'},
        {keey:'MAP_SOURCE_STATIC', value:'static'},
        {keey:'MAP_VIEW_MODE_HYBRID', value:'hybrid'},
        {keey:'MAP_VIEW_MODE_POLYGON', value:'polygon'},
        {keey:'MAP_VIEW_MODE_NORMAL', value:'normal'},
        {keey:'MAP_VIEW_MODE_SATELLITE', value:'satellite'},
        {keey:'MAP_VIEW_MODE_TERRAIN', value:'terrain'},
        {keey:'MAP_HEIGHT_BY_FORM_REFERENCE', value:'formreference'}, // form height
        {keey:'MAP_HEIGHT_BY_PARENT_WIDTH', value:'parentwidth'}, // ref to parent width
        {keey:'MASTER_TYPE_DEFAULT', value:'withoutcontract'},
        {keey:'MASTER_TYPE_USERWIDGET', value:'withcontract'},
        {keey:'NETWORK_TYPE_3G', value:'3G'},
        {keey:'NETWORK_TYPE_ANY', value:'ANY'},
        {keey:'NETWORK_TYPE_ETHERNET', value:'ETHERNET'},
        {keey:'NETWORK_TYPE_WIFI', value:'WIFI'},
        {keey:'ONHOVER_MOUSE_ENTER', value:'enter'},
        {keey:'ONHOVER_MOUSE_LEAVE', value:'leave'},
        {keey:'ONHOVER_MOUSE_MOVE', value:'move'},
        {keey:'OPEN_URL_SUCCESS', value:'success'},
        {keey:'OPEN_URL_FAILURE', value:'failure'},
        {keey:'OPEN_URL_UNKNOWN', value:'unknown'},
        {keey:'PRINTSTUB', value:'@printlevel'},
        {keey:'RADIOGROUP_ITEM_ORIENTATION_HORIZONTAL', value:'horizontal'},
        {keey:'RADIOGROUP_ITEM_ORIENTATION_VERTICAL', value:'vertical'},
        {keey:'RADIOBUTTON_VIEW_TYPE_CUSTOMVIEW', value:'customview'},
        {keey:'RADIOBUTTON_VIEW_TYPE_DEFAULTTVIEW', value:'defaultview'},
        {keey:'SEGUI_DEFAULT_BEHAVIOR', value:'default'},
        {keey:'SEGUI_MULTI_SELECT_BEHAVIOR', value:'multiselect'},
        {keey:'SEGUI_SCROLL_POSITION_DEFAULT', value:'default'},
        {keey:'SEGUI_SCROLL_POSITION_RETAIN', value:'retain'},
        {keey:'SEGUI_SCROLL_POSITION_TOP', value:'top'},
        {keey:'SEGUI_SEARCH_CRITERIA_CONTAINS', value:'CONTAINS'},
        {keey:'SEGUI_SEARCH_CRITERIA_ENDSWITH', value:'ENDSWITH'},
        {keey:'SEGUI_SEARCH_CRITERIA_GREATER', value:'GREATER'},
        {keey:'SEGUI_SEARCH_CRITERIA_GREATER_EQUAL', value:'GREATER_EQUAL'},
        {keey:'SEGUI_SEARCH_CRITERIA_LESSER', value:'LESSER'},
        {keey:'SEGUI_SEARCH_CRITERIA_LESSER_EQUAL', value:'LESSER_EQUAL'},
        {keey:'SEGUI_SEARCH_CRITERIA_NOT_CONTAINS', value:'NOT_CONTAINS'},
        {keey:'SEGUI_SEARCH_CRITERIA_NOT_EQUAL', value:'NOT_EQUAL'},
        {keey:'SEGUI_SEARCH_CRITERIA_NOT_ENDSWITH', value:'NOT_ENDSWITH'},
        {keey:'SEGUI_SEARCH_CRITERIA_NOT_STARTSWITH', value:'NOT_STARTSWITH'},
        {keey:'SEGUI_SEARCH_CRITERIA_OPERATOR_AND', value:'AND'},
        {keey:'SEGUI_SEARCH_CRITERIA_OPERATOR_OR', value:'OR'},
        {keey:'SEGUI_SEARCH_CRITERIA_STARTSWITH', value:'STARTSWITH'},
        {keey:'SEGUI_SEARCH_CRITERIA_STRICT_EQUAL', value:'STRICT_EQUAL'},
        {keey:'SEGUI_SINGLE_SELECT_BEHAVIOR', value:'singleselect'},
        {keey:'SEGUI_VIEW_TYPE_PAGEVIEW', value:'pageview'},
        {keey:'SEGUI_VIEW_TYPE_TABLEVIEW', value:'tableview'},
        {keey:'SLIDER_HORIZONTAL_ORIENTATION', value:'horizontal'},
        {keey:'SLIDER_VERTICAL_ORIENTATION', value:'vertical'},
        {keey:'SLIDER_VIEW_TYPE_DEFAULT', value:'default'},
        {keey:'SLIDER_VIEW_TYPE_PROGRESS', value:'progress'},
        {keey:'TAB_HEADER_POSITION_BOTTOM', value:'bottom'},
        {keey:'TAB_HEADER_POSITION_LEFT', value:'left'},
        {keey:'TAB_HEADER_POSITION_RIGHT', value:'right'},
        {keey:'TAB_HEADER_POSITION_TOP', value:'top'},
        {keey:'TABPANE_COLLAPSIBLE_IMAGE_POSITION_LEFT', value:'left'},
        {keey:'TABPANE_COLLAPSIBLE_IMAGE_POSITION_RIGHT', value:'right'},
        {keey:'TABPANE_COLLAPSIBLE_TABNAME_ALIGNMENT_CENTER', value:'center'},
        {keey:'TABPANE_COLLAPSIBLE_TABNAME_ALIGNMENT_LEFT', value:'left'},
        {keey:'TABPANE_COLLAPSIBLE_TABNAME_ALIGNMENT_RIGHT', value:'right'},
        {keey:'TABPANE_VIEW_TYPE_COLLAPSIBLEVIEW', value:'collapsibleview'},
        {keey:'TABPANE_VIEW_TYPE_PAGEVIEW', value:'pageview'},
        {keey:'TABPANE_VIEW_TYPE_TABVIEW', value:'tabview'},
        {keey:'TEXTBOX_AUTO_CAPITALIZE_ALL', value:'characters'},
        {keey:'TEXTBOX_AUTO_CAPITALIZE_NONE', value:'none'},
        {keey:'TEXTBOX_AUTO_CAPITALIZE_SENTENCES', value:'sentences'},
        {keey:'TEXTBOX_AUTO_CAPITALIZE_WORDS', value:'words'},
        {keey:'TEXTBOX_CUSTOM_HEIGHT', value:'custom'},
        {keey:'TEXTBOX_DEFAULT_PLATFORM_HEIGHT', value:'default'},
        {keey:'TEXTBOX_FONT_METRICS_DRIVEN_HEIGHT', value:'fontmetrics'},
        {keey:'TEXTBOX_INPUT_MODE_ANY', value:'any'},
        {keey:'TEXTBOX_INPUT_MODE_NUMERIC', value:'numeric'},
        {keey:'TEXTBOX_INPUT_MODE_PASSWORD', value:'password'},
        {keey:'TEXTBOX_KEY_BOARD_STYLE_CHAT', value:'chat'},
        {keey:'TEXTBOX_KEY_BOARD_STYLE_DECIMAL', value:'decimal'},
        {keey:'TEXTBOX_KEY_BOARD_STYLE_DEFAULT', value:'text'},
        {keey:'TEXTBOX_KEY_BOARD_STYLE_EMAIL', value:'email'},
        {keey:'TEXTBOX_KEY_BOARD_STYLE_NONE', value:'none'},
        {keey:'TEXTBOX_KEY_BOARD_STYLE_NUMBER_PAD', value:'numeric'},
        {keey:'TEXTBOX_KEY_BOARD_STYLE_PHONE_PAD', value:'tel'},
        {keey:'TEXTBOX_KEY_BOARD_STYLE_SEARCH', value:'search'},
        {keey:'TEXTBOX_KEY_BOARD_STYLE_URL', value:'url'},
        {keey:'TEXTBOX_VIEW_TYPE_DEFAULT', value:'default'},
        {keey:'TEXTBOX_VIEW_TYPE_SEARCH_VIEW', value:'search'},
        {keey:'TEXTAREA_INPUT_MODE_ANY', value:'any'},
        {keey:'TEXTAREA_INPUT_MODE_NUMERIC', value:'numeric'},
        {keey:'TEXTAREA_KEY_BOARD_STYLE_CHAT', value:'chat'},
        {keey:'TEXTAREA_KEY_BOARD_STYLE_DECIMAL', value:'decimal'},
        {keey:'TEXTAREA_KEY_BOARD_STYLE_DEFAULT', value:'text'},
        {keey:'TEXTAREA_KEY_BOARD_STYLE_EMAIL', value:'email'},
        {keey:'TEXTAREA_KEY_BOARD_STYLE_NONE', value:'none'},
        {keey:'TEXTAREA_KEY_BOARD_STYLE_NUMBER_PAD', value:'numeric'},
        {keey:'TEXTAREA_KEY_BOARD_STYLE_PHONE_PAD', value:'tel'},
        {keey:'TEXTAREA_KEY_BOARD_STYLE_SEARCH', value:'search'},
        {keey:'TEXTAREA_KEY_BOARD_STYLE_URL', value:'url'},
        {keey:'TEXTAREA_AUTO_CAPITALIZE_ALL', value:'characters'},
        {keey:'TEXTAREA_AUTO_CAPITALIZE_NONE', value:'none'},
        {keey:'TEXTAREA_AUTO_CAPITALIZE_SENTENCES', value:'sentences'},
        {keey:'TEXTAREA_AUTO_CAPITALIZE_WORDS', value:'words'},
        {keey:'UPLOAD_MAX_WAIT_TIME', value:120000}, // 2 mins
        {keey:'WIDGET_ALIGN_BOTTOM_CENTER', value:'bottomcenter'},
        {keey:'WIDGET_ALIGN_BOTTOM_LEFT', value:'bottomleft'},
        {keey:'WIDGET_ALIGN_BOTTOM_RIGHT', value:'bottomright'},
        {keey:'WIDGET_ALIGN_CENTER', value:'middlecenter'},
        {keey:'WIDGET_ALIGN_MIDDLE_LEFT', value:'middleleft'},
        {keey:'WIDGET_ALIGN_MIDDLE_RIGHT', value:'middleright'},
        {keey:'WIDGET_ALIGN_TOP_CENTER', value:'topcenter'},
        {keey:'WIDGET_ALIGN_TOP_LEFT', value:'topleft'},
        {keey:'WIDGET_ALIGN_TOP_RIGHT', value:'topright'},
        {keey:'WIDGET_DIRECTION_LTR', value:'ltr'},
        {keey:'WIDGET_DIRECTION_RTL', value:'rtl'}
    ]);

    return _ns;
}())});


/* FilePath: lib/utils/konyutils.js */
/* Version: 202305.0.0 */
/* TimeStamp: Fri Apr 14 2023 18:32:28 */

Object.defineProperty(kony.$kwebfw$, 'utils', {configurable:false, enumerable:false, writable:false, value:(function() {
    var _ns = {}, $K = kony.$kwebfw$, __uid = null,
        __browser = {supports:{}}, __is = {
            argument: function(datatype) {
                return (datatype === 'argument');
            },

            array: function(datatype) {
                return (datatype === 'array');
            },

            boolean: function(datatype) {
                return (datatype === 'boolean');
            },

            color: function(datatype, obj) {
                var flag = false;

                if(datatype === 'string') {
                    flag = (!obj) ? true : (/(^[0-9A-F]{8}$)|(^[0-9A-F]{6}$)/i.test(obj));

                    if(!flag && obj.indexOf('$') === 0) flag = true; //Color constants support

                    return flag;
                }
                return flag;
            },

            date: function(datatype, obj) {
                if(datatype === 'date') {
                    return true;
                } else if(datatype === 'array' && [3, 6].indexOf(obj.length) >= 0) {
                    return _isDateString((obj[2]+'-'+obj[1]+'-'+obj[0]+' '+(obj[3] || 0)+':'+(obj[4] || 0)+':'+(obj[5] || 0)));
                }
                return false;
            },

            decimal: function(datatype, obj) {
                return (datatype === 'number' && !__is.integer(datatype, obj));
            },

            document: function(datatype) {
                return (datatype === 'document');
            },

            dom: function(datatype) {
                return (datatype === 'node');
            },

            empty: function(datatype, obj) {
                var k = '';

                if(datatype === 'null' || datatype === 'undefined') {
                    return true;
                } else if(datatype === 'string' || __is.list(datatype, obj)) {
                    return (obj.length === 0);
                } else if(datatype === 'object') {
                    for(k in obj) {
                        if(Object.prototype.hasOwnProperty.call(obj, k)) {
                            return false;
                        }
                    }
                    return true;
                }
                return false;
            },

            equals: function(datatype, obj, a) {
                var i = 0, k = '', adatatype = _datatype(a);

                if(datatype !== adatatype) {
                    return false;
                } else if(__is.list(adatatype, a)) {
                    if(obj.length !== a.length) {
                        return false;
                    }
                    for(i=0; i<a.length; i++) {
                        if(!__is.equals(_datatype(obj[i]), obj[i], a[i])) {
                            return false;
                        }
                    }
                    return true;
                } else if(adatatype === 'object') {
                    if(_size(a) !== _size(obj)) {
                        return false;
                    }
                    for(k in a) {
                        if(Object.prototype.hasOwnProperty.call(a, k)) {
                            if(!__is.equals(_datatype(obj[k]), obj[k], a[k])) {
                                return false;
                            }
                        }
                    }
                    return true;
                }
                return (obj === a);
            },

            event: function(datatype) {
                return (['event', 'touch'].indexOf(datatype) >= 0);
            },

            fragment: function(datatype) {
                return (datatype === 'fragment');
            },

            function: function(datatype) {
                return (datatype === 'function');
            },

            i18n: function(datatype, obj) {
                return (datatype === 'string' && obj.indexOf('kony.i18n.getLocalizedString(') === 0);
            },

            integer: function(datatype, obj) {
                return (datatype === 'number' && Math.ceil(obj) === Math.floor(obj));
            },

            leapyear: function(datatype, obj) {
                if(datatype === 'number' && obj >= 1000 && obj <= 9999) {
                    obj = new Date(obj, 1, 29, 0, 0, 0);
                    return (obj.getMonth() === 1) ? true : false;
                } else if(datatype === 'date') {
                    obj = new Date(obj.getFullYear(), 1, 29, 0, 0, 0);
                    return (obj.getMonth() === 1) ? true : false;
                }
                return false;
            },

            list: function(datatype) {
                return ([
                    'argument',
                    'array',
                    'cssrulelist',
                    'nodelist',
                    'stylesheetlist',
                    'filelist',
                    'touchlist'
                ].indexOf(datatype) >= 0);
            },

            null: function(datatype) {
                return (datatype === 'null');
            },

            number: function(datatype) {
                return (datatype === 'number');
            },

            numeric: function(datatype, obj) {
                var regexp = /^\s*(\+|-)?((\d+(\.\d+)?)|(\.\d+))\s*$/;
                return (datatype === 'string' && regexp.test(obj));
            },

            object: function(datatype) {
                return (['object', 'widget'].indexOf(datatype) >= 0);
            },

            size: function(datatype, obj, arg2) {
                if(datatype === 'number') {
                    if(arg2 === true) { //Only +ve number
                        return (obj >= 0);
                    } else if(arg2 === false) { //Only -ve number
                        return (obj <= 0);
                    } //Both +ve/-ve number
                    return true;
                } else if(datatype === 'string') {
                    if(!obj) {
                        return true;
                    } else if(__is.numeric(datatype, obj)) {
                        return false;
                    } else if(arg2 === true) { //Only +ve number
                        return (/^([0-9]+)(\.[0-9]+)?(px|%|dp)?$/.test(obj));
                    } else if(arg2 === false) { //Only -ve number
                        return (/^[-]([0-9]+)(\.[0-9]+)?(px|%|dp)?$/.test(obj));
                    } //Both +ve/-ve number
                    return (/^[-+]?([0-9]+)(\.[0-9]+)?(px|%|dp)?$/.test(obj));
                }
                return false;
            },

            skinningConstant: function(datatype, value) {
                return (datatype === 'string' && value.indexOf('$') === 0);
            },

            string: function(datatype) {
                return (datatype === 'string');
            },

            undefined: function(datatype) {
                return (datatype === 'undefined');
            },

            widget: function(datatype, obj, arg2) {
                if(datatype !== 'widget') {
                    return false;
                }
                if(!arg2) { //arg2 is expected to be a "string"
                    return true;
                } else if(arg2 === 'component') {
                    if((obj instanceof kony.ui.UserWidget
                        || obj instanceof kony.ui.FlexContainer
                        || obj instanceof kony.ui.FlexScrollContainer)
                        && _datatype(obj._kwebfw_.is.component) === 'object') {
                        return true;
                    }
                    return false;
                } else if(arg2 === 'inherited') {
                    if(obj.__$kwebfw$ns__ && obj.__$kwebfw$name__
                        && !Object.prototype.hasOwnProperty.call(obj, '__$kwebfw$ns__')
                        && !Object.prototype.hasOwnProperty.call(obj, '__$kwebfw$name__')) {
                        return true;
                    }
                    return false;
                } else if(obj instanceof kony.ui[arg2]
                    && (obj.__$kwebfw$name__ === arg2
                    || obj._kwebfw_.ns === ('kony.ui.'+arg2))) {
                    return true;
                }
                return false;
            },

            window: function(datatype) {
                return (datatype === 'window');
            }
        };


    var _accessorDescriptor = function $KU_accessorDescriptor(configurable, prop, fn) {
        var desc = {enumerable:true, configurable:configurable};

        desc[prop] = fn;

        return desc;
    };


    var _browser = function $KU_browser(info, supports) {
        var ua = navigator.userAgent.toLowerCase(), index = -1,
            name = '', os = '', version = '', channel = '',
            orientation = null, bodyHeight = 0, bodyWidth = 0;

        if(_is(info, 'string') && info) info = info.toLowerCase();
        if(_is(supports, 'string') && supports) supports = supports.toLowerCase();

        if(ua.indexOf('edg/') >= 0) {
            ua = ua.replace('edg/', 'edge/');
        } else if(ua.indexOf('trident/') >= 0
        && ua.indexOf('rv:11.0') >= 0) {
            ua = ua.replace('rv:11.0', 'msie/11.0');
        }

        if(info === 'orientation') {
            orientation = screen.orientation || screen.mozOrientation || screen.msOrientation;

            if(window.ScreenOrientation
            && orientation instanceof ScreenOrientation) {
                if(orientation.type === 'portrait-primary'
                || orientation.type === 'portrait-secondary') {
                    return 'portrait';
                } else if(orientation.type === 'landscape-primary'
                || orientation.type === 'landscape-secondary') {
                    return 'landscape';
                }
                return 'portrait';
            } else if(typeof window.orientation === 'number') {
                if(window.orientation === 0 || window.orientation === 180) {
                    if(_browser('os') === 'android'
                    && _browser('channel') === 'tablet') {
                        return 'landscape';
                    }
                    return 'portrait';
                } else if(window.orientation === 90 || window.orientation === -90) {
                    if(_browser('os') === 'android'
                    && _browser('channel') === 'tablet') {
                        return 'portrait';
                    }
                    return 'landscape';
                }
                return 'portrait';
            } else if(window.matchMedia) {
                if(window.matchMedia('(orientation: portrait)').matches) {
                    return 'portrait';
                } else if(window.matchMedia('(orientation: landscape)').matches) {
                    return 'landscape';
                }
                return 'portrait';
            }
            bodyHeight = document.body.offsetHeight;
            bodyWidth = document.body.offsetWidth;
            if(bodyHeight > bodyWidth) {
                return 'portrait';
            } else if(bodyHeight < bodyWidth) {
                return 'landscape';
            }
            return 'portrait';
        } else if(info === 'channel') {
            if(!Object.prototype.hasOwnProperty.call(__browser, info)) {
                os = _browser('os');
                if(ua.indexOf('mobile') >= 0) {
                    if(os === 'ios') {
                        __browser[info] = (ua.indexOf('iphone') >= 0)
                            ? 'mobile' : (ua.indexOf('ipad') >= 0)
                                ? 'tablet' : 'desktop';
                    } else if(os === 'windows') {
                        __browser[info] = (ua.indexOf('phone') >= 0)
                            ? 'mobile' : (ua.indexOf('tablet') >= 0)
                                ? 'tablet' : 'desktop';
                    } else {
                        __browser[info] = 'mobile';
                    }
                } else if(ua.indexOf('tablet') >= 0) {
                    __browser[info] = 'tablet';
                } else {
                    __browser[info] = 'desktop';
                }
            }
        } else if(info === 'os') {
            if(!Object.prototype.hasOwnProperty.call(__browser, info)) {
                if(ua.indexOf('mac os') >= 0) {
                    __browser[info] = 'ios';
                } else if(ua.indexOf('windows') >= 0) {
                    __browser[info] = 'windows';
                } else if(ua.indexOf('android') >= 0) {
                    __browser[info] = 'android';
                } else {
                    __browser[info] = 'unknown';
                }
            }
        } else if(info === 'osversion') {
            if(!Object.prototype.hasOwnProperty.call(__browser, info)) {
                os = _browser('os');
            }
        } else if(info === 'name') {
            if(!Object.prototype.hasOwnProperty.call(__browser, info)) {
                //NOTE:: Order of if/else condition matters
                if(ua.indexOf('edge') >= 0) {
                    __browser[info] = 'edge';
                } else if(ua.indexOf('msie') >= 0) {
                    __browser[info] = 'msie';
                } else if(ua.indexOf('chrome') >= 0) {
                    __browser[info] = 'chrome';
                } else if(ua.indexOf('firefox') >= 0) {
                    __browser[info] = 'firefox';
                } else if(ua.indexOf('safari') >= 0) {
                    __browser[info] = 'safari';
                } else {
                    __browser[info] = 'unknown';
                }
            }
        } else if(info === 'device') {
            if(!Object.prototype.hasOwnProperty.call(__browser, info)) {
                os = _browser('os');
                channel = _browser('channel');

                if(channel === 'desktop') {
                    __browser[info] = 'desktop';
                } else if(os === 'android') {
                    __browser[info] = (channel === 'tablet')
                        ? 'androidtablet' : 'android';
                } else if(os === 'ios') {
                    __browser[info] = (channel === 'tablet') ? 'ipad'
                        : (channel === 'mobile') ? 'iphone' : 'mac';
                } else if(os === 'windows') {
                    __browser[info] = (channel === 'tablet') ? 'windowstablet'
                        : (channel === 'mobile') ? 'windowsphone' : 'pc';
                }
            }
        } else if(info === 'version') {
            if(!Object.prototype.hasOwnProperty.call(__browser, info)) {
                name = _browser('name');
                index = ua.indexOf(name+'/');
                if(index >= 0) {
                    index += (name.length + 1);
                    while(index < ua.length && ['.', '-', '_', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9'].indexOf(ua[index]) >= 0) {
                        version += ua[index];
                        index++;
                    }
                }
                __browser[info] = (version) ? version : 'unknown';
            }
        } else if(info === 'engine') {
            if(!Object.prototype.hasOwnProperty.call(__browser, info)) {
                name = _browser('name');
                if(['chrome', 'safari', 'edge'].indexOf(name) >= 0) {
                    __browser[info] = 'webkit';
                } else if(name === 'firefox') {
                    __browser[info] = 'moz';
                } else if(name === 'msie') {
                    __browser[info] = 'ms';
                } else {
                    __browser[info] = 'unknown';
                }
            }
        } else if(info === 'devicememory') {
            if(!Object.prototype.hasOwnProperty.call(__browser, info)) {
                __browser[info] = navigator.deviceMemory;
            }
        } else if(info === 'language') {
            if(!Object.prototype.hasOwnProperty.call(__browser, info)) {
                __browser[info] = navigator.language
                               || navigator.userLanguage
                               || navigator.browserLanguage;
            }
        } else if(info === 'supports') {
            if(supports === 'cookies') {
                if(!Object.prototype.hasOwnProperty.call(__browser[info], supports)) {
                    __browser[info][supports] = navigator.cookieEnabled;
                }
            } else if(supports === 'cache') {
                if(Object.prototype.hasOwnProperty.call(__browser[info], supports)) {
                    __browser[info][supports] = (window.caches
                                              && window.caches instanceof CacheStorage)
                        ? true : false;
                }
            } else if(supports === 'appcache') {
                if(!Object.prototype.hasOwnProperty.call(__browser[info], supports)) {
                    __browser[info][supports] = (window.applicationCache
                                              && window.applicationCache instanceof ApplicationCache)
                        ? true : false;
                }
            } else if(supports === 'battery') {
                if(!Object.prototype.hasOwnProperty.call(__browser[info], supports)) {
                    __browser[info][supports] = (_is(navigator.getBattery, 'function'))
                        ? true : false;
                }
            } else if(supports === 'bluetooth') {
                if(!Object.prototype.hasOwnProperty.call(__browser[info], supports)) {
                    __browser[info][supports] = '//TODO::';
                }
            } else if(supports === 'usb') {
                if(!Object.prototype.hasOwnProperty.call(__browser[info], supports)) {
                    __browser[info][supports] = '//TODO::';
                }
            } else if(supports === 'clipboard') {
                if(!Object.prototype.hasOwnProperty.call(__browser[info], supports)) {
                    __browser[info][supports] = '//TODO::';
                }
            } else if(supports === 'connection') {
                if(!Object.prototype.hasOwnProperty.call(__browser[info], supports)) {
                    __browser[info][supports] = (navigator.connection instanceof NetworkInformation)
                        ? true : false;
                }
            } else if(supports === 'displaymedia') {
                if(!Object.prototype.hasOwnProperty.call(__browser[info], supports)) {
                    __browser[info][supports] = (_is(navigator.mediaDevices.getDisplayMedia, 'function'))
                        ? true : false;
                }
            } else if(supports === 'fullscreen') {
                if(!Object.prototype.hasOwnProperty.call(__browser[info], supports)) {
                    __browser[info][supports] = document.fullscreenEnabled;
                }
            } else if(supports === 'geolocation') {
                if(!Object.prototype.hasOwnProperty.call(__browser[info], supports)) {
                    __browser[info][supports] = navigator.geolocation ? true : false;
                }
            } else if(supports === 'orientation') {
                if(!Object.prototype.hasOwnProperty.call(__browser[info], supports)) {
                    __browser[info][supports] = ('onorientationchange' in window);
                }
            } else if(supports === 'touch') {
                if(!Object.prototype.hasOwnProperty.call(__browser[info], supports)) {
                    __browser[info][supports] = ('ontouchstart' in window);
                }
            } else if(supports === 'localstorage') {
                if(!Object.prototype.hasOwnProperty.call(__browser[info], supports)) {
                    __browser[info][supports] = (localStorage
                                              && localStorage instanceof Storage)
                        ? true : false;
                }
            } else if(supports === 'mediarecorder') {
                if(!Object.prototype.hasOwnProperty.call(__browser[info], supports)) {
                    __browser[info][supports] = (_is(window.MediaRecorder, 'function'))
                        ? true : false;
                }
            } else if(supports === 'sessionstorage') {
                if(!Object.prototype.hasOwnProperty.call(__browser[info], supports)) {
                    __browser[info][supports] = (sessionStorage
                                              && sessionStorage instanceof Storage)
                        ? true : false;
                }
            } else if(supports === 'usermedia') {
                if(!Object.prototype.hasOwnProperty.call(__browser[info], supports)) {
                    __browser[info][supports] = (navigator.mediaDevices
                                              && _is(navigator.mediaDevices.getUserMedia, 'function'))
                        ? true : false;
                }
            } else if(supports === 'webshare') {
                if(!Object.prototype.hasOwnProperty.call(__browser[info], supports)) {
                    __browser[info][supports] = (_is(navigator.share, 'function'))
                        ? true : false;
                }
            } else if(supports === 'speechrecognition') {
                if(!Object.prototype.hasOwnProperty.call(__browser[info], supports)) {
                    __browser[info][supports] = (_is(window.webkitSpeechRecognition, 'function'))
                        ? true : false;
                }
            } else if(supports === 'contacts') {
                if(!Object.prototype.hasOwnProperty.call(__browser[info], supports)) {
                    __browser[info][supports] = (_is(navigator.contacts, 'function'))
                        ? true : false;
                }
            } else if(supports === 'getwakelock') {
                if(!Object.prototype.hasOwnProperty.call(__browser[info], supports)) {
                    __browser[info][supports] = (_is(navigator.getWakeLock, 'function'))
                        ? true : false;
                }
            }
        }

        if(_is(info, 'string') && info) {
            return (info === 'supports' && _is(supports, 'string') && supports)
                ? __browser[info][supports] : __browser[info];
        }
        return __browser;
    };


    var _datatype = function $KU_datatype(obj, arg1) {
        var objStr = '';
        objStr = Object.prototype.toString.call(obj);

        if(objStr === '[object Boolean]' || obj instanceof Boolean) {
            return 'boolean';
        } else if(objStr === '[object String]' || obj instanceof String) {
            return 'string';
        } else if(objStr === '[object Function]' || obj instanceof Function) {
            return 'function';
        } else if(objStr === '[object Undefined]' || obj === arg1) {
            return 'undefined';
        } else if(objStr === '[object Number]' && !isNaN(obj)) {
            return 'number';
        } else if(objStr === '[object Object]') { // || obj instanceof Object
            return 'object';
        } else if(objStr === '[object Array]' || obj instanceof Array) {
            return 'array';
        } else if(objStr === '[object Null]' || obj === null) {
            return 'null';
        } else if(objStr === '[object NodeList]' || objStr === '[object HTMLCollection]'
            || obj instanceof NodeList || obj instanceof HTMLCollection) {
            return 'nodelist';
        } else if(objStr === '[object StyleSheetList]' || obj instanceof StyleSheetList) {
            return 'stylesheetlist';
        } else if(objStr === '[object CSSRuleList]' || obj instanceof CSSRuleList) {
            return 'cssrulelist';
        } else if(objStr === '[object FileList]' || obj instanceof FileList) {
            return 'filelist';
        } else if(objStr === '[object TouchList]') {
            return 'touchlist';
        } else if((objStr === '[object Date]' || obj instanceof Date)
            && (obj.toDateString() !== 'Invalid Date' || !isNaN(obj.getTime()))) {
            return 'date';
        } else if(objStr === '[object Arguments]') {
            return 'argument';
        } else if(obj && obj.tagName) {
            return 'node';
        } else if(obj && obj.type) {
            return 'event';
        } else if(objStr === '[object Touch]') {
            return 'touch';
        } else if(objStr === '[object HTMLDocument]' || objStr === '[object Document]'
            || obj instanceof HTMLDocument || obj instanceof Document) {
            return 'document';
        } else if(objStr === '[object DocumentFragment]' || obj instanceof DocumentFragment) {
            return 'fragment';
        } else if(objStr === '[object global]' || objStr === '[object Window]' || obj === window) {
            return 'window';
        }
        return '';

    };


    //NOTE:: defineGetter must be called before defineSetter
    var _defineGetter = function $KU_defineGetter(obj, prop, get, configurable) {
        if(typeof configurable !== 'boolean') configurable = true;

        if(Object.defineProperty) {
            return Object.defineProperty(obj, prop, _accessorDescriptor(configurable, 'get', get));
        } else if(Object.prototype.__defineGetter__) {
            return obj.__defineGetter__(prop, get);
        }
        //Throw Error
    };


    var _defineProperty = function $KU_defineProperty(obj, prop, value, arg3) {
        var descriptor = {configurable:false, enumerable:false, value:value, writable:false};

        //NOTE:: When a function scope is changed using bind API.
        //Then that new function does not contain "prototype" property
        if(typeof value === 'function') {
            value.toLocaleString = value.__proto__.toLocaleString;
            value.toSource = value.__proto__.toSource;
            value.toString = value.__proto__.toString;
        }

        //Pass null as 4th argument, if none of the if condition to be met
        if(arguments.length === 3) {
            descriptor.configurable = true;
            descriptor.writable = true;
        } else if(arguments.length === 4) {
            if(typeof arg3 === 'boolean') {
                descriptor.writable = arg3;
            } else if(arg3 && typeof arg3 === 'object') {
                descriptor = arg3;
                descriptor.value = value;
            }
        }

        Object.defineProperty(obj, prop, descriptor);
    };


    //NOTE:: defineSetter must be called after defineGetter
    var _defineSetter = function $KU_defineSetter(obj, prop, set, configurable) {
        if(typeof configurable !== 'boolean') configurable = true;

        if(Object.defineProperty) {
            return Object.defineProperty(obj, prop, _accessorDescriptor(configurable, 'set', set));
        } else if(Object.prototype.__defineSetter__) {
            return obj.__defineSetter__(prop, set);
        }
        //Throw Error
    };


    var _getLocalStorage = function $KU_getLocalStorage() {
        var $K = kony.$kwebfw$, $KA = $K.app, store = null,
            data = localStorage.getItem($KA.id);

        if(typeof data === 'string' && data) {
            try{
                store = JSON.parse(data);
            } catch(e) {
                store = data;
            }
        }

        return store;
    };


    var _is = function $KU_is(obj, type, arg2) {
        var flag = false, datatype = '';

        if(__is[type]) {
            datatype = _datatype(obj);

            flag = (arg2 !== undefined && datatype !== undefined)
                ? __is[type](datatype, obj, arg2)
                : __is[type](datatype, obj);
        }

        return flag;
    };


    var _loadedFromOtherFramework = function $KU_loadedFromOtherFramework() {
        var flag = false, $KG = $K.globals;

        if($KG.kof.loadedFromOtherFramework) {
            flag = true;
        }

        return flag;
    };


    //meta = {api:'', enter|exit:true|false}
    //meta = {api:'', params:[]}
    var _log = function $KU_log(meta, arg1) {
    };


    var _uid = function $KU_uid() {
        var time = null;

        if(__uid === null) {
            time = new Date().getTime().toString();
            __uid = parseInt(time, 10);
        } else {
            __uid++;
        }
        return __uid.toString();
    };


    var _uuid = function $KU_uuid() {
        var uuid = '';

        if(window.crypto) {
            uuid = ([1e7]+-1e3+-4e3+-8e3+-1e11).replace(/[018]/g, function(c) {
                //eslint-disable-next-line no-undef
                return (c ^ crypto.getRandomValues(new Uint8Array(1))[0] & 15 >> c / 4).toString(16);
            });
        } else {
            uuid = new Date().getTime();

            if(window.performance && typeof performance.now === 'function') {
                uuid += performance.now();
            }

            uuid = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
                var r = (uuid + Math.random() * 16) % 16 | 0;

                uuid = Math.floor(uuid / 16);

                return (c === 'x' ? r : (r & 0x3 | 0x8)).toString(16);
            });
        }

        return uuid.toUpperCase();
    };

    $K.defKonyProp(_ns, [
        {keey:'browser', value:_browser},
        {keey:'datatype', value:_datatype},
        {keey:'defineGetter', value:_defineGetter},
        {keey:'defineProperty', value:_defineProperty},
        {keey:'defineSetter', value:_defineSetter},
        {keey:'getLocalStorage', value:_getLocalStorage},
        {keey:'is', value:_is},
        {keey:'log', value:_log},
        {keey:'uid', value:_uid},
        {keey:'uuid', value:_uuid}
    ]);

    return _ns;
}())});

/* FilePath: lib/apis/konycrypto.js */
/* Version: 202305.0.0 */
/* TimeStamp: Fri Apr 14 2023 18:32:27 */
/* global CryptoJS */
Object.defineProperty(kony, 'crypto', {configurable:false, enumerable:false, writable:false, value:(function() {
    var _ns = {}, $K = kony.$kwebfw$;


    var _createHash = function(algo, str, options) {
        var $K = kony.$kwebfw$, $KU = $K.utils, msg = '';

        $KU.log({api:'kony.crypto.createHash', enter:true});

        if(!$KU.is(str, 'string')) {
            return {
                errcode: 100,
                errmessage: 'invalid input parameters'
            };
        }

        try{
            switch(algo.toLowerCase()) {
                case 'md5':
                    msg = CryptoJS.MD5(str);
                    break;
                case 'sha256':
                    msg = CryptoJS.SHA256(str);
                    break;
                case 'sha1':
                    msg = CryptoJS.SHA1(str);
                    break;
                case 'sha512':
                    msg = CryptoJS.SHA512(str);
                    break;
                default:
                    msg = {
                        errcode: 101,
                        errmessage: 'unsupported algorithm'
                    };
                    break;
            }

            if(!$KU.is(msg, 'string')) {
                if($KU.is(options, 'object')) {
                    if(options.returnBase64String === 'true') {
                        msg = msg.toString(CryptoJS.enc.Base64);
                    } else {
                        msg = msg.toString(CryptoJS.enc.UTF8);
                    }
                } else {
                    msg = msg.toString(CryptoJS.enc.UTF8);
                }
            }

            $KU.log({api:'kony.crypto.createHash', exit:true});

            return msg;
        } catch(ex) {
            return {
                errcode: 102,
                errmessage: 'unknown  error'
            };
        }
    };

    var _createHashToUpperCase = function(algo, str) {
        var $K = kony.$kwebfw$, $KU = $K.utils,
            hashValueToUpperCase = _createHash(algo, str);

        if($KU.is(hashValueToUpperCase, 'string')) {
            hashValueToUpperCase = hashValueToUpperCase.toUpperCase();
        }

        return hashValueToUpperCase;
    };

    var _createPBKDF2Key = function(algo, password, salt, iteration, klen) {
        var $K = kony.$kwebfw$, $KU = $K.utils, key, hashFun;

        $KU.log({api:'kony.crypto._createPBKDF2Key', enter:true});

        if(!$KU.is(password, 'string')) {
            return {
                errcode: 100,
                errmessage: 'invalid input parameters'
            };
        }

        try{
            switch(algo.toLowerCase()) {
                case 'md5':
                    hashFun = CryptoJS.algo.MD5;
                    break;
                case 'sha256':
                    hashFun = CryptoJS.algo.SHA256;
                    break;
                case 'sha1':
                    hashFun = CryptoJS.algo.SHA1;
                    break;
                case 'sha512':
                    hashFun = CryptoJS.algo.SHA512;
                    break;
                default:
                    break;
            }

            if(hashFun) {
                klen = klen ? klen/32 : 256/32;
                key = CryptoJS.PBKDF2(password, salt, {keySize: klen, iterations: iteration, hasher: hashFun});
                return key.toString();
            }

            $KU.log({api:'kony.crypto.createPBKDF2Key', exit:true});

            return {
                errcode: 101,
                errmessage: 'unsupported  algo'
            };
        } catch(err) {
            return {
                errcode: 102,
                errmessage: 'unknown  error'
            };
        }
    };

    var _decrypt = function(algo, generatedkey, encryptedRawbytes, propertiesTable) {
        var $K = kony.$kwebfw$, $KU = $K.utils,
            mode = CryptoJS.mode.CBC, msg = '',
            padding = CryptoJS.pad.Pkcs7;

        $KU.log({api:'kony.crypto.decrypt', enter:true});

        if(!$KU.is(algo, 'string') && encryptedRawbytes && generatedkey) {
            $KU.log({api:'kony.crypto.decrypt', exit:true});

            return {
                errcode: 100,
                errmessage: 'invalid input parameters'
            };
        }

        try{
            if(propertiesTable) {
                if(propertiesTable.mode) {
                    switch(propertiesTable.mode.toLowerCase()) {
                        case 'cfb':
                            mode = CryptoJS.mode.CFB;
                            break;
                        case 'ctr':
                            mode = CryptoJS.mode.CTR;
                            break;
                        case 'ofb':
                            mode = CryptoJS.mode.OFB;
                            break;
                        case 'ecb':
                            mode = CryptoJS.mode.ECB;
                            break;
                        default:
                            break;
                    }
                }

                if(propertiesTable.padding) {
                    switch(propertiesTable.padding.toLowerCase()) {
                        case 'iso97971':
                            padding = CryptoJS.pad.Iso97971;
                            break;
                        case 'iso10126':
                            padding = CryptoJS.pad.Iso10126;
                            break;
                        case 'zeropadding':
                            padding = CryptoJS.pad.ZeroPadding;
                            break;
                        case 'nopadding':
                            padding = CryptoJS.pad.NoPadding;
                            break;
                        default:
                            break;
                    }
                }
            }

            encryptedRawbytes = _parse(encryptedRawbytes);

            if(algo.toLowerCase() === 'aes') {
                msg = CryptoJS.AES.decrypt(encryptedRawbytes, generatedkey, {
                    mode: mode,
                    padding: padding
                });

                $KU.log({api:'kony.crypto.decrypt', exit:true});

                return msg.toString(CryptoJS.enc.Utf8);
            } else if(algo.toLowerCase() === 'tripledes') {
                msg = CryptoJS.TripleDES.decrypt(
                    encryptedRawbytes,
                    generatedkey, {
                        mode: mode,
                        padding: padding
                    }
                );

                $KU.log({api:'kony.crypto.decrypt', exit:true});

                return msg.toString(CryptoJS.enc.Utf8);
            }
            $KU.log({api:'kony.crypto.decrypt', exit:true});

            return {
                errcode: 101,
                errmessage: 'unsupported algorithm'
            };
        } catch(err) {
            return {
                errcode: 102,
                errmessage: 'unknown  error'
            };
        }
    };


    var _deleteKey = function(uid) {
        var $K = kony.$kwebfw$, $KU = $K.utils, store = $K.store;

        $KU.log({api:'kony.crypto.deleteKey', enter:true});
        store.remove('local', uid);
        $KU.log({api:'kony.crypto.deleteKey', exit:true});
    };


    var _encrypt = function(algo, generatedkey, str, propertiesTable) {
        var $K = kony.$kwebfw$, $KU = $K.utils, mode = CryptoJS.mode.CBC,
            encryptedObj = null, padding = CryptoJS.pad.Pkcs7;

        $KU.log({api:'kony.crypto.createHash', enter:true});

        if(!$KU.is(algo, 'string') && str && generatedkey) {
            $KU.log({api:'kony.crypto.encrypt', exit:true});

            return {
                errcode: 100,
                errmessage: 'invalid input parameters'
            };
        }

        try{
            if(propertiesTable) {
                if(propertiesTable.mode) {
                    switch(propertiesTable.mode.toLowerCase()) {
                        case 'cfb':
                            mode = CryptoJS.mode.CFB;
                            break;
                        case 'ctr':
                            mode = CryptoJS.mode.CTR;
                            break;
                        case 'ofb':
                            mode = CryptoJS.mode.OFB;
                            break;
                        case 'ecb':
                            mode = CryptoJS.mode.ECB;
                            break;
                        default:
                            break;
                    }
                }

                if(propertiesTable.padding) {
                    switch(propertiesTable.padding.toLowerCase()) {
                        case 'iso97971':
                            padding = CryptoJS.pad.Iso97971;
                            break;
                        case 'iso10126':
                            padding = CryptoJS.pad.Iso10126;
                            break;
                        case 'zeropadding':
                            padding = CryptoJS.pad.ZeroPadding;
                            break;
                        case 'nopadding':
                            padding = CryptoJS.pad.NoPadding;
                            break;
                        default:
                            break;
                    }
                }
            }

            if(algo.toLowerCase() === 'aes') {
                encryptedObj = CryptoJS.AES.encrypt(str, generatedkey, {
                    mode: mode,
                    padding: padding
                });

                $KU.log({api:'kony.crypto.encrypt', exit:true});

                return _stringify(encryptedObj);
            } else if(algo.toLowerCase() === 'tripledes') {
                encryptedObj = CryptoJS.TripleDES.encrypt(str, generatedkey, {
                    mode: mode,
                    padding: padding,
                    format: _jsonFormatter
                });

                $KU.log({api:'kony.crypto.encrypt', exit:true});

                return _stringify(encryptedObj);
            }
            $KU.log({api:'kony.crypto.encrypt', exit:true});

            return {
                errcode: 101,
                errmessage: 'unsupported algorithm'
            };
        } catch(ex) {
            return {
                errcode: 102,
                errmessage: 'unknown  error'
            };
        }
    };


    var _generateRandomNumber = function(min, max) {
        min = Math.ceil(min);
        max = Math.floor(max);

        return Math.floor(Math.random() * (max - min + 1)) + min;
    };


    var _generateRandomString = function() {
        var possibleString = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789',
            randomLength = _generateRandomNumber(8, 16), i = 0,
            possibleLength = possibleString.length, randomString = '';

        for(i=0; i< randomLength; i++) {
            randomString += possibleString.charAt(Math.floor(Math.random() * possibleLength));
        }

        return randomString.toUpperCase();
    };


    var _generateSecureRandom = function(config) {
        var $K = kony.$kwebfw$, $KU = $K.utils, salt = null;

        if(!$KU.is(config, 'object')) {
            config = {type:'base64', size:36};
        } else {
            if(['base64'].indexOf(config.type) === -1) {
                config.type = 'base64';
            }

            if(!$KU.is(config.size, 'integer') || config.size < 0) {
                config.size = 36;
            }
        }

        salt = CryptoJS.lib.WordArray.random(config.size);

        return (config.type === 'base64')
            ? salt.toString(CryptoJS.enc.Base64)
            : salt.toString(CryptoJS.enc.Hex);
    };


    var _jsonFormatter = function() {
        //Not available in SPA repo too. Ask Shankar about it.
    };


    var _newKey = function(algo, keystrength, algoObject) {
        var $K = kony.$kwebfw$, $KU = $K.utils;

        $KU.log({api:'kony.crypto.newKey', enter:true});

        try{
            if(algo !== 'passphrase') {
                $KU.log({api:'kony.crypto.newKey', exit:true});

                return {
                    errcode: 100,
                    errmessage: 'invalid input parameters'
                };
            } else if(!algoObject.subalgo) {
                $KU.log({api:'kony.crypto.newKey', exit:true});

                return {
                    errcode: 105,
                    errmessage: 'subalgo parameter is missing'
                };
            }
            if(algoObject.subalgo.toLowerCase() === 'aes'
            || algoObject.subalgo.toLowerCase() === 'tripledes') {
                $KU.log({api:'kony.crypto.newKey', exit:true});

                return algoObject.passphrasetext[0];
            }
            $KU.log({api:'kony.crypto.newKey', exit:true});

            return {
                errcode: 101,
                errmessage: 'unsupported algorithm'
            };
        } catch(ex) {
            return {
                errcode: 102,
                errmessage: 'unknown error'
            };
        }
    };


    var _parse = function(str) {
        var json = JSON.parse(str), cipher = null;

        //Extract ciphertext from json object, and create cipher params object
        cipher = CryptoJS.lib.CipherParams.create({
            ciphertext: CryptoJS.enc.Base64.parse(json.ct)
        });

        // optionally extract iv and salt
        if(json.iv) {
            cipher.iv = CryptoJS.enc.Hex.parse(json.iv);
        }

        if(json.s) {
            cipher.salt = CryptoJS.enc.Hex.parse(json.s);
        }

        return cipher;
    };


    var _readKey = function(uid) {
        var $K = kony.$kwebfw$, $KU = $K.utils,
            store = $K.store, dataobj = null;

        $KU.log({api:'kony.crypto.readKey', enter:true});

        if($KU.is(uid, 'undefined')) {
            $KU.log({api:'kony.crypto.readKey', enter:true});

            return {
                errcode: 100,
                errmsg: 'Invalid input parameters'
            };
        }

        try{
            if(localStorage) {
                dataobj = JSON.parse(store.fetch('local', uid) || 'null');

                if(dataobj === null) {
                    $KU.log({api:'kony.crypto.readKey', exit:true});

                    return {
                        errcode: 101,
                        errmsg: 'unable to find the key with the specified unique ID'
                    };
                }
                $KU.log({api:'kony.crypto.readKey', exit:true});

                return dataobj;
            }
            $KU.log({api:'kony.crypto.readKey', exit:true});

            return {
                errcode: 102,
                errmsg: 'unknown error, storage not supported'
            };
        } catch(err) {
            //
        }
    };


    var _saveKey = function(name, key) {
        var $K = kony.$kwebfw$, $KU = $K.utils, store = $K.store;

        $KU.log({api:'kony.crypto.saveKey', enter:true});

        if($KU.is(name, 'undefined') || $KU.is(key, 'undefined')) {
            $KU.log({api:'kony.crypto.saveKey', exit:true});

            return {
                errcode: 100,
                errmsg: 'Invalid input parameters'
            };
        }

        store.put('local', name, JSON.stringify(key));
        $KU.log({api:'kony.crypto.saveKey', exit:true});
        return name;
    };


    var _stringify = function(obj) {
        // create json object with ciphertext
        var jsonObj = {
            ct: obj.ciphertext.toString(CryptoJS.enc.Base64)
        };

        // optionally add iv and salt
        if(obj.iv) {
            jsonObj.iv = obj.iv.toString();
        }

        if(obj.salt) {
            jsonObj.s = obj.salt.toString();
        }

        // stringify json object
        return JSON.stringify(jsonObj);
    };


    $K.defKonyProp(_ns, [
        {keey:'createHash', value:_createHash},
        {keey:'createHashToUpperCase', value:_createHashToUpperCase},
        {keey:'createPBKDF2Key', value:_createPBKDF2Key},
        {keey:'decrypt', value:_decrypt},
        {keey:'deleteKey', value:_deleteKey},
        {keey:'encrypt', value:_encrypt},
        {keey:'generateRandomNumber', value:_generateRandomNumber},
        {keey:'generateRandomString', value:_generateRandomString},
        {keey:'generateSecureRandom', value:_generateSecureRandom},
        {keey:'newKey', value:_newKey},
        {keey:'readKey', value:_readKey},
        {keey:'saveKey', value:_saveKey}
    ]);


    return _ns;
}())});

/* FilePath: lib/apis/konyds.js */
/* Version: 202305.0.0 */
/* TimeStamp: Fri Apr 14 2023 18:32:28 */

(function() {
    var _clean = function(namespace, arg1) {
        var $K = kony.$kwebfw$, $KA = $K.app,
            $KU = $K.utils, store = $KU.getLocalStorage();

        if($KU.is(store, 'object') && store.migrated === true) {
            if(arg1 === true) {
                store[namespace] = [];
            } else if(store.ns[namespace]
            && store.ns[namespace].length) {
                store.ns[namespace] = [];
            }

            $K.store.put('local', $KA.id, JSON.stringify(store));
        } else {
            $K.store.clear('local'); //For backward compatibility
            $K.store.put('local', $KA.id, JSON.stringify($KU.createBlankLocalStorage()));
        }
    };


    var _delete = function(key, namespace, arg2) {
        var $K = kony.$kwebfw$, $KU = $K.utils, $KA = $K.app, data = null,
            store = $KU.getLocalStorage(), i = 0, index = -1, len = 0;

        if(arg2 === true) {
            data = store[namespace];
        } else {
            data = store.ns[namespace];
        }

        if($KU.is(data, 'array')) {
            len = data.length;

            for(i = 0; i < len; i++) {
                if(data[i].key === key) {
                    index = i;
                    break;
                }
            }
        }

        if(index >= 0) {
            data.splice(index, 1);
            $K.store.put('local', $KA.id, JSON.stringify(store));
        }
    };


    var _fetch = function(key, namespace, arg2) {
        var $K = kony.$kwebfw$, $KU = $K.utils,
            store = $KU.getLocalStorage(), i = 0,
            len = 0, item = null, data = null;

        if(arg2 === true) {
            data = store[namespace];
        } else {
            data = store.ns[namespace];
        }

        if($KU.is(data, 'array')) {
            len = data.length;

            for(i = 0; i < len; i++) {
                if(data[i].key === key) {
                    item = data[i].value;
                    break;
                }
            }
        }

        return item;
    };


    var _getLength = function(namespace, arg1) {
        var $K = kony.$kwebfw$, $KU = $K.utils,
            store = $KU.getLocalStorage(), data = null;

        if(arg1 === true) {
            data = store[namespace];
        } else {
            data = store.ns[namespace];
        }

        return ($KU.is(data, 'array')) ? data.length : 0;
    };


    var _keyAt = function(index, namespace, arg2) {
        var $K = kony.$kwebfw$, $KU = $K.utils,
            store = $KU.getLocalStorage(), data = null;

        if(arg2 === true) {
            data = store[namespace];
        } else {
            data = store.ns[namespace];
        }

        if($KU.is(data, 'array')) data = data[index];

        return (data) ? data.key : null;
    };


    var _put = function(key, value, namespace, arg3) {
        var $K = kony.$kwebfw$, $KU = $K.utils, $KA = $K.app, data = null,
            store = $KU.getLocalStorage(), i = 0, index = -1, len = 0;

        if(arg3 === true) {
            data = store[namespace];
        } else {
            if(!$KU.is(store.ns[namespace], 'array')) {
                store.ns[namespace] = [];
            }

            data = store.ns[namespace];
        }

        if($KU.is(data, 'array')) {
            len = data.length;

            for(i = 0; i < len; i++) {
                if(data[i].key === key) {
                    index = i;
                    break;
                }
            }

            if(index === -1) { //New key
                data.push({
                    key: key,
                    value: value
                });
            } else { //Existing key
                data[index].value = value;
            }

            $K.store.put('local', $KA.id, JSON.stringify(store));
        }
    };


    Object.defineProperty(kony, 'ds', {configurable:false, enumerable:false, writable:false, value:(function() {
        var _ns = {}, $K = kony.$kwebfw$;


        var _read = function(name, storeContext) {
            var $K = kony.$kwebfw$, $KU = $K.utils;

            $KU.log({api:'kony.ds.read', enter:true});

            if(typeof storeContext === 'string' && storeContext) {
                $KU.log({api:'kony.ds.read', exit:true});
                return _fetch(name, storeContext);
            }
            $KU.log({api:'kony.ds.read', exit:true});
            return _fetch(name, 'ds', true);
        };


        var _remove = function(name, storeContext) {
            var $K = kony.$kwebfw$, $KU = $K.utils;

            $KU.log({api:'kony.ds.remove', enter:true});

            if(typeof storeContext === 'string' && storeContext) {
                _delete(name, storeContext);
            } else {
                _delete(name, 'ds', true);
            }

            $KU.log({api:'kony.ds.remove', exit:true});

            return true;
        };


        var _save = function(inputtable, name, metainfo /*, storeContext*/) {
            var $K = kony.$kwebfw$, $KU = $K.utils;

            $KU.log({api:'kony.ds.save', enter:true});

            if(typeof metainfo === 'string' && metainfo) {
                _put(name, inputtable, metainfo);
            } else if(arguments.length === 2
            || (typeof metainfo === 'object' && metainfo)) {
                _put(name, inputtable, 'ds', true);
            }

            $KU.log({api:'kony.ds.save', exit:true});
        };


        $K.defKonyProp(_ns, [
            {keey:'read', value:_read},
            {keey:'remove', value:_remove},
            {keey:'save', value:_save}
        ]);


        return _ns;
    }())});


    Object.defineProperty(kony, 'store', {configurable:false, enumerable:false, writable:false, value:(function() {
        var _ns = {}, $K = kony.$kwebfw$;


        var _clear = function(arg0) {
            var $K = kony.$kwebfw$, $KU = $K.utils;

            $KU.log({api:'kony.store.clear', enter:true});

            //eslint-disable-next-line no-undef
            if(typeof storeContext === 'string' && storeContext) {
                _clean(arg0);
            } else {
                _clean('store', true);
            }

            $KU.log({api:'kony.store.clear', exit:true});
        };


        var _getItem = function(key, arg1) {
            var $K = kony.$kwebfw$, $KU = $K.utils;

            $KU.log({api:'kony.store.getItem', enter:true});

            if(typeof arg1 === 'string' && arg1) {
                $KU.log({api:'kony.store.getItem', exit:true});
                return _fetch(key, arg1);
            }
            $KU.log({api:'kony.store.getItem', exit:true});
            return _fetch(key, 'store', true);
        };


        var _key = function(index, arg1) {
            var $K = kony.$kwebfw$, $KU = $K.utils;

            $KU.log({api:'kony.store.key', enter:true});

            if(typeof arg1 === 'string' && arg1) {
                $KU.log({api:'kony.store.key', exit:true});
                return _keyAt(index, arg1);
            }
            $KU.log({api:'kony.store.key', exit:true});
            return _keyAt(index, 'store', true);
        };


        var _length = function(arg0) {
            var $K = kony.$kwebfw$, $KU = $K.utils;

            $KU.log({api:'kony.store.length', enter:true});

            if(typeof arg0 === 'string' && arg0) {
                $KU.log({api:'kony.store.length', exit:true});
                return _getLength(arg0);
            }
            $KU.log({api:'kony.store.length', exit:true});
            return _getLength('store', true);
        };


        var _removeItem = function(keey, arg1) {
            var $K = kony.$kwebfw$, $KU = $K.utils;

            $KU.log({api:'kony.store.removeItem', enter:true});

            if(typeof arg1 === 'string' && arg1) {
                _delete(keey, arg1);
            } else {
                _delete(keey, 'store', true);
            }

            $KU.log({api:'kony.store.removeItem', exit:true});
        };


        var _setItem = function(keey, value, arg2) {
            var $K = kony.$kwebfw$, $KU = $K.utils;

            $KU.log({api:'kony.store.setItem', enter:true});

            if(typeof arg2 === 'string' && arg2) {
                _put(keey, value, arg2);
            } else {
                _put(keey, value, 'store', true);
            }

            $KU.log({api:'kony.store.setItem', exit:true});
        };


        $K.defKonyProp(_ns, [
            {keey:'clear', value:_clear},
            {keey:'getItem', value:_getItem},
            {keey:'key', value:_key},
            {keey:'length', value:_length},
            {keey:'removeItem', value:_removeItem},
            {keey:'setItem', value:_setItem}
        ]);


        return _ns;
    }())});
}());

/* FilePath: lib/apis/konynet.js */
/* Version: 202305.0.0 */
/* TimeStamp: Fri Apr 14 2023 18:32:28 */

Object.defineProperty(kony, 'net', {configurable:false, enumerable:false, writable:false, value:(function() {
    var _ns = {}, $K = kony.$kwebfw$, $KU = $K.utils, _http = {},
        _integrityProperties = null;


    var _cancel = function(connection) {
        var $K = kony.$kwebfw$, $KU = $K.utils;

        $KU.log({api:'kony.net.cancel', enter:true});

        if($KU.is(connection, 'object')
        && $KU.is(connection.abort, 'function')) {
            connection.userCancelled = true;
            connection.abort();
        }

        $KU.log({api:'kony.net.cancel', exit:true});
    };


    var _clearCookies = function(url, cookies) {
        var $K = kony.$kwebfw$, $KU = $K.utils,
            allCookies = document && document.cookie.split(';'),
            pathBits = null, i = 0, ilen = 0, pathCurrent = '/',
            cookieName = '', j = 0, jlen = 0;

        $KU.log({api:'kony.net.clearCookies', enter:true});

        url = url || document.URL;

        if(window && url.indexOf(window.location.origin) !== -1) {
            cookies = cookies || allCookies;

            if(cookies) {
                pathBits = window.location.pathname.split('/');
                ilen = cookies.length;

                for(i=0; i<ilen; i++) {
                    cookieName = cookies[i].trim();

                    if(document.cookie.indexOf(cookieName) !== -1) {
                        jlen = pathBits.length;

                        for(j=0; j<jlen; j++) {
                            pathCurrent += ((pathCurrent.substr(-1) !== '/') ? '/' : '') + pathBits[j];

                            if(cookieName.indexOf('=') !== -1) {
                                document.cookie = cookieName + '; expires=Thu, 01-Jan-1970 00:00:01 GMT;path=' + pathCurrent + ';';
                            } else {
                                document.cookie = cookieName + '=; expires=Thu, 01-Jan-1970 00:00:01 GMT;path=' + pathCurrent + ';';
                            }

                            if(document.cookie.indexOf(cookieName) === -1) break;
                        }
                    }
                }
            }

            $KU.log({api:'kony.net.clearCookies', exit:true});
        } else {
            throw new $KU.error(1005, 'invalid input url', 'invalid input url');
        }
    };


    var _FormData = function(param) {
        var $K = kony.$kwebfw$, $KU = $K.utils, _formdata = {};

        $KU.log({api:'kony.net.FormData', enter:true});

        if($KU.is(param, 'object')
        && param.isMultiPart && window.FormData) {
            return new FormData();
        }
        this.append = function(key, value) {
            var $K = kony.$kwebfw$, $KU = $K.utils, $KB = $K.behavior;

            if($KU.is(key, 'string') && key) {
                if(!$KB.doNotEncodeFormValue) {
                    value = encodeURIComponent(value);
                }

                if(!_formdata[key]) {
                    _formdata[key] = [value];
                } else {
                    _formdata[key].push(value);
                }
            } else {
                throw new Error('FormData append Error: key cannot be empty');
            }
        };

        this.toString = function() {
            var formdata = '', key = '';

            for(key in _formdata) {
                if(formdata === '') {
                    formdata = key + '=' + _formdata[key].join('&' + key + '=');
                } else {
                    formdata += '&' + key + '=' + _formdata[key].join('&' + key + '=');
                }
            }

            return formdata;
        };

        this.delete = function(key) {
            delete _formdata[key];
        };

        this.entries = function() {
            return _iterator(_formdata, 'entries');
        };

        this.get = function(key) {
            return _formdata[key][0];
        };

        this.getAll = function(key) {
            return _formdata[key];
        };

        this.has = function(key) {
            //eslint-disable-next-line no-prototype-builtins
            return _formdata.hasOwnProperty(key);
        };

        this.keys = function() {
            return _iterator(_formdata, 'keys');
        };

        this.set = function(key, value) {
            _formdata[key] = [value];
        };

        this.values = function() {
            return _iterator(_formdata, 'values');
        };


        $KU.log({api:'kony.net.FormData', exit:true});
    };


    var _getActiveNetworkType = function() {
        var $K = kony.$kwebfw$, $KU = $K.utils;

        $KU.log({api:'kony.net.getActiveNetworkType', enter:true});

        if($KU.is(navigator.onLine, 'undefined')) {
            $KU.log({api:'kony.net.getActiveNetworkType', exit:true});
            return constants.NETWORK_TYPE_ANY;
        }
        if(navigator.onLine) {
            $KU.log({api:'kony.net.getActiveNetworkType', exit:true});
            return constants.NETWORK_TYPE_ANY;
        }
        $KU.log({api:'kony.net.getActiveNetworkType', exit:true});
        return null;
    };


    var _getCookies = function(url) {
        var $K = kony.$kwebfw$, $KU = $K.utils, allCookies = null;

        $KU.log({api:'kony.net.getCookies', enter:true});

        if($KU.is(url, 'string') && url) {
            if(url.indexOf(window.location.origin) !== -1) {
                allCookies = document && document.cookie;

                if(allCookies && allCookies.length > 0) {
                    allCookies = allCookies.split(';');
                }
            }
        }

        $KU.log({api:'kony.net.getCookies', exit:true});

        return allCookies;
    };

    var _getResponseHeader = function(headerfield) {
        var xhr = this.xhr;

        if(xhr.getResponseHeader(headerfield)) {
            return xhr.getResponseHeader(headerfield);
        }
        return null;
    };

    var _getAllResponseHeaders = function() {
        var $K = kony.$kwebfw$, $KU = $K.utils, $KB = $K.behavior,
            xhr = this.xhr, headers = null, arr, parts, header,
            value, line, count = 0, len = 0, map = {};

        if(xhr.getAllResponseHeaders()) {
            headers = xhr.getAllResponseHeaders();
        }

        if(!$KB.isResponseHeaderString && $KU.is(headers, 'string')) {
            // Convert the header string into an array
            // of individual headers
            arr = headers.trim().split(/[\r\n]+/);
            len = arr.length;

            for(count=0; count<len; count++) {
                line = arr[count];
                parts = line.split(': ');
                header = parts.shift();
                value = parts.join(': ');
                map[header] = value;
            }

            headers = map;
        }
        return headers;
    };


    var _HttpRequest = function() {
        var $K = kony.$kwebfw$, $KU = $K.utils, id = $KU.uid();

        $KU.log({api:'kony.net.HttpRequest', enter:true});

        _http[id] = {
            disableIntegrityCheck: false,
            enableWithCredentials: false,
            integrityCheckRequired: false,
            integrityStatus: constants.HTTP_INTEGRITY_CHECK_NOT_DONE,
            isMultiPartOrBinary: false,
            onReadyStateChange: function() {},
            randomString: null,
            response: '',
            responseType: '',
            status: null,
            statusText: null,
            timeout: 0,
            url: null,
            xhr: new XMLHttpRequest()

        };

        _http[id].xhr.onreadystatechange = function() {
            var $K = kony.$kwebfw$, $KW = $K.widget, $KA = $K.app,
                http = _http[id], xhr = http.xhr, cf = null;

            http.status = xhr.status;
            http.readyState = xhr.readyState;

            switch(xhr.readyState) {
                case 0: // UNINITIALIZED
                case 1: // LOADING
                case 2: // LOADED
                case 3: // INTERACTIVE
                    http.readyState = xhr.readyState;
                    http.statusText = (xhr.readyState === 0)
                        ? 'Request Uninitialised'
                        : (xhr.readyState === 1)
                            ? 'Request Loading'
                            : (xhr.readyState === 2)
                                ? 'Request Loaded'
                                : (xhr.readyState === 3)
                                    ? 'Request Interactive' : '';
                    http.onReadyStateChange({
                        enableWithCredentials: http.enableWithCredentials,
                        integrityStatus: http.integrityStatus,
                        readyState: http.readyState,
                        response: http.response,
                        responseType: http.responseType,
                        status: http.status,
                        statusText: http.statusText,
                        timeout: http.timeout
                    });
                    break;

                case 4: // COMPLETED
                    http.readyState = xhr.readyState;
                    http.statusText = 'Request Completed';

                    if(xhr.responseType === '' || xhr.responseType === 'text') {
                        http.response = xhr.responseText;
                    } else {
                        http.response = xhr.response;
                    }

                    if(http.integrityCheckRequired) {
                        _integrity.generateResponseCheckSumAndCheckIntegrity.call(http, http.response);
                    }

                    if(xhr.status === 200) {
                        http.statusText += ': OK';

                        if(http.timeout) {
                            clearTimeout(http.timeout);
                        }
                    }

                    if(xhr.status === 400) {
                        http.statusText += ': Error';

                        if(http.timeout) {
                            clearTimeout(http.timeout);
                        }
                    }

                    http.onReadyStateChange({
                        enableWithCredentials: http.enableWithCredentials,
                        integrityStatus: http.integrityStatus,
                        readyState: http.readyState,
                        response: http.response,
                        responseType: http.responseType,
                        status: http.status,
                        statusText: http.statusText,
                        timeout: http.timeout
                    }); //MADPSPA-425: SDK expecting result obj in callback handler


                    xhr = http = null; //For GC
                    delete _http[id];
                    break;

                default:
                    xhr = http = null; //For GC
                    delete _http[id];
                    //$KU.logErrorMessage('Unknown Error: XMLHttpRequest Error');
            }
        };

        $KU.defineProperty(this, 'id', id);

        $KU.defineGetter(this, 'disableIntegrityCheck', function() {
            return _http[this.id].disableIntegrityCheck;
        });
        $KU.defineSetter(this, 'disableIntegrityCheck', function(value) {
            if(typeof value === 'boolean') {
                _http[this.id].disableIntegrityCheck = value;
            }
        });

        $KU.defineGetter(this, 'enableWithCredentials', function() {
            return _http[this.id].enableWithCredentials;
        });
        $KU.defineSetter(this, 'enableWithCredentials', function(value) {
            if(typeof value === 'boolean') {
                _http[this.id].enableWithCredentials = value;
            }
        });

        $KU.defineGetter(this, 'integrityStatus', function() {
            return _http[this.id].integrityStatus;
        });
        //eslint-disable-next-line no-unused-vars
        $KU.defineSetter(this, 'integrityStatus', function(value) {
            //Readonly:: Throw error
        });

        $KU.defineGetter(this, 'onReadyStateChange', function() {
            return _http[this.id].onReadyStateChange;
        });
        $KU.defineSetter(this, 'onReadyStateChange', function(value) {
            if(typeof value === 'function') {
                _http[this.id].onReadyStateChange = value;
            }
        });

        $KU.defineGetter(this, 'readyState', function() {
            return _http[this.id].readyState;
        });
        //eslint-disable-next-line no-unused-vars
        $KU.defineSetter(this, 'readyState', function(value) {
            //Readonly:: Throw error
        });

        $KU.defineGetter(this, 'response', function() {
            return _http[this.id].response;
        });
        //eslint-disable-next-line no-unused-vars
        $KU.defineSetter(this, 'response', function(value) {
            //Readonly:: Throw error
        });

        $KU.defineGetter(this, 'responseType', function() {
            return _http[this.id].responseType;
        });
        $KU.defineSetter(this, 'responseType', function(value) {
            _http[this.id].responseType = value;
        });

        $KU.defineGetter(this, 'status', function() {
            return _http[this.id].status;
        });
        //eslint-disable-next-line no-unused-vars
        $KU.defineSetter(this, 'status', function(value) {
            //Readonly:: Throw error
        });

        $KU.defineGetter(this, 'statusText', function() {
            return _http[this.id].statusText;
        });
        //eslint-disable-next-line no-unused-vars
        $KU.defineSetter(this, 'statusText', function(value) {
            //Readonly:: Throw error
        });

        $KU.defineGetter(this, 'timeout', function() {
            return _http[this.id].timeout;
        });
        $KU.defineSetter(this, 'timeout', function(value) {
            if(typeof value === 'number' && !isNaN(value)) {
                _http[this.id].timeout = value;
            }
        });

        $KU.log({api:'kony.net.HttpRequest', exit:true});
    };

    $KU.defineProperty(_HttpRequest.prototype, 'abort', function() {
        var $K = kony.$kwebfw$, $KU = $K.utils,
            http = _http[this.id], xhr = http.xhr;

        $KU.log({api:'kony.net.HttpRequest.abort', enter:true});

        if(http.timeout) {
            clearTimeout(http.timeout);
        }

        xhr.abort();
        delete _http[this.id];

        $KU.log({api:'kony.net.HttpRequest.abort', exit:true});
    });

    $KU.defineProperty(_HttpRequest.prototype, 'getAllResponseHeaders', function() {
        var $K = kony.$kwebfw$, $KU = $K.utils, http = _http[this.id], headers = null;

        $KU.log({api:'kony.net.HttpRequest.getAllResponseHeaders', enter:true});

        headers = _getAllResponseHeaders.call(http);

        $KU.log({api:'kony.net.HttpRequest.getAllResponseHeaders', exit:true});

        return headers;
    });

    $KU.defineProperty(_HttpRequest.prototype, 'getResponseHeader', function(headerfield) {
        var $K = kony.$kwebfw$, $KU = $K.utils, http = _http[this.id], header = null;

        $KU.log({api:'kony.net.HttpRequest.getResponseHeader', enter:true});

        header = _getResponseHeader.call(http, headerfield);

        $KU.log({api:'kony.net.HttpRequest.getResponseHeader', exit:true});

        return header;
    });

    $KU.defineProperty(_HttpRequest.prototype, 'open', function(method, url, async, username, password) {
        var $K = kony.$kwebfw$, $KU = $K.utils,
            http = _http[this.id], xhr = http.xhr;

        $KU.log({api:'kony.net.HttpRequest.open', enter:true});

        if($KU.is(method, 'string')) {
            method = method.toUpperCase();
        }

        if($KU.is(url, 'string') && url) {
            http.url = url;
            http.open = true;
            http.method = method;
            async = ($KU.is(async, 'boolean')) ? async : true;

            xhr.open(method, url, async, username, password);
        }

        $KU.log({api:'kony.net.HttpRequest.open', exit:true});
    });

    $KU.defineProperty(_HttpRequest.prototype, 'send', function(data) {
        var $K = kony.$kwebfw$, $KU = $K.utils,
            http = _http[this.id], xhr = http.xhr, self = null;

        $KU.log({api:'kony.net.HttpRequest.send', enter:true});

        if(data instanceof kony.net.FormData) {
            //Calling toString() if it is Kony.net.FormData
            //otherwise send the data directly to send method.
            data = data.toString();
        } else if(!data) {
            data = '';
        } else if((window.FormData !== undefined) && data instanceof window.FormData) {
            http.isMultiPartOrBinary = true;
        }

        if(this.enableWithCredentials) {
            xhr.withCredentials = true;
        }

        xhr.count++;
        xhr.timeout = !!this.timeout && this.timeout;

        if(xhr.timeout) {
            self = this;

            http.timeout = setTimeout(function() {
                self.abort();
                self.readyState = xhr.readyState;
                self.status = 0;
                self.statusText = 'Request timed out';
                self.response = '';

                self.onReadyStateChange();
            }, this.timeout);
        }

        if(this.responseType) {
            xhr.responseType = this.responseType;
        }


        http.integrityCheckRequired = _integrity.isIntegrityCheckRequired(http.url, http.disableIntegrityCheck);

        if(http.integrityCheckRequired) {
            _integrity.generateRequestCheckSumAndSetRequestHeader.call(http, data);
        }
        xhr.send(data);

        $KU.log({api:'kony.net.HttpRequest.send', exit:true});
    });

    $KU.defineProperty(_HttpRequest.prototype, 'setRequestHeader', function(header, value) {
        var $K = kony.$kwebfw$, $KU = $K.utils,
            http = _http[this.id],
            binaryFormats = ['application/octet-stream', 'multipart/form-data'];

        $KU.log({api:'kony.net.HttpRequest.setRequestHeader', enter:true});

        if(header && header.toLowerCase() === 'content-type'
        && value && binaryFormats.indexOf(value.toLowerCase()) !== -1) {
            http.isMultiPartOrBinary = true;
        }

        _setRequestHeader.call(http, header, value);

        $KU.log({api:'kony.net.HttpRequest.setRequestHeader', exit:true});
    });


    //Dummy implementation
    //eslint-disable-next-line no-unused-vars
    var _invokeService = function(url, inputParamTable, isblocking) {
        var $K = kony.$kwebfw$, $KU = $K.utils;

        $KU.log({api:'kony.net.invokeService', enter:true});
        $KU.log({api:'kony.net.invokeService', exit:true});
    };


    //Dummy implementation
    //eslint-disable-next-line no-unused-vars
    var _invokeServiceAsync = function(url, inputParamTable, callback, info) {
        var $K = kony.$kwebfw$, $KU = $K.utils;

        $KU.log({api:'kony.net.invokeServiceAsync', enter:true});
        $KU.log({api:'kony.net.invokeServiceAsync', exit:true});
    };

    var _integrity = {

        //This function will be called in the scope of http instance
        generateRequestCheckSum: function Integrity$generateRequestCheckSum(data, passThroughOrFileMultipart) {
            var requestCheckSum = null, toHash = null, requestBodyHash = 'EMPTY_BODY';

            if(passThroughOrFileMultipart !== null) {
                requestBodyHash = passThroughOrFileMultipart;
            } else if(data) {
                requestBodyHash = kony.crypto.createHashToUpperCase(_integrityProperties.algo, data);
            }

            toHash = 'Request:' + _integrityProperties.salt + ':' + this.randomString + ':' + requestBodyHash;
            requestCheckSum = kony.crypto.createHashToUpperCase(_integrityProperties.algo, toHash);
            return requestCheckSum;
        },

        //This function will be called in the scope of http instance
        generateResponseCheckSum: function Integrity$generateResponseCheckSum(data, passThroughOrFileMultipart) {
            var responseCheckSum = null, toHash = null, responseBodyHash = 'EMPTY_BODY';

            if(passThroughOrFileMultipart !== null) {
                responseBodyHash = passThroughOrFileMultipart;
            } else if(data) {
                responseBodyHash = kony.crypto.createHashToUpperCase(_integrityProperties.algo, data);
            }
            toHash = ('Response:' + _integrityProperties.salt + ':' + this.randomString + ':' + responseBodyHash);
            responseCheckSum = kony.crypto.createHashToUpperCase(_integrityProperties.algo, toHash);

            return responseCheckSum;
        },

        //This function will be called in the scope of http instance
        generateRequestCheckSumAndSetRequestHeader: function Integrity$generateRequestCheckSumAndSetRequestHeader(data) {
            var createCheckSumOnReq = null, requestChecksum = null, headerValue = null;

            this.randomString = kony.crypto.generateRandomString();

            if(this.isMultiPartOrBinary) {
                createCheckSumOnReq = this.randomString;
            }

            requestChecksum = _integrity.generateRequestCheckSum.call(this, data, createCheckSumOnReq);
            headerValue = (this.randomString + ';' + requestChecksum);

            _setRequestHeader.call(this, _integrityProperties.headerName, headerValue);
        },

        //This function will be called in the scope of http instance
        generateResponseCheckSumAndCheckIntegrity: function Integrity$generateResponseCheckSumAndCheckIntegrity(data) {
            var responseChecksum = null, responseHeaders = null, checkSum =null,
                passthroughHeaderVal = null, createCheckSumOnResp = null,
                responseContentTypes = ['application/text', 'application/json', 'application/xml',
                    'text/xml', 'text/html', 'application/rss+xml', 'text/plain'];

            var getHeaderValue = function(http, headers, headerName) {
                var headerVal = '';
                //eslint-disable-next-line no-prototype-builtins
                if(headerName && (headers.hasOwnProperty(headerName) || headers.hasOwnProperty(headerName.toLowerCase()))) {
                    headerVal = _getResponseHeader.call(http, headerName);
                }
                return headerVal;
            };

            if(_integrityProperties.validateResp) {
                responseHeaders = _getAllResponseHeaders.call(this);
                passthroughHeaderVal = getHeaderValue(this, responseHeaders, _integrityProperties.passthroughHeaderName);
                if(passthroughHeaderVal.trim().toLowerCase() === 'true') {
                    createCheckSumOnResp = this.randomString;
                } else if(responseContentTypes.indexOf(_getResponseHeader.call(this, 'Content-Type').split(';')[0]) === -1) {
                    createCheckSumOnResp = this.randomString;
                }
                responseChecksum = _integrity.generateResponseCheckSum.call(this, data, createCheckSumOnResp);
                checkSum = getHeaderValue(this, responseHeaders, _integrityProperties.headerName);
                _integrity.setIntegrityStatus.call(this, responseChecksum, checkSum);
            }
        },


        isIntegrityCheckRequired: function Integrity$isIntegrityCheckRequired(url, userDisabledIntegrityCheck) {
            var isIntegrityRequired = false, currHost = null, hyperLink = null;

            if(_integrityProperties && !userDisabledIntegrityCheck) {
                if(_integrityProperties.hostNamesList) {
                    if(typeof document !== 'undefined') {
                        hyperLink = document.createElement('a');
                        hyperLink.href = url;
                        currHost = hyperLink.host;
                    } else {
                        currHost = url.replace('http://', '').replace('https://', '').replace('wwww.', '').split('/')[0];
                    }
                    currHost = currHost.toLowerCase();
                    isIntegrityRequired = _integrity.isIntegrityCheckRequiredForThisHost(currHost);
                } else {
                    isIntegrityRequired = true;
                }
            }

            return isIntegrityRequired;
        },

        isIntegrityCheckRequiredForThisHost: function Integrity$isIntegrityCheckRequiredForThisHost(currHost) {
            var i = 0, host = '', hostsLen = 0, isIntegrityRequired = false,
                hostNamesList = _integrityProperties.hostNamesList;

            hostsLen = hostNamesList.length;
            if(hostsLen > 0) {
                for(i = 0; i < hostsLen; i++) {
                    host = hostNamesList[i];
                    if(host.startsWith('*.')) {
                        host = host.replace('*.', '').toLowerCase();
                        if(currHost.endsWith(host)) {
                            isIntegrityRequired = true;
                            break;
                        }
                    } else if(host === currHost) {
                        isIntegrityRequired = true;
                        break;
                    }
                }
            } else {
                isIntegrityRequired = true;
            }

            return isIntegrityRequired;
        },

        //This function will be called in the scope of http instance
        setIntegrityStatus: function Integrity$setIntegrityStatus(responseChecksum, checkSum) {
            if(responseChecksum === checkSum) {
                kony.print('Integrity Successful');
                this.integrityStatus = constants.HTTP_INTEGRITY_CHECK_SUCCESSFUL;
            } else {
                this.integrityStatus = constants.HTTP_INTEGRITY_CHECK_FAILED;
            }
        },

        validateHostNamesList: function Integrity$validateHostNamesList(hostNamesList) {
            var $K = kony.$kwebfw$, $KU = $K.utils, i = 0, j = 0, domain = null,
                domainArr = null, domainLen = 0;

            //eslint-disable-next-line no-useless-escape
            var regex = /^[A-Za-z0-9\\\-]+$/;

            if(!$KU.is(hostNamesList, 'undefined') && !$KU.is(hostNamesList, 'null')) {
                if(!$KU.is(hostNamesList, 'array')) {
                    throw new $KU.error('100', 'Error', 'Invalid argument :- hostNamesList');
                }

                for(i = hostNamesList.length - 1; i >= 0; i--) {
                    domain = hostNamesList[i];
                    if(typeof domain === 'undefined' || domain === null || domain.trim() === '') {
                        throw new $KU.error('100', 'Error', 'Invalid argument :- hostNamesList');
                    }
                    if(domain.startsWith('*.')) {
                        domain = domain.replace('*.', '');
                    }
                    domainArr = domain.split('.');
                    domainLen = domainArr.length;
                    if(domainLen <= 1) {
                        throw new $KU.error('100', 'Error', 'Invalid argument :- hostNamesList');
                    }
                    for(j = domainLen - 1; j >= 0; j--) {
                        if(!regex.test(domainArr[j])) {
                            throw new $KU.error('100', 'Error', 'Invalid argument :- hostNamesList');
                        }
                    }
                }
            }
        },

        validateIntegrityParams: function Integrity$validateIntegrityParams(properties) {
            var $K = kony.$kwebfw$, $KU = $K.utils,
                algoList = ['md5', 'sha1', 'sha256', 'sha512'];

            if(Object.keys(properties).length > 0) {
                _integrity.validateIntegrityPropertyType('validateResp', properties.validateResp, 'boolean');
                _integrity.validateIntegrityPropertyType('algo', properties.algo, 'string');
                _integrity.validateIntegrityPropertyType('salt', properties.salt, 'string');
                _integrity.validateIntegrityPropertyType('headerName', properties.headerName, 'string');

                if((algoList.indexOf(properties.algo.toLowerCase())) === -1) {
                    throw new $KU.error('100', 'Error', 'Invalid argumment' + properties.algo);
                }

                if(properties.salt.length > 1024) {
                    properties.salt = properties.salt.substring(0, 1024);
                }

                if(properties.headerName.length > 64) {
                    properties.headerName = properties.headerName.substring(0, 64);
                }

                if(properties.passthroughHeaderName) {
                    _integrity.validateIntegrityPropertyType('passthroughHeaderName', properties.passthroughHeaderName, 'string');
                    if(properties.passthroughHeaderName.length > 64) {
                        properties.passthroughHeaderName = properties.passthroughHeaderName.substring(0, 64);
                    }
                }

                _integrity.validateHostNamesList(properties.hostNamesList);
            } else {
                throw new $KU.error('101', 'Error', 'Invalid number of arguments');
            }

            return true;
        },

        validateIntegrityPropertyType: function Integrity$validateIntegrityPropertyType(propertyName, propertyValue, propertyType) {
            var $K = kony.$kwebfw$, $KU = $K.utils;

            if(typeof propertyValue !== propertyType) {
                throw new $KU.error('100', 'Error', 'Invalid argument' + propertyName);
            }

            return true;
        }

    };


    var _iterator = function(data, arg) {
        var keys = Object.keys(data),
            keyIndex = 0, valueIndex = 0;

        if(arg === 'entries') {
            return {
                next: function() {
                    var key = '', value = null;

                    if(keyIndex < keys.length) {
                        key = keys[keyIndex];
                        value = data[key];

                        if(valueIndex >= value.length) {
                            valueIndex = 0;
                            keyIndex++;
                        }

                        return {
                            done: false,
                            value: [key, value[valueIndex++]]
                        };
                    }
                    return {
                        done: true,
                        value: undefined
                    };
                }
            };
        } else if(arg === 'keys') {
            return {
                next: function() {
                    if(keyIndex < keys.length) {
                        return {
                            done: false,
                            value: keys[keyIndex++]
                        };
                    }
                    return {
                        done: true,
                        value: undefined
                    };
                }
            };
        } else if(arg === 'values') {
            return {
                next: function() {
                    var key = '', value = null;

                    if(keyIndex < keys.length) {
                        key = keys[keyIndex];
                        value = data[key];

                        if(valueIndex >= value.length) {
                            valueIndex = 0;
                            keyIndex++;
                        }
                        return {
                            done: false,
                            value: value[valueIndex++]
                        };
                    }
                    return {
                        done: true,
                        value: undefined
                    };
                }
            };
        }
    };


    var _isNetworkAvailable = function(networkType) {
        var $K = kony.$kwebfw$, $KU = $K.utils;

        $KU.log({api:'kony.net.isNetworkAvailable', enter:true});

        if(networkType) {
            if(networkType === constants.NETWORK_TYPE_ANY) {
                if(!$KU.is(navigator.onLine, 'undefined')) {
                    $KU.log({api:'kony.net.isNetworkAvailable', exit:true});
                    return navigator.onLine;
                }
                $KU.log({api:'kony.net.isNetworkAvailable', exit:true});
                return false;
            } else if(networkType === constants.NETWORK_TYPE_3G
            || networkType === constants.NETWORK_TYPE_WIFI
            || networkType === constants.NETWORK_TYPE_ETHERNET) {
                $KU.log({api:'kony.net.isNetworkAvailable', exit:true});
                return false;
            }
            throw new Error('Invalid Network Type');
        } else {
            throw new Error('Invalid Network Type');
        }
    };


    var _loadClientCertificate = function() {
        var $K = kony.$kwebfw$, $KU = $K.utils;

        $KU.unsupportedAPI('kony.net.loadClientCertificate');
    };


    var _removeAllCachedResponses = function() {
        var $K = kony.$kwebfw$, $KU = $K.utils;

        $KU.unsupportedAPI('kony.net.removeAllCachedResponses');
    };


    var _removeClientCertificate = function() {
        var $K = kony.$kwebfw$, $KU = $K.utils;

        $KU.unsupportedAPI('kony.net.removeClientCertificate');
    };


    var _removeIntegrityCheck = function() {
        var $K = kony.$kwebfw$, $KU = $K.utils;

        $KU.log({api:'kony.net.removeIntegrityCheck', enter:true});

        _integrityProperties = null;

        $KU.log({api:'kony.net.removeIntegrityCheck', exit:true});
    };


    //This function will be called in the scope of http instance
    var _setRequestHeader = function(header, value) {
        var xhr = this.xhr;

        xhr.setRequestHeader(header, value);
    };


    var _setIntegrityCheck = function(properties) {
        var $K = kony.$kwebfw$, $KU = $K.utils;

        $KU.log({api:'kony.net.setIntegrityCheck', enter:true});

        if(_integrity.validateIntegrityParams(properties)) {
            $KU.log('kony.net.setIntegrityCheck', properties);

            _integrityProperties = properties;
        }

        $KU.log({api:'kony.net.setIntegrityCheck', exit:true});
    };


    var _setNetworkCallbacks = function(config) {
        var $K = kony.$kwebfw$, $KU = $K.utils;

        $KU.log({api:'kony.net.setNetworkCallbacks', enter:true});

        if($KU.is(config, 'object') && $KU.is(config.statusChange, 'function')) {
            if($KU.is(window.ononline, 'object')) {
                window.addEventListener('online', function() {
                    config.statusChange(navigator.onLine);
                }, false);
            }
            if($KU.is(window.onoffline, 'object')) {
                window.addEventListener('offline', function() {
                    config.statusChange(navigator.onLine);
                }, false);
            }

            $KU.log({api:'kony.net.setNetworkCallbacks', enter:true});
        } else {
            throw new Error('Invalid Input : config is not of valid type');
        }
    };

    $K.defKonyProp(_ns, [
        {keey:'cancel', value:_cancel},
        {keey:'clearCookies', value:_clearCookies},
        {keey:'FormData', value:_FormData},
        {keey:'getActiveNetworkType', value:_getActiveNetworkType},
        {keey:'getCookies', value:_getCookies},
        {keey:'HttpRequest', value:_HttpRequest},
        {keey:'invokeService', value:_invokeService},
        {keey:'invokeServiceAsync', value:_invokeServiceAsync, writable:true},
        {keey:'isNetworkAvailable', value:_isNetworkAvailable},
        {keey:'loadClientCertificate', value:_loadClientCertificate},
        {keey:'removeAllCachedResponses', value:_removeAllCachedResponses},
        {keey:'removeClientCertificate', value:_removeClientCertificate},
        {keey:'removeIntegrityCheck', value:_removeIntegrityCheck},
        {keey:'setIntegrityCheck', value:_setIntegrityCheck},
        {keey:'setNetworkCallbacks', value:_setNetworkCallbacks}
    ]);


    return _ns;
}())});

/* FilePath: lib/apis/konynosql.js */
/* Version: 202305.0.0 */
/* TimeStamp: Fri Apr 14 2023 18:32:28 */
Object.defineProperty(kony, 'nosql', {configurable:false, enumerable:false, writable:false, value:(function() {
    var _ns = {}, $K = kony.$kwebfw$, _validTypes = null, _validOrders = null, _validOperators = null,
        _AND = '&&', _ASCENDING = 'ASC', _DESCENDING = 'DESC', _EQ = '=',
        _GT = '>', _GTE = '>=', _LT = '<', _LTE = '<=', _NEQ = '!=',
        _OR = '||', _READ = 'read', _READ_WRITE = 'readwrite', _REGEXP = null,
        _NOT_SUPPORTED_MSG = 'Your browser doesn\'t support a stable version of IndexedDB.',
        _ENDS_WITH = '', _CONTAINS = '', _NOT_CONTAINS = '', _NOT_ENDS_WITH = '',
        _NOT_STARTS_WITH = '', _STARTS_WITH = '',
        _iDB = window.indexedDB || window.mozIndexedDB || window.webkitIndexedDB || window.msIndexedDB;


    var _deleteAllByIndex = function(objectStore, index, keyRangeValue) {
        return new Promise(function(resolve, reject) {
            var cursor, i, recordToDelete = [], recordCount = 0, record, successCallback;

            successCallback = function(/*event*/) {
                recordCount++;

                if(recordCount === recordToDelete.length) {
                    resolve();
                }
            };

            cursor = index.openCursor(keyRangeValue);
            cursor.onsuccess = function(event) {
                var $K = kony.$kwebfw$, $KU = $K.utils, cursor = event.target.result, request;

                if(cursor) {
                    if($KU.browser('name') === 'safari') {
                        record = cursor.primaryKey;
                        recordToDelete.push(record);
                    } else {
                        request = cursor.delete();

                        request.onsuccess = function(/*event*/) {
                            //Do nothing
                        };
                        request.onerror = function(event) {
                            reject(event);
                        };
                    }

                    cursor.continue();
                } else {
                    if(recordToDelete.length === 0) { //it gets executed for Safari and also in the case of records not found for applied filter
                        resolve();
                    } else {
                        for(i=0; i<recordToDelete.length; i++) {
                            request = objectStore.delete(recordToDelete[i]);
                            request.onsuccess = successCallback.bind(this, recordCount, recordToDelete);
                            request.onerror = function(event) {
                                reject(event);
                            };
                        }
                    }
                }
            };

            cursor.onerror = function(event) {
                reject(event);
            };
        });
    };


    var _evaluate = function(record, rule) {
        var result = false, col = record[rule.column], val = rule.value;

        switch(rule.operator) {
            case _ENDS_WITH:
                result = (col.indexOf(val) === (col.length - val.length)) ? true : false;
                break;
            case _EQ:
                result = (col === val);
                break;
            case _GT:
                result = (col > val);
                break;
            case _GTE:
                result = (col >= val);
                break;
            case _CONTAINS:
                result = (col.indexOf(val) >= 0) ? true : false;
                break;
            case _LT:
                result = (col < val);
                break;
            case _LTE:
                result = (col <= val);
                break;
            case _NEQ:
                result = (col !== val);
                break;
            case _NOT_CONTAINS:
                result = (col.indexOf(val) >= 0) ? false : true;
                break;
            case _NOT_ENDS_WITH:
                result = (col.indexOf(val) === (col.length - val.length)) ? false : true;
                break;
            case _NOT_STARTS_WITH:
                result = (col.indexOf(val) === 0) ? false : true;
                break;
            case _STARTS_WITH:
                result = (col.indexOf(val) === 0) ? true : false;
                break;
            case _REGEXP:
                val.lastIndex = 0;
                result = val.test(col);
                break;
            default:
                break;
        }

        return result;
    };


    var _expression = function(record, condition) {
        var str = '', c = 0, clen = condition.length;

        for(c=0; c<clen; c++) {
            if(condition[c] instanceof Array) {
                str += _expression(record, condition[c]);
            } else if(typeof condition[c] === 'string') {
                str += (' ' + condition[c] + ' ');
            } else if(typeof condition[c] === 'object' && condition[c]) {
                str += _evaluate(record, condition[c]);
            }
        }

        return ('(' + str + ')');
    }; //eval(_expression(record, condition))


    var _filterRecords = function(records, condition) {
        return records.filter(function(record) {
            return _isConditionMatched(record, condition);
        });
    };


    //This method is the polyfil of ObjectStore getAll API.
    //In Edge browser getAll API is not available on ObjectStore
    var _getAll = function(objectStore) {
        var records = [];

        return new Promise(function(resolve, reject) {
            var cursor = objectStore.openCursor();
            cursor.onsuccess = function(event) {
                var cursor = event.target.result, record;

                if(cursor) {
                    record = cursor.value;
                    records.push(record);
                    cursor.continue();
                } else {
                    resolve(records);
                }
            };

            cursor.onerror = function(event) {
                reject(event);
            };
        });
    };


    var _getAllByIndex = function(index, keyRangeValue) {
        var records = [];

        return new Promise(function(resolve, reject) {
            var cursor = index.openCursor(keyRangeValue);

            cursor.onsuccess = function(event) {
                var cursor = event.target.result, record;

                if(cursor) {
                    record = cursor.value;
                    records.push(record);
                    cursor.continue();
                } else {
                    resolve(records);
                }
            };

            cursor.onerror = function(event) {
                reject(event);
            };
        });
    };


    var _getDataBaseName = function(dbName) {
        var $K = kony.$kwebfw$, $KA = $K.app;

        return ($KA.id + '_' + dbName);
    };


    var _getKeyRangeValue = function(data) {
        var keyRangeValue;

        switch(data.operator) {
            case _EQ:
                keyRangeValue = IDBKeyRange.only(data.value);
                break;
            case _GT:
                keyRangeValue = IDBKeyRange.lowerBound(data.value, true);
                break;
            case _GTE:
                keyRangeValue = IDBKeyRange.lowerBound(data.value);
                break;
            case _LT:
                keyRangeValue = IDBKeyRange.upperBound(data.value, true);
                break;
            case _LTE:
                keyRangeValue = IDBKeyRange.upperBound(data.value);
                break;
            default:
                break;
            //need to find solution for mosule.NEQ
        }

        return keyRangeValue;
    };


    var _getObjectValues= function(obj) {
        var values = [], key;

        for(key in obj) {
            if(Object.prototype.hasOwnProperty.call(obj, key)) {
                values.push(obj[key]);
            }
        }

        return values;
    };


    var _isConditionOptimizable = function(condition, objectStore) {
        var canOperatorFitInKeyRange, column, isColumnIndexed, operator, isValueBoolean;

        if(!(condition instanceof kony.nosql.Condition)
        || condition.data.length !== 1) {
            return false;
        }

        column = condition.data[0].column;
        operator = condition.data[0].operator;
        isColumnIndexed = objectStore.indexNames.contains(column);
        canOperatorFitInKeyRange = (operator !== _NEQ && operator !== _REGEXP);
        isValueBoolean = (typeof condition.data[0].value === 'boolean');

        return (isColumnIndexed && canOperatorFitInKeyRange && !isValueBoolean);
    };


    var _isConditionMatched = function(record, condition) {
        return eval(_expression(record, condition)); // eslint-disable-line no-eval
    };


    var _replaceRecordValues = function(record, valueObject, includeKeys) {
        var key;

        for(key in valueObject) {
            if(includeKeys instanceof Array) {
                if(includeKeys.indexOf(key) !== -1) {
                    record[key] = valueObject[key];
                }
            } else {
                record[key] = valueObject[key];
            }
        }

        return record;
    };


    var _updateAllByIndex = function(objectStore, index, keyRangeValue, updateObject) {
        return new Promise(function(resolve, reject) {
            var cursor, i, recordCount = 0, recordsToAdd = [], successCallback;

            successCallback = function(/*event*/) {
                recordCount++;

                if(recordCount === recordsToAdd.length) {
                    resolve();
                }
            };

            cursor = index.openCursor(keyRangeValue);

            cursor.onsuccess = function(event) {
                var $K = kony.$kwebfw$, $KU = $K.utils, record,
                    cursor = event.target.result, request;

                if(cursor) {
                    record = cursor.value;
                    record = _replaceRecordValues(record, updateObject);

                    if($KU.browser('name') === 'safari') {
                        recordsToAdd.push(record);
                    } else {
                        request = cursor.update(record);

                        request.onsuccess = function(/*event*/) {
                            //Do nothing
                        };
                        request.onerror = function(/*event*/) {
                            reject();
                        };
                    }

                    cursor.continue();
                } else {
                    if(recordsToAdd.length === 0) {
                        resolve();
                    } else {
                        for(i=0; i<recordsToAdd.length; i++) {
                            request = objectStore.put(recordsToAdd[i]);
                            request.onsuccess = successCallback.bind(this, recordCount, recordsToAdd);

                            request.onerror = function(event) {
                                reject(event);
                            };
                        }
                    }
                }
            };

            cursor.onerror = function(event) {
                reject(event);
            };
        });
    };


    /***************************************************************************
    *                                                                          *
    *                                                                          *
    ****************************************************************************/
    var _addOrReplaceRecords = function $K_nosql_addOrReplaceRecords(transaction, tableName, records) {
        var $K = kony.$kwebfw$, $KU = $K.utils, promise = null;
        $KU.log({api:'kony.nosql.addOrReplaceRecords', enter:true});
        if(!_iDB) {
            $KU.log('error', _NOT_SUPPORTED_MSG);
        } else {
            promise = new Promise(function(resolve, reject) {
                var i = 0, storeReq = null, tx = null, store = null,
                    onerrorcb = function(event) {
                        reject(event.target.error);
                    },
                    replaceNext = function() {
                        if(i < records.length) {
                            storeReq = store.put(records[i]);
                            storeReq.onsuccess = replaceNext;
                            storeReq.onerror = onerrorcb;
                            ++i;
                        } else {
                            $KU.log({api:'kony.nosql.addOrReplaceRecords', exit:true});
                            resolve();
                        }
                    };

                if(!(transaction instanceof _Transaction)) {
                    $KU.log('error', 'Pass proper transaction object.');
                    reject({'errorMsg': 'Pass proper transaction object.'});
                }

                tx = transaction.tx;
                store = tx.objectStore(tableName);

                replaceNext();
            });

            return promise;
        }
    };


    var _addRecords = function $K_nosql_addRecords(transaction, tableName, data) {
        var $K = kony.$kwebfw$, $KU = $K.utils, promise = null;
        $KU.log({api:'kony.nosql.addRecords', enter:true});
        if(!_iDB) {
            $KU.log('error', _NOT_SUPPORTED_MSG);
        } else {
            promise = new Promise(function(resolve, reject) {
                var i = 0, storeReq = null, tx = null, store = null,
                    onerrorcb = function(event) {
                        $KU.log('error', 'unknown error' + event.target.error);
                        reject(event.target.error);
                    },
                    addNext = function() {
                        if(i < data.length) {
                            storeReq = store.add(data[i]);
                            storeReq.onsuccess = addNext;
                            storeReq.onerror = onerrorcb;
                            ++i;
                        } else {
                            $KU.log({api:'kony.nosql.addRecords', exit:true});
                            resolve();
                        }
                    };

                if(transaction instanceof _Transaction) {
                    tx = transaction.tx;
                    store = tx.objectStore(tableName);
                    addNext();
                } else {
                    $KU.log('error', 'Pass proper transaction object.');
                    reject({errorMsg: 'Pass proper transaction object.'});
                }
            });

            return promise;
        }
    };


    var _clearTable = function $K_nosql_clearTable(transaction, tableName) {
        var $K = kony.$kwebfw$, $KU = $K.utils, promise = null;
        $KU.log({api:'kony.nosql.clearTable', enter:true});
        if(!_iDB) {
            $KU.log('error', _NOT_SUPPORTED_MSG);
        } else {
            promise = new Promise(function(resolve, reject) {
                var objectStore, tx, request;

                if(transaction instanceof _Transaction) {
                    tx = transaction.tx;
                    objectStore = tx.objectStore(tableName);
                    request = objectStore.clear();

                    request.onsuccess = function(/*event*/) {
                        $KU.log({api:'kony.nosql.clearTable', exit:true});
                        resolve();
                    };
                    request.onerror = function(event) {
                        reject(event.target.error);
                    };
                } else {
                    $KU.log('error', 'Pass proper transaction object.');
                    reject({errorMsg: 'Pass proper transaction object.'});
                }
            });

            return promise;
        }
    };


    var _closeDatabase = function $K_nosql_closeDatabase(database) {
        var $K = kony.$kwebfw$, $KU = $K.utils, promise = null;

        $KU.log({api:'kony.nosql.closeDatabase', enter:true});
        if(!_iDB) {
            $KU.log('error', _NOT_SUPPORTED_MSG);
        } else {
            promise = new Promise(function(resolve, reject) {
                var db;

                if(database instanceof _DataBase) {
                    db = database.db;
                    try{
                        db.close();
                        delete database.dbOpenRequest;
                        $KU.log({api:'kony.nosql.closeDatabase', exit:true});
                        resolve();
                    } catch(error) {
                        $KU.log('error', 'unknown error' + error);
                        delete database.dbOpenRequest;
                        reject(error);
                    }
                } else {
                    $KU.log('error', 'Pass proper database object.');
                    reject({'errorMsg': 'Pass proper database object.'});
                }
            });

            return promise;
        }
    };


    var _createIndices = function $K_nosql_createIndices(database, tableName, indexes) {
        var $K = kony.$kwebfw$, $KU = $K.utils, promise = null;

        $KU.log({api:'kony.nosql.createIndices', enter:true});
        if(!_iDB) {
            $KU.log('error', _NOT_SUPPORTED_MSG);
        } else {
            promise = new Promise(function(resolve, reject) {
                var request, store, transaction, index;

                try{
                    request = database.dbOpenRequest;
                    transaction = request.transaction;
                    store = transaction.objectStore(tableName);

                    for(index in indexes) {
                        store.createIndex(index, index, indexes[index]);
                    }
                } catch(error) {
                    reject(error);
                }

                transaction.oncomplete = function(/*e*/) {
                    $KU.log({api:'kony.nosql.createIndices', exit:true});
                    resolve(true);
                };
            });

            return promise;
        }
    };


    var _createTable = function $K_nosql_createTable(transaction, tableName, config) {
        var $K = kony.$kwebfw$, $KU = $K.utils, index = '',
            primaryKey = config.primaryKey, objectStore = null,
            indexes = config.indexes || {}, db = transaction.db;
            /*autoIncrement = $KU.is(primaryKey, 'array') ? false : config.autoIncrement;*/

        $KU.log({api:'kony.nosql.createTable', enter:true});
        if(!_iDB) {
            $KU.log('error', _NOT_SUPPORTED_MSG);
        } else {
            objectStore = db.createObjectStore(tableName, {keyPath: primaryKey, autoIncrement: false});
            for(index in indexes) {
                objectStore.createIndex(index, index, indexes[index]);
            }
        }
        $KU.log({api:'kony.nosql.createTable', exit:true});
    };


    var _databaseExists = function $K_nosql_databaseExists(databaseName) {
        var $K = kony.$kwebfw$, $KU = $K.utils, promise = null;

        $KU.log({api:'kony.nosql.databaseExists', enter:true});
        if(!_iDB) {
            $KU.log('error', _NOT_SUPPORTED_MSG);
        } else {
            promise = new Promise(function(resolve, reject) {
                var request = _iDB.open(_getDataBaseName(databaseName));

                request.onupgradeneeded = function(event) {
                    event.target.transaction.abort();
                    $KU.log({api:'kony.nosql.databaseExists', exit:true});
                    resolve(false);
                };
                request.onsuccess = function(event) {
                    var database = event.target.result;
                    $KU.log({api:'kony.nosql.databaseExists', exit:true});
                    resolve(true);
                    database.close();
                };
                request.onerror = function(event) {
                    $KU.log('error', 'unknown error' + event.target.error);
                    reject(event.target.error);
                };
            });

            return promise;
        }
    };


    var _databaseVersion = function $K_nosql_databaseVersion(databaseName) {
        var $K = kony.$kwebfw$, $KU = $K.utils, promise = null;

        $KU.log({api:'kony.nosql.databaseVersion', enter:true});
        if(!_iDB) {
            $KU.log('error', _NOT_SUPPORTED_MSG);
        } else {
            promise = new Promise(function(resolve, reject) {
                var request = _iDB.open(_getDataBaseName(databaseName));

                request.onupgradeneeded = function(event) {
                    event.target.transaction.abort();
                    $KU.log({api:'kony.nosql.databaseVersion', exit:true});
                    resolve(0);
                };
                request.onsuccess = function(event) {
                    var database = event.target.result;
                    resolve(database.version);
                    $KU.log({api:'kony.nosql.databaseVersion', exit:true});
                    database.close();
                };
                request.onerror = function(event) {
                    $KU.log('error', 'unknown error' + event.target.error);
                    reject(event.target.error);
                };
            });

            return promise;
        }
    };


    var _deleteDatabase = function $K_nosql_deleteDatabase(databaseName) {
        var $K = kony.$kwebfw$, $KU = $K.utils, promise = null;

        $KU.log({api:'kony.nosql.deleteDatabase', enter:true});
        if(!_iDB) {
            $KU.log('error', _NOT_SUPPORTED_MSG);
        } else {
            promise = new Promise(function(resolve, reject) {
                var request = _iDB.deleteDatabase(_getDataBaseName(databaseName));

                request.onsuccess = function(/*event*/) {
                    $KU.log({api:'kony.nosql.deleteDatabase', exit:true});
                    resolve();
                };
                request.onerror = function(event) {
                    $KU.log('error', 'unknown error' + event.target.error);
                    reject(event.target.error);
                };
            });

            return promise;
        }
    };


    var _deleteIndices = function $K_nosql_deleteIndices(database, tableName, indexes) {
        var $K = kony.$kwebfw$, $KU = $K.utils, promise = null;

        $KU.log({api:'kony.nosql.deleteIndices', enter:true});
        if(!_iDB) {
            $KU.log('error', _NOT_SUPPORTED_MSG);
        } else {
            promise = new Promise(function(resolve, reject) {
                var request, store, transaction, index;

                try{
                    request = database.dbOpenRequest;
                    transaction = request.transaction;
                    store = transaction.objectStore(tableName);

                    for(index in indexes) {
                        store.deleteIndex(index);
                    }
                } catch(error) {
                    reject(error);
                }

                transaction.oncomplete = function(/*e*/) {
                    $KU.log({api:'kony.nosql.deleteIndices', exit:true});
                    resolve(true);
                };
            });

            return promise;
        }
    };


    var _deleteRecords = function $K_nosql_deleteRecords(transaction, tableName, condition) {
        var $K = kony.$kwebfw$, $KU = $K.utils, promise = null;

        $KU.log({api:'kony.nosql.deleteRecords', enter:true});
        if(!_iDB) {
            $KU.log('error', _NOT_SUPPORTED_MSG);
        } else {
            promise = new Promise(function(resolve, reject) {
                var tx, objectStore, data, keyRangeValue, index;

                if(!(transaction instanceof _Transaction)) {
                    $KU.log('error', 'Pass proper transaction object');
                    reject({'errorMsg': 'Pass proper transaction object'});
                }

                tx = transaction.tx;
                objectStore = tx.objectStore(tableName);

                if(_isConditionOptimizable(condition, objectStore)) {
                    data = condition.data[0];
                    keyRangeValue = _getKeyRangeValue(data);
                    index = objectStore.index(data.column);

                    if(keyRangeValue) {
                        _deleteAllByIndex(objectStore, index, keyRangeValue).then(function() {
                            $KU.log({api:'kony.nosql.deleteRecords', exit:true});
                            resolve();
                        }).catch(function(event) {
                            $KU.log('error', 'unknown error' + event.message);
                            reject({errorMsg: event.message});
                        });
                    }
                } else {
                    objectStore.openCursor().onsuccess = function(event) {
                        var cursor = event.target.result, request;

                        if(cursor) {
                            if(!condition || _isConditionMatched(cursor.value, condition.data)) {
                                request = cursor.delete();

                                request.onsuccess = function(/*event*/) {
                                    $KU.log('info', 'deleteRecords success');
                                };
                                request.onerror = function(event) {
                                    reject(event.target.error);
                                };
                            }

                            cursor.continue();
                        } else {
                            resolve();
                        }
                    };
                }
            });

            return promise;
        }
    };


    var _deleteTable = function $K_nosql_deleteTable(database, tableName) {
        var $K = kony.$kwebfw$, $KU = $K.utils, promise = null;

        $KU.log({api:'kony.nosql.deleteTable', enter:true});
        if(!_iDB) {
            $KU.log('error', _NOT_SUPPORTED_MSG);
        } else {
            promise = new Promise(function(resolve, reject) {
                var db;

                if(database instanceof _DataBase) {
                    db = database.db;
                    db.deleteObjectStore(tableName);
                    $KU.log({api:'kony.nosql.deleteTable', exit:true});
                    resolve();
                } else {
                    $KU.log('error', 'Pass proper database object.');
                    reject({errorMsg: 'Pass proper database object.'});
                }
            });

            return promise;
        }
    };


    var _fetchRecords = function $K_nosql_fetchRecords(transaction, tableName, condition) {
        var $K = kony.$kwebfw$, $KU = $K.utils, promise = null;

        $KU.log({api:'kony.nosql.fetchRecords', enter:true});
        if(!_iDB) {
            $KU.log('error', _NOT_SUPPORTED_MSG);
        } else {
            promise = new Promise(function(resolve, reject) {
                var resultSet = null, objectStore, tx, data, keyRangeValue, index;
                var successCallback = function(records) {
                    if(condition instanceof _Condition) {
                        records = _filterRecords(records, condition.data);
                    }

                    resultSet = new _Result(records);
                    $KU.log({api:'kony.nosql.fetchRecords', exit:true});
                    resolve(resultSet);
                };
                var errorCallback = function(event) {
                    $KU.log('error', 'unknown error' + event.target.error);
                    reject(event.target.error);
                };

                if(!(transaction instanceof _Transaction)) {
                    $KU.log('error', 'Pass proper transaction object');
                    reject({'errorMsg': 'Pass proper transaction object'});
                }

                tx = transaction.tx;
                objectStore = tx.objectStore(tableName);

                if(_isConditionOptimizable(condition, objectStore)) {
                    data = condition.data[0];
                    keyRangeValue = _getKeyRangeValue(data);
                    index = objectStore.index(data.column);

                    if(keyRangeValue) {
                        _getAllByIndex(index, keyRangeValue).then(function(records) {
                            resultSet = new _Result(records);
                            resolve(resultSet);
                        }).catch(function(event) {
                            reject(event.target.error);//todo
                        });
                    }
                } else {
                    if(objectStore.getAll) {
                        objectStore = objectStore.getAll();
                    } else {
                        _getAll(objectStore).then(function(records) {
                            successCallback(records);
                        }).catch(function(errorObj) {
                            errorCallback(errorObj);
                        });
                    }
                    objectStore.onsuccess = function(event) {
                        successCallback(event.target.result);
                    };
                    objectStore.onerror = errorCallback;
                }
            });

            return promise;
        }
    };


    var _getPrimaryKeys = function $K_nosql_getPrimaryKeys(database, tableName, transaction) {
        var $K = kony.$kwebfw$, $KU = $K.utils, promise = null;

        $KU.log({api:'kony.nosql.getPrimaryKeys', enter:true});
        if(!_iDB) {
            $KU.log('error', _NOT_SUPPORTED_MSG);
        } else {
            promise = new Promise(function(resolve, reject) {
                var primaryKeys, objectStore;
                var _getPrimaryKeys = function(transaction) {
                    var primaryKeys = [];

                    objectStore = transaction.tx.objectStore(tableName);
                    primaryKeys = (typeof objectStore.keyPath === 'string')
                        ? [objectStore.keyPath] : objectStore.keyPath;

                    return primaryKeys;
                };

                kony.nosql.tableExists(database, tableName).then(function(exists) {
                    if(exists) {
                        if(!transaction) {
                            kony.nosql.openTransaction(database, [tableName], kony.nosql.READ_WRITE, function(transaction) {
                                primaryKeys = _getPrimaryKeys(transaction);
                            }).then(function() {
                                $KU.log({api:'kony.nosql.getPrimaryKeys', exit:true});
                                resolve(primaryKeys);
                            }).catch(function(error) {
                                reject(error);
                            });
                        } else {
                            $KU.log({api:'kony.nosql.getPrimaryKeys', exit:true});
                            resolve(_getPrimaryKeys(transaction));
                        }
                    } else {
                        $KU.log('error', 'Table doesn\'t exists.');
                        reject({errorMsg: 'Table doesn\'t exists.'});
                    }
                }).catch(function(error) {
                    reject(error);
                });
            });

            return promise;
        }
    };


    var _getTables = function $K_nosql_getTables(database) {
        var $K = kony.$kwebfw$, $KU = $K.utils, promise = null;

        $KU.log({api:'kony.nosql.getTables', enter:true});
        if(!_iDB) {
            $KU.log('error', _NOT_SUPPORTED_MSG);
        } else {
            promise = new Promise(function(resolve, reject) {
                var db;

                if(database instanceof _DataBase) {
                    db = database.db;
                    $KU.log({api:'kony.nosql.getTables', exit:true});
                    resolve(_getObjectValues(db.objectStoreNames));
                } else {
                    $KU.log('error', 'Pass proper database object.');
                    reject({errorMsg: 'Pass proper database object.'});
                }
            });

            return promise;
        }
    };


    var _openDatabase = function $K_nosql_openDatabase(databaseName, version, upgradeCallback) {
        var $K = kony.$kwebfw$, $KU = $K.utils, promise = null;

        $KU.log({api:'kony.nosql.openDatabase', enter:true});
        if(!_iDB) {
            $KU.log('error', _NOT_SUPPORTED_MSG);
        } else {
            promise = new Promise(function(resolve, reject) {
                var request, kdb;

                if(version) {
                    request = _iDB.open(_getDataBaseName(databaseName), version);
                } else {
                    request = _iDB.open(_getDataBaseName(databaseName));
                }

                request.onerror = function(event) {
                    reject(event.target.error);
                };
                request.onsuccess = function(/*event*/) {
                    var db = request.result;

                    kdb = kdb || new _DataBase(db, 'indexedDB', request);
                    $KU.log({api:'kony.nosql.openDatabase', exit:true});
                    resolve(kdb);
                };
                request.onupgradeneeded = function(event) {
                    var db = event.target.result;

                    kdb = new _DataBase(db, 'indexedDB', request);
                    upgradeCallback && upgradeCallback(kdb);
                };
            });

            return promise;
        }
    };


    var _openTransaction = function $K_nosql_openTransaction(database, tableNames, accessType, callback) {
        var $K = kony.$kwebfw$, $KU = $K.utils, promise = null;

        $KU.log({api:'kony.nosql.openTransaction', enter:true});
        if(!_iDB) {
            $KU.log('error', _NOT_SUPPORTED_MSG);
        } else {
            promise = new Promise(function(resolve, reject) {
                var db = database.db, tx = db.transaction(tableNames, accessType),
                    transaction = new _Transaction(tx);

                callback(transaction);

                tx.oncomplete = function(/*e*/) {
                    $KU.log({api:'kony.nosql.openTransaction', exit:true});
                    resolve(transaction);
                };
                tx.onerror = function(e) {
                    $KU.log('error', 'unknown error' + e);
                    reject(e.target.error);
                };
                tx.onabort = function(e) {
                    $KU.log('error', 'unknown error' + e);
                    reject(e.target.error);
                };
            });

            return promise;
        }
    };


    var _replaceRecords = function $K_nosql_replaceRecords(transaction, tableName, replaceObject, condition) {
        var $K = kony.$kwebfw$, $KU = $K.utils, promise = null;

        $KU.log({api:'kony.nosql.replaceRecords', enter:true});
        if(!_iDB) {
            $KU.log('error', _NOT_SUPPORTED_MSG);
        } else {
            promise = new Promise(function(resolve, reject) {
                kony.nosql.fetchRecords(transaction, tableName, condition).then(function(resultSet) {
                    var i = 0, storeReq = null, store, records = resultSet.data,
                        onerrorcb = function(event) {
                            reject(event.target.error);
                        },
                        replaceNext = function() {
                            var record, primaryKeys;

                            if(i < records.length) {
                                record = records[i];
                                primaryKeys = (typeof store.keyPath === 'string') ? [store.keyPath] : store.keyPath;

                                record = _replaceRecordValues(replaceObject, record, primaryKeys);

                                storeReq = store.put(record);
                                storeReq.onsuccess = replaceNext;
                                storeReq.onerror = onerrorcb;
                                ++i;
                            } else {
                                $KU.log({api:'kony.nosql.replaceRecords', exit:true});
                                resolve();
                            }
                        };

                    if(!(transaction instanceof _Transaction)) {
                        $KU.log('error', 'Pass proper transaction object.');
                        reject({'errorMsg': 'Pass proper transaction object.'});
                    }

                    store = transaction.tx.objectStore(tableName);

                    replaceNext();
                }).catch(function(error) {
                    $KU.log('error', 'unknown error' + error);
                    reject(error);
                });
            });

            return promise;
        }
    };


    var _tableExists = function $K_nosql_tableExists(database, tableName) {
        var $K = kony.$kwebfw$, $KU = $K.utils, promise = null;

        $KU.log({api:'kony.nosql.tableExists', enter:true});
        if(!_iDB) {
            $KU.log('error', _NOT_SUPPORTED_MSG);
        } else {
            promise = new Promise(function(resolve, reject) {
                var tableExists;

                if(database instanceof _DataBase) {
                    kony.nosql.getTables(database).then(function(tables) {
                        if(tables.indexOf(tableName) !== -1) {
                            tableExists = true;
                        } else {
                            tableExists = false;
                        }
                        $KU.log({api:'kony.nosql.tableExists', exit:true});
                        resolve(tableExists);
                    }).catch(function(error) {
                        reject(error);
                    });
                } else {
                    $KU.log('error', 'Pass proper database object.');
                    reject({errorMsg: 'Pass proper database object.'});
                }
            });

            return promise;
        }
    };


    var _updateRecords = function $K_nosql_updateRecords(transaction, tableName, updateObject, condition) {
        var $K = kony.$kwebfw$, $KU = $K.utils, promise = null;

        $KU.log({api:'kony.nosql.updateRecords', enter:true});
        if(!_iDB) {
            $KU.log('error', _NOT_SUPPORTED_MSG);
        } else {
            promise = new Promise(function(resolve, reject) {
                var index, objectStore, data, keyRangeValue;


                if(!(transaction instanceof _Transaction)) {
                    $KU.log('error', 'Pass proper transaction object.');
                    reject({'errorMsg': 'Pass proper transaction object'});
                }

                objectStore = transaction.tx.objectStore(tableName);

                if(_isConditionOptimizable(condition, objectStore)) {
                    data = condition.data[0];
                    index = objectStore.index(data.column);
                    keyRangeValue = _getKeyRangeValue(data);

                    if(keyRangeValue) {
                        _updateAllByIndex(objectStore, index, keyRangeValue, updateObject).then(function() {
                            $KU.log({api:'kony.nosql.updateRecords', exit:true});
                            resolve();
                        }).catch(function(event) {
                            $KU.log('error', 'unknown' + event.message);
                            reject({errorMsg: event.message});
                        });
                    }
                } else {
                    objectStore.openCursor().onsuccess = function(event) {
                        var cursor = event.target.result, record, request;

                        if(cursor) {
                            record = cursor.value;
                            if(!condition || _isConditionMatched(record, condition.data)) {
                                record = _replaceRecordValues(record, updateObject);
                                request = cursor.update(record);
                                request.onsuccess = function(/*event*/) {
                                    $KU.log('info', 'Successfully deleting record.');
                                };
                                request.onerror = function(/*event*/) {
                                    reject();
                                };
                            }

                            cursor.continue();
                        } else {
                            resolve();
                        }
                    };
                }
            });

            return promise;
        }
    };


    /***************************************************************************
    *                                                                          *
    ****************************************************************************/
    var _Condition = function Condition(ruleOrCondition) {
        var $K = kony.$kwebfw$, $KU = $K.utils, data = null;

        if(!_iDB) {
            $KU.log('error', _NOT_SUPPORTED_MSG);
        } else if(!(this instanceof _Condition)) {
            //Throw Error:: Must be called with new operator.
        } else {
            data = [];

            Object.defineProperty(this, 'data', {
                configurable: true,
                enumerable: false,
                get: function() {
                    return (this.passReference) ? data : data.slice(0);
                }
            });
            Object.defineProperty(this, 'data', {
                configurable: false,
                enumerable: false,
                set: function(/*value*/) {}
            });

            if(ruleOrCondition instanceof _Rule) {
                data.push({
                    'column':   ruleOrCondition.column,
                    'operator': ruleOrCondition.operator,
                    'value':    ruleOrCondition.value
                });
            } else if(ruleOrCondition instanceof _Condition) {
                data.push(ruleOrCondition.data);
            } else {
                //Throw Error:: Invalid Argument
            }
        }
    };

    Object.defineProperty(_Condition.prototype, 'addCondition', {
        configurable: false,
        enumerable: false,
        writable: false,
        value: function(type, condition) {
            if(_validTypes.indexOf(type) >= 0 && condition instanceof _Condition) {
                this.passReference = true;
                this.data.push(type);
                this.data.push(condition.data);
                delete this.passReference;
            } else {
                //TODO:: Throw Error
            }

            return this;
        }
    });

    Object.defineProperty(_Condition.prototype, 'addRule', {
        configurable: false,
        enumerable: false,
        writable: false,
        value: function(type, rule) {
            if(_validTypes.indexOf(type) >= 0 && rule instanceof _Rule) {
                this.passReference = true;
                this.data.push(type);
                this.data.push({
                    'column':   rule.column,
                    'operator': rule.operator,
                    'value':    rule.value
                });
                delete this.passReference;
            } else {
                //TODO:: Throw Error:: Invalid Arguments
            }

            return this;
        }
    });

    //Any record cannot contain an object as any of its column value
    Object.defineProperty(_Condition.prototype, 'toString', {
        configurable: false,
        enumerable: false,
        writable: false,
        value: function() {
            var stringifyCondition = function(condition) {
                var str = '', c = 0, clen = condition.length;

                for(c=0; c<clen; c++) {
                    if(condition[c] instanceof Array) {
                        str += stringifyCondition(condition[c]);
                    } else if(typeof condition[c] === 'string') {
                        str += (' ' + condition[c] + ' ');
                    } else if(typeof condition[c] === 'object' && condition[c]) {
                        str += stringifyRule(condition[c]);
                    }
                }

                return ('(' + str + ')');
            };

            var stringifyRule = function(rule) {
                var str = rule.column + ' ' + rule.operator + ' ';

                if(typeof rule.value === 'string') {
                    //TODO:: Escape all 'backslash', 'doublequote'
                    str += ('\'' + rule.value + '\'');
                } else {
                    str += rule.value;
                }

                return str;
            };

            return stringifyCondition(this.data);
        }
    });


    /***************************************************************************
    *                                                                          *
    ****************************************************************************/
    var _DataBase = function DataBase(db, dbType, dbOpenRequest) {
        var $K = kony.$kwebfw$, $KU = $K.utils;

        if(!_iDB) {
            $KU.log('error', _NOT_SUPPORTED_MSG);
        } else {
            Object.defineProperty(this, 'db', {
                configurable: false,
                enumerable: false,
                writable: false,
                value: db
            });
            Object.defineProperty(this, 'dbType', {
                configurable: false,
                enumerable: false,
                writable: false,
                value: dbType
            });
            Object.defineProperty(this, 'dbOpenRequest', {
                configurable: true,
                enumerable: false,
                writable: false,
                value: dbOpenRequest
            });
        }
    };


    /***************************************************************************
    *                                                                          *
    ****************************************************************************/
    var _Result = function Result(data) {
        var $K = kony.$kwebfw$, $KU = $K.utils, index = -1, length = -1;

        if(!_iDB) {
            $KU.log('error', _NOT_SUPPORTED_MSG);
        } else {
            data = (data instanceof Array) ? data : [];

            Object.defineProperty(this, 'data', {
                configurable: true,
                enumerable: false,
                get: function() {
                    return (this.passReference) ? data : data.slice(0);
                }
            });
            Object.defineProperty(this, 'data', {
                configurable: false,
                enumerable: false,
                set: function(/*value*/) {}
            });


            Object.defineProperty(this, 'length', {
                configurable: true,
                enumerable: false,
                get: function() {
                    if(length === -1) {
                        length = data.length;
                    }

                    return length;
                }
            });
            Object.defineProperty(this, 'length', {
                configurable: false,
                enumerable: false,
                set: function(/*value*/) {}
            });


            Object.defineProperty(this, 'next', {
                configurable: true,
                enumerable: false,
                get: function() {
                    ++index;
                    return (index >= 0 && index < data.length) ? true : false;
                }
            });
            Object.defineProperty(this, 'next', {
                configurable: false,
                enumerable: false,
                set: function(/*value*/) {}
            });


            Object.defineProperty(this, 'record', {
                configurable: true,
                enumerable: false,
                get: function() {
                    return (index >= 0 && index < data.length) ? data[index] : null;
                }
            });
            Object.defineProperty(this, 'record', {
                configurable: false,
                enumerable: false,
                set: function(/*value*/) {}
            });
        }
    };

    Object.defineProperty(_Result.prototype, 'groupBy', {
        configurable: false,
        enumerable: false,
        writable: false,
        value: function(columnNames, index) {
            var data = null;

            this.passReference = true;
            data = this.data;
            delete this.passReference;
            var result = {};

            function __prepareMap() {
                var row, name, i, j;
                for(i = 0; i < data.length; i++) {
                    row = data[i];
                    name = '';
                    for(j = 0; j < columnNames.length; j++) {
                        name += row[columnNames[j]];
                        if(j < columnNames.length -1) {
                            name += '&_';
                        }
                    }

                    if(name in result) {
                        result[name].push(row);
                    } else {
                        result[name] = [row];
                    }
                }
                //console.log(result);
            }

            function __prepareResults() {
                var resultSet = [], i, key, finalResult = [];
                for(key in result) {
                    resultSet.push(result[key]);
                }

                if(typeof index === 'number') {
                    for(i = 0; i < resultSet.length; i++) {
                        if(index >= 0) {
                            finalResult.push(resultSet[i][index]);
                        } else {
                            key = resultSet[i].length + index;
                            finalResult.push(resultSet[i][key]);
                        }
                    }
                    return finalResult;
                }
                return resultSet;
            }

            if(columnNames instanceof Array) {
                /* eslint-disable no-useless-catch */
                try{
                    __prepareMap();
                    return __prepareResults();
                } catch(e) {
                    throw e;
                }
                /* eslint-enable no-useless-catch */
            }
        }
    });

    Object.defineProperty(_Result.prototype, 'limit', {
        configurable: false,
        enumerable: false,
        writable: false,
        value: function(startIndex, recordCount) {
            var data = null, copy = null, c = 0, clen = 0;

            if(typeof startIndex === 'number'
            && typeof recordCount === 'number'
            && startIndex >= 0 && recordCount >= 0) {
                this.passReference = true;
                data = this.data;
                delete this.passReference;

                copy = data.splice(0);
                clen = copy.length;

                for(c=startIndex; c<=recordCount; c++) {
                    if(c < clen) {
                        data.push(copy[c]);
                    } else {
                        break;
                    }
                }
            } else {
                //Throw Error:: Invalid Arguments
            }

            return this;
        }
    });

    Object.defineProperty(_Result.prototype, 'sort', {
        configurable: false,
        enumerable: false,
        writable: false,
        value: function(columnName, order) {
            var data = null;

            function __localsort(data, name, order) {
                data.sort(function(a, b) {
                    a = a[name];
                    b = b[name];
                    if(order === kony.nosql.ASCENDING) {
                        return (a > b) ? 1 : (a < b) ? -1 : 0;
                    }
                    return (a > b) ? -1 : (a < b) ? 1 : 0;
                });
            }

            function __groupByName(data, name) {
                var i, result = [], temp = [], value;

                temp.push(data[0]);
                value = data[0][name];

                for(i = 1; i < data.length; i++) {
                    if(data[i][name] === value) {
                        temp.push(data[i]);
                    } else {
                        if(temp.length === 1) {
                            result.push(temp[0]);
                        } else {
                            result.push(temp);
                        }

                        temp = [];
                        value = data[i][name];
                        temp.push(data[i]);
                    }
                }

                result.push(temp);
                return result;
            }

            function __createFlatArray(result) {
                var i, len, temp = [];

                for(i = 0; i < result.length; i++) {
                    if(result[i] instanceof Array) {
                        for(len = 0; len < result[i].length; len++) {
                            temp.push(result[i][len]);
                        }
                    } else {
                        temp.push(result[i]);
                    }
                }

                return temp;
            }

            function __orderBY(data, index, order) {
                var i, result = [], result1 = [];

                if(index >= columnName.length) {
                    return data;
                }

                __localsort(data, columnName[index], order);
                result = __groupByName(data, columnName[index]);

                for(i = 0; i < result.length; i++) {
                    if(result[i] instanceof Array) {
                        result1 = __orderBY(result[i], index+1, order);
                        result[i] = result1;
                    }
                }

                result = __createFlatArray(result);
                return result;
            }

            this.passReference = true;
            data = this.data;
            delete this.passReference;

            if(typeof columnName === 'function') {
                data.sort(columnName);
            } else if(typeof columnName === 'string'
            && _validOrders.indexOf(order) >= 0) {
                data.sort(function(a, b) {
                    a = a[columnName];
                    b = b[columnName];

                    if(order === kony.nosql.ASCENDING) {
                        return (a > b) ? 1 : (a < b) ? -1 : 0;
                    }
                    return (a > b) ? -1 : (a < b) ? 1 : 0;
                });
            } else if(columnName instanceof Array
            && _validOrders.indexOf(order) >= 0) {
                var i, sortedData = [];

                sortedData = this.data;
                sortedData = __orderBY(sortedData, 0, order);
                data.splice(0, data.length);

                for(i =0; i < sortedData.length; i++) {
                    data.push(sortedData[i]);
                }
            } else {
                //Throw Error:: Invalid Arguments
            }

            return this;
        }
    });


    /*
    var r1 = new _Rule('col_01', '===', 'A');
    var r2 = new _Rule('col_01', '===', 'B');
    var r3 = new _Rule('col_01', '===', 'C');
    var r4 = new _Rule('col_01', '===', 'D');
    var r5 = new _Rule('col_01', '===', 'E');
    var r6 = new _Rule('col_01', '===', 'F');
    var r7 = new _Rule('col_01', '===', 'G');

    var c1 = new _Condition(r1);
    var c2 = new _Condition(r3);
    var c3 = new _Condition(r4);
    var c4 = new _Condition(r6);

    c1.addRule('&&', r2);
    c3.addRule('||', r5);
    c4.addRule('||', r7);

    c3.addCondition('&&', c4);
    c1.addCondition('||', c2);
    c1.addCondition('||', c3);
    //*/
    /***************************************************************************
    *                                                                          *
    ****************************************************************************/
    var _Rule = function Rule(column, operator, value) {
        var $K = kony.$kwebfw$, $KU = $K.utils;

        if(!_iDB) {
            $KU.log('error', _NOT_SUPPORTED_MSG);
        } else if(!(this instanceof _Rule)) {
            //Throw Error:: Must be called with new operator.
        } else if(operator === _REGEXP && !(value instanceof RegExp)) {
            throw Error('Invalid arguments.');
        } else if(!(arguments.length === 3
        && typeof column === 'string' && column
        && _validOperators.indexOf(operator) >= 0)) {
            //Throw Error:: Invalid Arguments
        } else {
            Object.defineProperty(this, 'column', {
                configurable: true,
                enumerable: true,
                get: function() {
                    return column;
                }
            });
            Object.defineProperty(this, 'column', {
                configurable: false,
                enumerable: true,
                set: function(val) {
                    column = val;
                }
            });


            Object.defineProperty(this, 'operator', {
                configurable: true,
                enumerable: true,
                get: function() {
                    return operator;
                }
            });
            Object.defineProperty(this, 'operator', {
                configurable: false,
                enumerable: true,
                set: function(val) {
                    operator = val;
                }
            });


            Object.defineProperty(this, 'value', {
                configurable: true,
                enumerable: true,
                get: function() {
                    return value;
                }
            });
            Object.defineProperty(this, 'value', {
                configurable: false,
                enumerable: true,
                set: function(val) {
                    value = val;
                }
            });
        }
    };


    /***************************************************************************
    *                                                                          *
    ****************************************************************************/
    var _Transaction = function Transaction(tx) {
        var $K = kony.$kwebfw$, $KU = $K.utils;

        if(!_iDB) {
            $KU.log('error', _NOT_SUPPORTED_MSG);
        } else {
            Object.defineProperty(this, 'tx', {
                configurable: false,
                enumerable: false,
                writable: false,
                value: tx
            });
        }
    };


    if(_iDB) {
        _validTypes = [_AND, _OR];
        _validOrders = [_ASCENDING, _DESCENDING];
        _validOperators = [_EQ, _GT, _GTE, _LT, _LTE, _NEQ, _REGEXP];
    }


    $K.defKonyProp(_ns, [
        {keey:'addOrReplaceRecords', value:_addOrReplaceRecords},
        {keey:'addRecords', value:_addRecords},
        {keey:'clearTable', value:_clearTable},
        {keey:'closeDatabase', value:_closeDatabase},
        {keey:'Condition', value:_Condition},
        {keey:'createIndices', value:_createIndices},
        {keey:'createTable', value:_createTable},
        {keey:'databaseExists', value:_databaseExists},
        {keey:'databaseVersion', value:_databaseVersion},
        {keey:'deleteDatabase', value:_deleteDatabase},
        {keey:'deleteIndices', value:_deleteIndices},
        {keey:'deleteRecords', value:_deleteRecords},
        {keey:'deleteTable', value:_deleteTable},
        {keey:'fetchRecords', value:_fetchRecords},
        {keey:'getPrimaryKeys', value:_getPrimaryKeys},
        {keey:'getTables', value:_getTables},
        {keey:'openDatabase', value:_openDatabase},
        {keey:'openTransaction', value:_openTransaction},
        {keey:'replaceRecords', value:_replaceRecords},
        {keey:'Rule', value:_Rule},
        {keey:'tableExists', value:_tableExists},
        {keey:'updateRecords', value:_updateRecords},
        //Constants starts from here...
        {keey:'AND', value:_AND},
        {keey:'ASCENDING', value:_ASCENDING},
        {keey:'DESCENDING', value:_DESCENDING},
        {keey:'EQ', value:_EQ},
        {keey:'GT', value:_GT},
        {keey:'GTE', value:_GTE},
        {keey:'LT', value:_LT},
        {keey:'LTE', value:_LTE},
        {keey:'NEQ', value:_NEQ},
        {keey:'OR', value:_OR},
        {keey:'READ', value:_READ},
        {keey:'READ_WRITE', value:_READ_WRITE},
        {keey:'REGEXP', value:_REGEXP}
    ]);


    return _ns;
}())});

/* FilePath: lib/apis/konyos.js */
/* Version: 202305.0.0 */
/* TimeStamp: Fri Apr 14 2023 18:32:28 */
Object.defineProperty(kony, 'os', {configurable:false, enumerable:false, writable:false, value:(function() {
    var _ns = {}, $K = kony.$kwebfw$;


    var _deviceInfo = function() {
        var $K = kony.$kwebfw$, $KU = $K.utils, info = {};

        $KU.log({api:'kony.os.deviceInfo', enter:true});

        info.category = $KU.browser('name');
        if(info.category === 'msie') info.category = 'IE';
        else info.category = info.category[0].toUpperCase()+info.category.substr(1);
        info.deviceid = (function() {
            var $K = kony.$kwebfw$, $KU = $K.utils, $KA = $K.app,
                id = '', store = null, data = null;

            if(window.localStorage && typeof localStorage.getItem === 'function') {
                data = localStorage.getItem($KA.id);

                if(typeof data === 'string' && data) {
                    try{
                        store = JSON.parse(data);
                    } catch(e) {
                        store = data;
                    }
                }

                if(typeof store === 'object' && store) {
                    if(typeof store.deviceId === 'string' && store.deviceId) {
                        id = store.deviceId;
                    } else {
                        store.deviceId = id = $KU.uuid();
                        localStorage.setItem($KA.id, JSON.stringify(store));
                    }
                }
            } else if(typeof $KA.id === 'string' && $KA.id) {
                id = $KU.uuid();
            }

            return id;
        }());
        info.deviceHeight = screen.availHeight;
        info.deviceWidth = screen.availWidth;
        info.hascamera = $KU.browser('supports', 'usermedia');
        info.hasgps = $KU.browser('supports', 'geolocation');
        info.hastouchsupport = $KU.browser('supports', 'touch');
        info.hasorientationsupport = $KU.browser('supports', 'orientation');
        info.httpheaders = '//TODO::';
        info.imagecat = $K.device.resolution;
        info.ip = '';
        info.iswifiavailable = ($KU.is(navigator.onLine, 'boolean') ? navigator.onLine : true);
        info.model = '';
        info.name = 'thinclient';
        info.screenHeight = (window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight);
        info.screenWidth = (window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth);
        info.type = 'spa';
        info.userAgent = navigator.userAgent;
        info.version = $KU.browser('version');

        $KU.log({api:'kony.os.deviceInfo', exit:true});

        return info;
    };


    var _userAgent = function() {
        var $K = kony.$kwebfw$, $KU = $K.utils;

        $KU.log({api:'kony.os.userAgent', enter:true});
        $KU.log({api:'kony.os.userAgent', exit:true});

        return navigator.userAgent;
    };


    $K.defKonyProp(_ns, [
        {keey:'deviceInfo', value:_deviceInfo},
        {keey:'userAgent', value:_userAgent}
    ]);
    return _ns;
}())});

/* FilePath: lib/utils/konystore.js */
/* Version: 202305.0.0 */
/* TimeStamp: Fri Apr 14 2023 18:32:28 */
Object.defineProperty(kony.$kwebfw$, 'store', {configurable:false, enumerable:false, writable:false, value:(function() {
    var _ns = {}, $K = kony.$kwebfw$;


    var _ = {
        local: {
            clear: function() {
                if(window.localStorage) {
                    localStorage.clear();
                } else {
                    //LOG:: LOG WARNING - 'localStorage is not available.'
                }
            },

            fetch: function(key) {
                var $K = kony.$kwebfw$, $KU = $K.utils, data = null;

                if(window.localStorage) {
                    data = localStorage.getItem(key);
                    data = ($KU.is(data, 'string')) ? data : null;
                } else {
                    //LOG:: LOG WARNING - 'localStorage is not available.'
                }

                return data;
            },

            put: function(key, value) {
                var success = true;

                if(window.localStorage) {
                    try{
                        localStorage.setItem(key, value);
                    } catch(err) {
                        success = false;

                        if(err.name === 'QUOTA_EXCEEDED_ERR'
                        || err.name === 'QuotaExceededError') {
                            if(localStorage.length === 0) {
                                //LOG:: LOG WARNING - 'Private Browsing is switched ON.'
                            } else {
                                //LOG:: LOG WARNING - 'Local storage limit has exceeded.'
                            }
                        } else {
                            //LOG:: LOG ERROR - 'Unexpected error encountered.'
                        }
                    }
                } else {
                    success = false;
                    //LOG:: LOG WARNING - 'localStorage is not available.'
                }

                return success;
            },

            remove: function(key) {
                if(window.localStorage) {
                    localStorage.removeItem(key);
                } else {
                    //LOG:: LOG WARNING - 'localStorage is not available.'
                }
            }
        },


        session: {
            clear: function() {
                if(window.sessionStorage) {
                    sessionStorage.clear();
                } else {
                    //LOG:: LOG WARNING - 'sessionStorage is not available.'
                }
            },

            fetch: function(key) {
                if(window.sessionStorage) {
                    return sessionStorage.getItem(key);
                }
                //LOG:: LOG WARNING - 'sessionStorage is not available.'

                return null;
            },

            put: function(key, value) {
                if(window.sessionStorage) {
                    try{
                        sessionStorage.setItem(key, value);
                    } catch(err) {
                        if(err.name === 'QUOTA_EXCEEDED_ERR'
                        || err.name === 'QuotaExceededError') {
                            if(sessionStorage.length === 0) {
                                //LOG:: LOG WARNING - 'Private Browsing is switched ON.'
                            } else {
                                //LOG:: LOG WARNING - 'Session storage limit has exceeded.'
                            }
                        } else {
                            //LOG:: LOG ERROR - 'Unexpected error encountered.'
                        }
                    }
                } else {
                    //LOG:: LOG WARNING - 'sessionStorage is not available.'
                }
            },

            remove: function(key) {
                if(window.sessionStorage) {
                    sessionStorage.removeItem(key);
                } else {
                    //LOG:: LOG WARNING - 'sessionStorage is not available.'
                }
            }
        }
    };


    var _clear = function(type) {
        _[type] && _[type].clear();
    };


    var _fetch = function(type, key) {
        if(_[type]) return _[type].fetch(key);
        return null;
    };


    var _put = function(type, key, value) {
        if(_[type]) return _[type].put(key, value);
        return false;
    };


    var _remove = function(type, key) {
        _[type] && _[type].remove(key);
    };


    $K.defKonyProp(_ns, [
        {keey:'clear', value:_clear},
        {keey:'fetch', value:_fetch},
        {keey:'put', value:_put},
        {keey:'remove', value:_remove}
    ]);


    return _ns;
}())});

/* FilePath: lib/apis/konytimer.js */
/* Version: 202305.0.0 */
/* TimeStamp: Fri Apr 14 2023 18:32:28 */
Object.defineProperty(kony, 'timer', {configurable:false, enumerable:false, writable:false, value:(function() {
    var _ns = {}, _map = {}, $K = kony.$kwebfw$;


    var _cancel = function(id) {
        var $K = kony.$kwebfw$, $KU = $K.utils, timer = null, func = null;

        $KU.log({api:'kony.timer.cancel', enter:true});

        if((($KU.is(id, 'string') && id) || $KU.is(id, 'number'))) {
            id = ('' + id);

            if(Object.prototype.hasOwnProperty.call(_map, id)) {
                timer = _map[id];
                func = (timer.repeat) ? 'clearInterval' : 'clearTimeout';

                window[func](timer.id);
                delete _map[id];
                $KU.log({api:'kony.timer.cancel', exit:true});
            } else {
                $KU.log('warn', 'No timer found with id="'+id+'".');
                $KU.log({api:'kony.timer.cancel', exit:true});
                return null;
            }
        } else {
            $KU.log({api:'kony.timer.cancel', exit:true});
        }
    };


    var _schedule = function(id, callback, interval, repeat) {
        var $K = kony.$kwebfw$, $KU = $K.utils, func = null;

        $KU.log({api:'kony.timer.schedule', enter:true});

        if((($KU.is(id, 'string') && id)
                || $KU.is(id, 'number'))
        && $KU.is(callback, 'function')
        && $KU.is(interval, 'number')) {
            id = ('' + id);

            if(!$KU.is(repeat, 'boolean')) {
                repeat = false;
            }

            _map[id] = {callback:callback, repeat:repeat};
            func = (repeat) ? 'setInterval' : 'setTimeout';

            _map[id].id = window[func](function() {
                _map[id] && _map[id].callback();
                !repeat && _cancel(id);
            }, (interval*1000));
        }

        $KU.log({api:'kony.timer.schedule', exit:true});
    };


    var _setCallBack = function(id, callback) {
        var $K = kony.$kwebfw$, $KU = $K.utils, timer = null;

        $KU.log({api:'kony.timer.setCallBack', enter:true});

        if((($KU.is(id, 'string') && id)
                || $KU.is(id, 'number'))
        && $KU.is(callback, 'function')) {
            timer = _map[(''+id)];

            if(timer) {
                timer.callback = callback;
            } else {
                //LOG:: WARN
            }
        }

        $KU.log({api:'kony.timer.setCallBack', exit:true});
    };


    $K.defKonyProp(_ns, [
        {keey:'cancel', value:_cancel},
        {keey:'schedule', value:_schedule},
        {keey:'setCallBack', value:_setCallBack}
    ]);


    return _ns;
}())});

/*
 *
 *  File      : license.js
 *  Version   : 9.3.0.3
 *  TimeStamp : 16-06-2021 13:39:31 IST
 *
 */

kony.license = {};
kony.license.disableMetricReporting = function() {
    kony.ds.save(["true"], "LicenseDisableFlag");
}

kony.licensevar = {};
kony.licensevar.didAppWentInBackground = false;
kony.license.timeoutValue = 14400 ;
kony.license.version = "9.3.0.3";
kony.licensevar.currentSessionId = "";
kony.licensevar.latestSessionCreationTimestamp = "";
kony.licensevar.maxSessionCountLimit = 100;
kony.licensevar.changeHandlers = [];
kony.licensevar.isLicenseUrlAvailable = true;
kony.licensevar.isISTNetworkCallProcessingInProgress = false;
kony.licensevar.deferredNewSessionsCounter = 0;
kony.licensevar.isInteractive = false;
kony.licensevar.isPostAppInitCalled = false;
kony.licensevar.timesAppBecomeInteractive = 0;
kony.licensevar.maxDeferSessionCount = 15;
kony.licensevar.appLaunch = "appLaunch";

kony.licensevar.appStateCallbackFunction = function () {
    kony.licensevar.timesAppBecomeInteractive++;
    kony.license.log("appStateCallbackFunction:: isPostAppInitCalled :" + kony.licensevar.isPostAppInitCalled + " ,isInteractive :" + kony.licensevar.isInteractive);
    if (kony.licensevar.isInteractive === false) {
        kony.licensevar.isInteractive = true;
        kony.license.log("App is in interactive state");
        if (kony.licensevar.isPostAppInitCalled === true) {
            /* Create a new interactive session if app got launched in silent mode and later comes to postappinit due to user
            action such as clicking the notification (isAppLaunchedForInteraction callback is invoked later)*/
            kony.license.log("Creating and sending a new interactive session details.");
            kony.license.sendNewIST();
        }
    }
    else {
        kony.license.log("Warning: appStateCallbackFunction is called "+kony.licensevar.timesAppBecomeInteractive+" times, ignoring the interactive app state event");
    }
};

kony.licensevar.callbacksObjList = {};
kony.licensevar.callbacksObjList.isAppLaunchedForInteraction = {};
kony.licensevar.callbacksObjList.isAppLaunchedForInteraction.appStateCallbackFunction = kony.licensevar.appStateCallbackFunction;

kony.license.maxWaitTimeToHandleMultipleNewSessions = 60;

kony.license.constants = {};
kony.license.constants.THIN_CLIENT = "thinclient";
kony.license.constants.LAUNCH_PARAMS = "launchparams";
kony.license.constants.REUSABLE_SESSION_ID = "reusable_session_id";
kony.license.constants.KEY_KONY_LICENSE_TIMEOUT = "konyLicenseTimeout";

/*
 *  Name      : kony.license.setLogging
 *  Purpose   : The API enables the logs for license.js. 
 *              It should be called via devloper who is intented to debug the license flow. It can be called in the app code or through developer tools.
 *  Scenarios : i) If kony.license.setLogging is invoked with boolean value true , the logs will be enabled for current launch and further launch of the app
 *              ii) If kony.license.setLogging is invoked with boolean value false , the logs will be disabled for current launch and further launch of the app
 */
kony.license.setLogging = function(boolValue){
    if(boolValue === true){
        kony.ds.save([true], "LicenseLoggingFlag");
    }else{
        kony.ds.save([false], "LicenseLoggingFlag");
    }
}

kony.license.log = function(msg){
    try{
        var logCondition = kony.ds.read("LicenseLoggingFlag");
    }catch(e){
        //This might get into exception in case of SPA due to a limitaion in implementation of FTR MADPSPA-394
    }
    if (logCondition != undefined && logCondition[0] != undefined && logCondition[0]!=null && logCondition[0]===true) {
        kony.print("[License] :"+msg);
    }
}

kony.license.isLicenseUrlAvailable = function() {
    return kony.licensevar.isLicenseUrlAvailable;
}

kony.license.setIsLicenseUrlAvailable = function(value) {
    kony.licensevar.isLicenseUrlAvailable = value;
}

kony.license.getSessionId = function() {
    return kony.licensevar.currentSessionId;
}

/*
  konyUserID encrypted and saved in datastore.Used in reporting params.
 */
var konyUserID = function () {

    var dataStorekeys = {};
    dataStorekeys.encryptedKonyuserId = "konyUserID_ENC";
    dataStorekeys.konyuserId = "konyUserID";
    var encryptionSalt = "konyUserID_ENC";
    var encryptionAlgo = "aes";

    /*
     *  Name      : get
     *  Purpose   : Returns array with one element encrypted userID.
     *              Removes old key "konyUserID" and add new key with encrypted userid to data store for migration from old version.
     *
     *  Scenarios : i) UserID must be encrypted and saved with key konyUserID_ENC.
     *              ii) For upagrade to 8.4 check if all both encrypted and non-encrpyted data are going to Mf
     */
    var getKonyUserID = function () {
        var userInfo = new Array();
        var userId = kony.ds.read(dataStorekeys.encryptedKonyuserId);
        if (userId === undefined || userId === null || userId[0] === undefined) {
            userId = kony.ds.read(dataStorekeys.konyuserId);
            if (userId != undefined && userId != null && userId[0] != undefined) {
                userId = userId[0];
                setKonyUserID(userId);
                kony.ds.remove(dataStorekeys.konyuserId);
            }
            else {
                return null;
            }

        }
        else {
            userId = decryptText(userId[0], encryptionSalt, encryptionAlgo);
        }

        userInfo.push(userId);
        return userInfo;
    };

    /*
     *  Name      : set
     *  Purpose   : Saves encrypted userID in datastore
     *
     *  Scenarios : i) UserID must be encrypted and saved with key konyUserID_ENC
     *              ii) For upagrade to 8.4 check if all both encrypted and non-encrpyted data are going to Mf
     */
    var setKonyUserID = function (userId) {
        if (userId == undefined || userId == null || typeof userId !== 'string') {
            return;
        }

        var userId = encryptText(userId, encryptionSalt, encryptionAlgo);
        var userInfo = new Array();
        userInfo.push(userId);
        kony.ds.save(userInfo, dataStorekeys.encryptedKonyuserId);
    };

    /**
     * Name     : generateSecureKeyFromText
     * Purpose  : Generates key for encryption.
     */
    function generateSecureKeyFromText(salt) {
        var secureKey = salt;

        if (salt != undefined || salt != null) {
            secureKey = kony.crypto.newKey("passphrase", 128, {
                passphrasetext: salt,
                subalgo: encryptionAlgo,
                passphrasehashalgo: "md5"
            });
        }
        return secureKey;
    }

    /**
     * Name     : encryptText
     * Purpose  : Encrypts text with the given salt and encryptionAlgo.
     *            Channel specific  behaviour:
     *            SPA     : Saving encrypted object to DS, as convertToRawbytes not supported in SPA
     */
    function encryptText(text, salt, encryptionAlgo) {
        var channel = kony.os.deviceInfo().name.toString().toLowerCase();
        var secureSalt = generateSecureKeyFromText([ salt ]);
        var encryptedText = kony.crypto.encrypt(encryptionAlgo, secureSalt, text, {});
        if(channel !== "thinclient") {
            encryptedText = kony.convertToBase64(encryptedText);
        }
        return encryptedText;
    }

    /**
     * Name     : decryptText
     * Purpose  : Decrypts text with the given salt and encryptionAlgo.
     */
    function decryptText(text, salt, decryptionAlgo) {
        var channel = kony.os.deviceInfo().name.toString().toLowerCase();
        var secureSalt = generateSecureKeyFromText([ salt ]);
        var rawBytes = text;
        if(channel !== "thinclient") {
            rawBytes = kony.convertToRawBytes(text);
        }

        var decryptText =kony.crypto.decrypt(decryptionAlgo, secureSalt, rawBytes, {});
        return decryptText;
    }

    return {"set": setKonyUserID, "get": getKonyUserID};
}

kony.license.registerChangeListener = function(changeHandler) {

    if (!changeHandler) {
        return;
    }
    // We give the initial values once
    var changes = {};
    var userId = konyUserID().get.call(this)
    changes["sessionId"] = kony.licensevar.currentSessionId;
    if (userId != undefined && userId[0] != undefined && userId[0]!=null) {
        changes["userId"] = userId[0];
    }

    if (!kony.license.isNullOrUndefined(kony.licensevar.currentSessionId)) {
        changeHandler(changes);
    }

    // Add to my listeners
    kony.licensevar.changeHandlers.push(changeHandler);
};

kony.license.notifyChangesToListeners = function() {
    for (var i = 0; i < kony.licensevar.changeHandlers.length; i++) {
        var changes = {};
        var userId = konyUserID().get.call(this);
        changes["sessionId"] = kony.licensevar.currentSessionId;
        if (userId != undefined && userId[0] != undefined && userId[0]!=null) {
            changes["userId"] = userId[0];
        }
        var changeHandler = kony.licensevar.changeHandlers[i];
        changeHandler(changes);
    }
};

/*
*  Name      : processDeferredNewSessions
*  Author    : None
*  Purpose   : Helper method to process deferred new sessions
*/

kony.license.processDeferredNewSessions = function () {
    kony.license.log("sending deferred launch date - "+kony.licensevar.currentSessionId);
    kony.licensevar.isISTNetworkCallProcessingInProgress = false;
    kony.licensevar.deferredNewSessionsCounter = 0;
    kony.license.pushKonySessionsToServer(true);
}

/**
 * This function takes a value as input to check for undefined or null
 * @param value
 * @returns {boolean}
 */
kony.license.isNullOrUndefined = function (value) {
    var isNullOrUndefined = false;
    if (value === undefined || value === null) {
        isNullOrUndefined = true;
    }
    return isNullOrUndefined;
}

/*
 *  Name      : kony.license.startLicenseService
 *  Author    : None
 *  Purpose   : Single global function which contains definitions of all required functions for session tracking.
 */
kony.license.startLicenseService = function() {
        "use strict";
        var deviceInfo = kony.os.deviceInfo();
        kony.license.log("startLicenseService deviceInfo " + JSON.stringify(deviceInfo));
        /*
         *  Name      : getLicenseUrl
         *  Author    : None
         *  Purpose   : Internal function to get the appropriate IST url for session calls
         */

        function getLicenseUrl() {
            var url = "";
            if (appConfig.isturlbase) {
                url = appConfig.isturlbase + "/IST";
            } else if (appConfig.secureurl) {
                url = getFromServerUrl(appConfig.secureurl, "IST");
            } else if (appConfig.url) {
                url = getFromServerUrl(appConfig.url, "IST");
            }
            return url;
        }

       
        /*
         *  Name      : getFromServerUrl
         *  Author    : None
         *  Purpose   : Helper method to form a proper url
         */

        function getFromServerUrl(url, path) {
            if (!url) {
                return null;
            }
            // ServerURL for non-mf has /mwservlet appended after the context path.
            // We need to remove it to get the base server url
            kony.license.log("Entering into getfromserverurl when IST-base url is not defined");
            if (deviceInfo.name === "thinclient") {
                url = url.replace(/mwservlet\/*$/i, "");
                return url + path;
            } else {
                var exactSubString = url.match(/mwservlet/i);
                var newUrl = null;
                if (exactSubString) {
                    var exactSubStringLength = "mwservlet".length;
                    var lastSubStringIndex = url.lastIndexOf(exactSubString);
                    var subString = url.slice(0, lastSubStringIndex);
                    var index = (lastSubStringIndex + exactSubStringLength);
                    var subString2 = url.slice(index, url.length);
                    var has = /[a-zA-Z0-9]/.test(subString2);
                    if (!has) {
                        newUrl = subString;
                    } else {
                        newUrl = url;
                    }
                } else {
                    newUrl = url;
                }
                return newUrl + path;
            }
        }

        function getApplicationType(name) {
            if (name === "thinclient") {
                return "spa";
            }
            var appMode = kony.application.getApplicationMode();
            if (appMode === constants.APPLICATION_MODE_NATIVE) {
                return "native";
            } else if (appMode === constants.APPLICATION_MODE_HYBRID) {
                return "hybrid";
            } else if (appMode === constants.APPLICATION_MODE_WRAPPER) {
                return "mixedmode";
            } else {
                return "";
            }
        }

        /*
         *  Name       : kony.setUserID
         *  Author     : None
         *  Purpose    : Stores the userID in device local, once set.
         *  Scenarios :  i) If kony.setUserID api is invoked by the developer, the userId set won't be overriden regardless 
         *                   of any number of logins.
         *               ii) If kony.setUserID is called from login flow, then the userId of login will be set and will 
         *                    be overriden for every subsequent login calls and direct invocation of kony.setUserID.
         *               iii) kony.setUserID api is invoked by the developer the userId for ex: 'X' will be set, again if kony.setUserID 
         *                    api is invoked with value ex : 'Y' then the previous value will be overriden and 
         *                    current userId will be set to 'Y'.
         */

        kony.setUserID = function(userId,fromLoginFlag) {
            /* fromLoginFlag is introduced to know whether the call is made from
               login flow or directly kony.setUserID api is invoked */
			if(fromLoginFlag == undefined || fromLoginFlag == null){
				fromLoginFlag = false;
			}

            var userIDflagGet = kony.ds.read("userIDFromLicenseFlag");
             /* If userIDflagGet is true ie. it is being set by invoking kony.setUserID directly and this function 
               is invoked from login flow, then no need to override, just return */
            if(userIDflagGet && (userIDflagGet[0] == "true") && fromLoginFlag) {
                return;
            }

            /* If the invocation is directly through calling api and not through login flow,
               set userIDFromLicenseFlag key to true so that it is not overriden by any other invocations from login flow*/

            /* userIDFromLicenseFlag is set to true only when kony.setUserID api is directly invoked by the developer */
            if(!fromLoginFlag) {
                var userIDflagSet = new Array;
                userIDflagSet.push("true");
                kony.ds.save(userIDflagSet,"userIDFromLicenseFlag");
            }

            /* sets userID in device local */
            konyUserID().set.call(this, userId);
            kony.license.notifyChangesToListeners();
        }

        kony.license.generateUUID = function() {
                var S4 = function() {
                    return (((1 + Math.random()) * 0x10000) | 0).toString(16).substring(1);
                };
                return (new Date().getTime() + '-' + S4() + '-' + S4() + '-' + S4());
        }
        /*
         *  Name      : kony.license.isCloud
         *  Author    : None
         *  Purpose   : Returns true if it is cloud enviroment, else returns false.
         */
        kony.license.isCloud = function() {
                //starting 6.0 the licensing approach is also applicable for On-Prem customers.Hence the license usage posting 
                //will be enabled for on-prem customers as well. So removing the check for the Kony Cloud URLs.

                var isLicenseEnabled = true;
                var LicenseCheck = kony.ds.read("LicenseDisableFlag");
                if (LicenseCheck && (LicenseCheck[0] === "true" || LicenseCheck === "true" ))  {
                    isLicenseEnabled = false;
                }
                if (kony.license.isLicenseUrlAvailable() === false) {
                    isLicenseEnabled = false;
                }
                return isLicenseEnabled;
        }

        /*
         *  Name      : kony.license.getCurrentDateTime
         *  Author    : None
         *  Purpose   : Returns current date and time details in required string format for service input.
         */
        kony.license.getCurrentDateTime = function() {
                kony.license.log("getCurrentDateTime..");
                var nowDate, month, formatDate;
                nowDate = new Date();
                month = nowDate.getUTCMonth() + 1;
                formatDate = (("00" + nowDate.getUTCFullYear()).slice(-4)) + "-" + (("00" + month).slice(-2)) + "-" + (("00" + nowDate.getUTCDate()).slice(-2)) + " " + (("00" + nowDate.getUTCHours()).slice(-2)) + ":" + (("00" + nowDate.getUTCMinutes()).slice(-2)) + ":" + (("00" + nowDate.getUTCSeconds()).slice(-2));
                return formatDate;
        }

        /*
         *  Name      : kony.license.appendLicenseTrackingKeys
         *  Author    : None
         *  Purpose   : Returns input object after appending the required tracking keys for provided input object.
         */

        kony.license.appendLicenseTrackingKeys = function(requestType,reportData) {
                kony.license.log("appendLicenseTrackingKeys deviceinfo ---> " + JSON.stringify(deviceInfo));
                var inputParams = {};
                 if (kony.license.isCloud() === true) {
                    inputParams.plat = deviceInfo.name;
                    if (typeof(kony.sdk) !== "undefined"){
                        inputParams.chnl = kony.sdk.getChannelType();
                        inputParams.did = kony.sdk.getDeviceId();
                        inputParams.plat = kony.sdk.getPlatformName();    
                    }
                    else{
                        //In absense of sdk [ MFSDK-2377 ],since for 7.0 viz we do not package SDK, so sdk namespace won't be available
                        //We should be okay with this hardcoding because in absence of SDK, IST call also doesn't make sense
                        //We are making this fix just for Backward compatibility of Viz Starter 7.0 Apps.
                        inputParams.chnl = "fpApp";
                        inputParams.did = "fp-"+kony.license.generateUUID();
                        inputParams.plat = "fp";
                    }
                    
                    inputParams.aid = appConfig.appId;
                    inputParams.aver = appConfig.appVersion;
                    inputParams.aname = appConfig.appName;
                    //adding mfaid, mfaname if konyref is available.
                    if (typeof konyRef !== "undefined" && konyRef != null && konyRef.mainRef) {
                        inputParams.mfaid = konyRef.mainRef.appId;
                        inputParams.mfbaseid = konyRef.mainRef.baseId;
                        inputParams.mfaname = konyRef.mainRef.name;
                    }
                    if (kony.application.getCurrentForm()) {
                        var fid = kony.application.getCurrentForm().id;
                        if (fid) {
                            inputParams.fid = fid;
                        }
                    }
                    inputParams.atype = getApplicationType(deviceInfo.name);
                    inputParams.os = deviceInfo.version;
                    inputParams.stype = "b2c";
                    inputParams.dm = deviceInfo.model;
                    inputParams.ua = kony.os.userAgent();
                    inputParams.sessiontype = kony.licensevar.isInteractive === true ? "I" : "NI";
                     var userId = konyUserID().get.call(this);
                    if (userId !== undefined && userId !== null && userId.length > 0) {
                        inputParams.kuid = userId[0];
                    } else {
                        inputParams.kuid = "";
                    }
                    if (requestType === "session") {
                        kony.license.checkAndCreateSession();
                        if(kony.licensevar.isISTNetworkCallProcessingInProgress === true || kony.licensevar.deferredNewSessionsCounter > 0){
                            //In case of first app laucn the kony.licensevar.deferredNewSessionsCounter would be 0 , so we don't need to cancel the uncommenced timer
                            if(kony.licensevar.deferredNewSessionsCounter > 0) {
                                try{
                                    kony.license.log("cancelling the previous timer, as in span of "
                                        +kony.license.maxWaitTimeToHandleMultipleNewSessions+ " seconds, a new IST was fired immediately");
                                    kony.timer.cancel("konySession"+(kony.licensevar.deferredNewSessionsCounter-1));
                                } catch(erObj) {
                                    kony.license.log("error - "+JSON.stringify(erObj)+",  while cancelling the deferred session timer" +
                                        " to send launch dates with timer id"+(kony.licensevar.deferredNewSessionsCounter-1));
                                }
                            }
                            kony.timer.schedule(("konySession"+(kony.licensevar.deferredNewSessionsCounter++)),
                                kony.license.processDeferredNewSessions, kony.license.maxWaitTimeToHandleMultipleNewSessions, false);
                                kony.license.log("another session is in progress , we will try again");
                            return {}; //returning empty konyReportingParams as we dont want another IST call while one IST call is in progress
                        }
                        
                        var offlineData = kony.license.getStoredSession();
                        inputParams.launchDates = offlineData;
                        kony.licensevar.isISTNetworkCallProcessingInProgress = true;
                        inputParams.svcid = "RegisterKonySession";
                        kony.license.log("---------->LaunchDates : " + inputParams.launchDates);
                    } else {
                        var uuid = kony.ds.read("konyUUID");
                        if (uuid !== undefined && uuid !== null && uuid.length > 0) {
                            inputParams.rsid = uuid[0];
                        } else {
                            inputParams.rsid = kony.license.generateUUID().toString();
                        }
                    }
                }
                kony.license.log("input params in appendLicenseTrackingKeys are " + JSON.stringify(inputParams));
                return inputParams;
            
        }

        /*
         *  Name      : kony.license.checkAndCreateSession
         *  Author    : None
         *  Purpose   : creates a new session (if session is not created).
         */
        kony.license.checkAndCreateSession = function() {
                kony.license.log("check and create session..");
                var uuid = kony.ds.read("konyUUID");
                if (uuid !== undefined && uuid !== null && uuid.length > 0) {
                   kony.licensevar.currentSessionId = uuid[0];
                } else {
                   kony.license.createSession();
                } 
        }

        kony.licensevar.sdkTimerCounter = 0;
        /**
         * This function prepares timer event for 4 hour delayed license call.
         * If another timer has to be scheduled, this function takes care of cancelling previous timer.
         */
        kony.license.prepare4HoursTimer = function () {
            kony.license.log("Entering prepare4HoursTimer, counter value-" + kony.licensevar.sdkTimerCounter);
            //In case of first app launch the kony.licensevar.sdkTimerCounter would be 0 , so we don't need to cancel the uncommenced timer
            if (kony.licensevar.sdkTimerCounter !== 0) {
                try {
                    var timerIdToCancel = kony.license.constants.KEY_KONY_LICENSE_TIMEOUT + (kony.licensevar.sdkTimerCounter - 1);
                    kony.timer.cancel(timerIdToCancel);
                } catch (erObj) {
                    kony.license.log("the error object while cancelling the timer is" + erObj);
                }
            }
        }

        /**
         * This function takes care of creating a new timer id and scheduling a new timed event
         * for new IST session to be created after 4 hours
         */
        kony.license.schedule4HoursTimer = function () {
            kony.license.log("Entering schedule4HoursTimer, counter value-" + kony.licensevar.sdkTimerCounter);
            var timerIdToSchedule = kony.license.constants.KEY_KONY_LICENSE_TIMEOUT + (kony.licensevar.sdkTimerCounter++);
            kony.timer.schedule(timerIdToSchedule, kony.license.sendNewIST, kony.license.timeoutValue, false);
        }

        /*
         *  Name      : kony.license.createSession
         *  Author    : None
         *  Purpose   : creates a new session (if session is not created) and sets the counter for 4hrs to call IST.
         */
        kony.license.createSession = function() {
            kony.license.prepare4HoursTimer();
            var uuid = new Array();
            kony.licensevar.currentSessionId = kony.license.generateUUID().toString();
            kony.licensevar.latestSessionCreationTimestamp = kony.license.getCurrentDateTime();
            uuid.push(kony.licensevar.currentSessionId);
            kony.ds.save(uuid, "konyUUID");
            kony.license.storeSession();
            kony.license.notifyChangesToListeners();
            kony.license.schedule4HoursTimer();
        }

        kony.license.storeSession = function(){
            var uuid = kony.licensevar.currentSessionId;
            var offlineData = kony.license.getStoredSession();
            if (offlineData === undefined || offlineData === null) {
                offlineData = new Array();
            }
            var currentSession = new Array();
            currentSession.push(uuid);
            currentSession.push(kony.licensevar.latestSessionCreationTimestamp);
            var sessionType = kony.licensevar.isInteractive === true ? "I" : "NI";
            currentSession.push(sessionType);

            if(offlineData.length === 0 || offlineData[(offlineData.length-1)][0] !== currentSession[0]){
                if(offlineData.length > 0 && kony.licensevar.deferredNewSessionsCounter > 0){
                    //we are dropping rapidly created sessions while already a network call is in progress. We will send only recent session.
                    offlineData.pop();
                }
                offlineData.push(currentSession);
            }else{
                kony.license.log("Ignoring duplicate session: "+JSON.stringify(currentSession));
                offlineData[offlineData.length - 1][2] = kony.licensevar.isInteractive.toString();
            }
            if(offlineData.length > kony.licensevar.maxSessionCountLimit){
                kony.license.log("Trimming to latest " + kony.licensevar.maxSessionCountLimit + " records, total records found - " + offlineData.length);
                var sliceValue = offlineData.length - kony.licensevar.maxSessionCountLimit;
                offlineData = offlineData.slice(sliceValue);
            }
            kony.ds.save(offlineData, "konyOfflineAccessData");
            kony.license.log("offlineData saved");
        };

        kony.license.getStoredSession = function(){
            return kony.ds.read("konyOfflineAccessData");
        };
            
        kony.license.sendNewIST = function() {
            kony.license.createSession();
            kony.license.pushKonySessionsToServer(true);           
        }

        /*
         *  Name      : kony.license.handleISTInvocation
         *  Author    : KH2293
         *  Purpose   : handles whether or not to invoke the IST call based on session type and other parameters
         */
        kony.license.handleISTInvocation = function(sessionURL, input, options) {
                var storedSessions = kony.license.getStoredSession();
                if((!kony.licensevar.isInteractive && storedSessions && (storedSessions.length >= kony.licensevar.maxDeferSessionCount)) || kony.licensevar.isInteractive) {
                   kony.license.invokeIST(sessionURL, input, kony.license.licenseUsageServiceSuccessCallback, kony.license.licenseUsageServiceFailureCallback, options);
                } else {
                   kony.licensevar.isISTNetworkCallProcessingInProgress = false;
                }
        }

        /*
         *  Name      : kony.license.licenseUsageServiceSuccessCallback
         *  Author    : KH2321
         *  Purpose   : handles the success behaviour of IST call and clear the offline stored failed sid
         */
        kony.license.licenseUsageServiceSuccessCallback = function (result){
                kony.licensevar.isISTNetworkCallProcessingInProgress = false;
                kony.license.log("launch dates sent successfully. result - "+JSON.stringify(result));
                //If launchDetails are successfully logged at server. Removing offline access details.
                kony.ds.remove("konyOfflineAccessData");
                kony.ds.remove("konyOfflineSessionsCount");
        }

        /*
         *  Name      : kony.license.licenseUsageServiceFailureCallback
         *  Author    : KH2321
         *  Purpose   : handles the error behaviour of IST call and stores failed sid
         */
        kony.license.licenseUsageServiceFailureCallback = function(result)
        {       
                kony.licensevar.isISTNetworkCallProcessingInProgress = false;
                kony.license.log("launch dates weren't sent successfully. result - "+JSON.stringify(result));
                //Storing offline access time details in case of network/service issues.
                var count, offlineCount;
                //Storing the offline sessions count.
                offlineCount = kony.ds.read("konyOfflineSessionsCount");
                if (offlineCount === undefined || offlineCount === null || offlineCount.length < 1) {
                    offlineCount = new Array();
                    offlineCount.push(1);
                } else if (!(offlineCount[0] >= 500)) {
                    //Stop updating the count if greater than 500
                    count = offlineCount[0] + 1;
                    offlineCount[0] = count;
                }
                kony.ds.save(offlineCount, "konyOfflineSessionsCount");
            }

        kony.license.captureKonyLicenseUsage = function(newLaunch) {
            // we are maintaining this for FP app made on earlier release for backward compatibility
            kony.license.pushKonySessionsToServer(newLaunch);
        }

        /*
         *  Name      : kony.license.pushKonySessionsToServer
         *  Author    : None
         *  Purpose   : Makes service call for session tracking if the app is built with cloud environment and last access is made 30 minutes ago.
         *              Sends required tracking keys for the service.
         */
        kony.license.pushKonySessionsToServer = function(newLaunch) {
                kony.license.log("capturing license information..");
                //Count session only if the time difference between last access and current access is more than 1 minute (30 minutes)
                var nowDate, lastDate, diff, sessionURL;
                var timeCheck = 1800000;
                var isNewSession = true;
                if (newLaunch === undefined || newLaunch === null) {
                    newLaunch = false;
                } else if (newLaunch !== true) {
                    newLaunch = false;
                }
                if (kony.license.isCloud() === false) {
                    kony.license.log("session tracking is turned off");
                    isNewSession = false;
                }
                if (kony.ds.read("konyLastAccessTime") !== undefined && kony.ds.read("konyLastAccessTime") !== null) {
                    nowDate = new Date();
                    lastDate = new Date(kony.ds.read("konyLastAccessTime")[0]);
                    diff = nowDate.getTime() - lastDate.getTime();
                    if (diff < timeCheck && newLaunch === false) {
                        isNewSession = false;
                    } else {
                        kony.ds.remove("konyLastAccessTime");
                    }
                }

                if (isNewSession === true) {
                    var input = {};
                    var options = {};
                    if (deviceInfo.name !== "thinclient") {
                        options["httpRequestOptions"] = [];
                        options["httpRequestOptions"]["timeoutIntervalForRequest"]=60;  
                    }
                    sessionURL = getLicenseUrl();
                    input.konyreportingparams = JSON.stringify(kony.license.appendLicenseTrackingKeys("session"),null);
                    options["disableIntegrity"] = true;
                    if(input.konyreportingparams !== "{}"){
                    	kony.license.handleISTInvocation(sessionURL, input, options);
                    }
                }
        }

        /*
         *  Name      : kony.license.backgroundTimeCapture
         *  Author    : None
         *  Purpose   : Stores the time stamp when app is sent to background.
         */
        kony.license.backgroundTimeCapture = function() {
                kony.license.log("app is going to background..");
                if (kony.license.isCloud() === true) {
                    var accessDetails = new Array();
                    accessDetails.push(new Date().toString());
                    kony.ds.save(accessDetails, "konyLastAccessTime");
                }
        }

        /*
         *  Name      : kony.license.clearLastAccess
         *  Author    : None
         *  Purpose   : Clears last access details on the termination of app.
         */
        kony.license.clearLastAccess = function() {
                kony.license.log("clear last access..");
                if (kony.license.isCloud() === true) {
                    kony.ds.remove("konyLastAccessTime");
                }
        }

        /*
         *  Name      : kony.license.setAppCallbacksOverride
         *  Author    : None
         *  Purpose   : Overrides the API setApplicationCallbacks. Prepends onforeground, onbackground and onappterminate events with required
         *              session tracking methods.
         */
        kony.license.setAppCallbacksOverride = function() {
                kony.license.log("overriding kony.application.setApplicationCallbacks..");
                var oldImplementation = kony.application.setApplicationCallbacks;

                function newImplementation(eventsDefinition) {
                    if (kony.license.isCloud() === true) {
                        if (eventsDefinition !== undefined && eventsDefinition !== null) {
                            if (eventsDefinition.onforeground !== undefined && eventsDefinition.onforeground !== null) {
                                var userForeFunction = eventsDefinition.onforeground;
                                var newForeFunction = function() {
                                    if(kony.licensevar.didAppWentInBackground === true){
                                        kony.license.pushKonySessionsToServer(false);
                                    }
                                    if (deviceInfo.name !== "thinclient " && typeof(kony.sync) !== "undefined") {
                                        kony.sync.isAppInBackground = false;
                                    }
                                    kony.licensevar.didAppWentInBackground = false;
                                    userForeFunction();
                                };
                                eventsDefinition.onforeground = newForeFunction;
                            }
                            if (eventsDefinition.onbackground !== undefined && eventsDefinition.onbackground !== null) {
                                var userBackFunction = eventsDefinition.onbackground;
                                var newBackFunction = function() {
                                    kony.licensevar.didAppWentInBackground = true;
                                    kony.license.backgroundTimeCapture();
                                    if (typeof(kony.sdk) !== "undefined" && typeof(kony.sdk.metric) !== "undefined") {
                                        kony.sdk.metric.saveInDS();
                                    }
                                    if (deviceInfo.name !== "thinclient " && typeof(kony.sync) !== "undefined") {
                                        kony.sync.isAppInBackground = true;
                                    }
                                    userBackFunction();
                                };
                                eventsDefinition.onbackground = newBackFunction;
                            }
                            if (eventsDefinition.onappterminate !== undefined && eventsDefinition.onappterminate !== null) {
                                var userTerminateFunction = eventsDefinition.onappterminate;
                                var newTerminateFunction = function() {
                                    kony.license.clearLastAccess();
                                    if (typeof(kony.sdk) !== "undefined" && typeof(kony.sdk.metric) !== "undefined") {
                                        kony.sdk.metric.saveInDS();
                                    }
                                    userTerminateFunction();
                                };
                                eventsDefinition.onappterminate = newTerminateFunction;
                            }
                        }
                    }
                    return oldImplementation(eventsDefinition);
                }
                kony.application.setApplicationCallbacks = newImplementation;
                if (deviceInfo.name !== "thinclient ") {
                    var callbackEvents = {
                        onforeground: function() {},
                        onbackground: function() {},
                        onappterminate: function() {}
                    };

                    kony.application.setApplicationCallbacks(callbackEvents);
                }
        }

        /*
         *  Name      : kony.license.invokeServiceAsyncOverride
         *  Author    : None
         *  Purpose   : Overrides the API invokeServiceAsync. Appends tracking keys to the input param.
         */
        kony.license.invokeServiceAsyncOverride = function() {
                kony.license.log("overriding kony.net.invokeServiceAsync..");
                var oldImplementation = kony.net.invokeServiceAsync;

                function newImplementation(url, input, callback, config, requestType, reportData) {
                    if (kony.license.isCloud() === true) {
                        if (input === undefined || input === null) {
                            input = {};
                        }
                        if (input !== undefined && input !== null && !isGetRequest(input)) {
                            if (requestType !== undefined && requestType !== null) {
                                input.konyreportingparams = processKonyReportingParams(input.konyreportingparams, requestType, reportData);
                            } else {
                                input.konyreportingparams = processKonyReportingParams(input.konyreportingparams, null, null);
                            }
                        }
                    }
                    return oldImplementation(url, input, callback, config);

                    function processKonyReportingParams(params, requestType, reportData) {
                        var params2 = kony.license.appendLicenseTrackingKeys(requestType, reportData);
                        if (!params) {
                            return JSON.stringify(params2);
                        } else {
                            try {
                                if (typeof(params) === "string") {
                                    params = JSON.parse(params);
                                }
                                for (var key in params2) {
                                    if (typeof(params[key]) === "undefined") {
                                        params[key] = params2[key];
                                    }
                                }
                                return JSON.stringify(params);
                            } catch (e) {
                                kony.license.log("unable to parse params " + params);
                                return JSON.stringify(params2);
                            }


                        }
                    }

                    function isGetRequest(inputParams) {
                        if (inputParams && inputParams.httpconfig && inputParams.httpconfig.method && inputParams.httpconfig.method === "get") {
                            return true;
                        }
                        return false;
                    }
                }
                kony.net.invokeServiceAsync = newImplementation;
        }

        /*
         *  Name      : kony.license.invokeServiceSyncOverride
         *  Author    : None
         *  Purpose   : Overrides the API invokeServiceSync. Appends tracking keys to the input param.
         */
        kony.license.invokeServiceSyncOverride = function() {
                kony.license.log("overriding kony.net.invokeServiceSync..");
                var oldImplementation = kony.net.invokeServiceSync;

                function newImplementation(url, input, isblocking) {
                    if (kony.license.isCloud() === true) {
                        if (input === undefined || input === null) {
                            input = {};
                        }
                        if (input !== undefined && input !== null) {
                            input.konyreportingparams = JSON.stringify(kony.license.appendLicenseTrackingKeys(null));
                        }
                    }
                    return oldImplementation(url, input, isblocking);
                }
                kony.net.invokeServiceSync = newImplementation;
        }

        //The below function gets defined only in thinclient channels due to APPPLT-7291
        if (kony.os.deviceInfo().name === kony.license.constants.THIN_CLIENT) {
            /**
             * This function reads post app init argument and tries to find
             * for availability of code in params for recovery against last session.
             * In case of non-availability , this function cleans any stored resuable session
             * @param eventObject
             * @returns {boolean}
             */
            kony.license.doesLaunchParamsHaveCode = function (eventObject) {
                kony.license.log("Entering doesLaunchParamsHaveCode");
                var isCodePresentInQueryParams = !kony.license.isNullOrUndefined(eventObject)
                                                 && !kony.license.isNullOrUndefined(eventObject[kony.license.constants.LAUNCH_PARAMS])
                                                 && !kony.license.isNullOrUndefined(eventObject[kony.license.constants.LAUNCH_PARAMS].code);

                if (!isCodePresentInQueryParams) {
                    kony.license.log("code was not present in launch params");
                    kony.license.removeReusableSession();
                }

                kony.license.log("code was present in launch params");
                return isCodePresentInQueryParams;
            }

            /**
             * This function saves current session to be used in next continued app launch for login
             */
            kony.license.saveCurrentSessionForReuse = function () {
                kony.license.log("Entering saveCurrentSessionForReuse");
                var singleStoredSession = [kony.licensevar.currentSessionId];
                kony.ds.save(singleStoredSession, kony.license.constants.REUSABLE_SESSION_ID);
            }

            /**
             * This function does following function
             * 1.consume previously saved session in last launch & notify all listeners with this session
             * always cleans any stored resuable session
             * @returns {boolean} returns true if session was restored successfully
             */
            kony.license.reuseLastSession = function () {
                kony.license.log("Entering reuseLastSession");
                var wasAbleToReuseLastSession = false;
                var singleStoredSession = kony.ds.read(kony.license.constants.REUSABLE_SESSION_ID);

                if (!kony.license.isNullOrUndefined(singleStoredSession)
                    && !kony.license.isNullOrUndefined(singleStoredSession[0]))
                {
                    kony.license.log("successfully reused session");
                    kony.license.prepare4HoursTimer();
                    kony.licensevar.currentSessionId = singleStoredSession[0];
                    kony.license.notifyChangesToListeners();
                    wasAbleToReuseLastSession = true;
                    kony.license.schedule4HoursTimer();
                }

                kony.license.removeReusableSession();
                return wasAbleToReuseLastSession;
            }

            /**
             * This function removes single stored session from storage for clean up
             */
            kony.license.removeReusableSession = function (){
                kony.license.log("removing reusable session");
                kony.ds.remove(kony.license.constants.REUSABLE_SESSION_ID);
            }
        }


        /**
         * This function primarily sets session id & capture app launch event
         * @param postAppInitArgument
         */
        kony.license.prepareLicenseSessionOnPostAppInit = function (postAppInitArgument) {
            kony.license.log("Entering prepareLicenseSessionOnPostAppInit");
            /* MFSDK-4266 Saving app launch key-value to detect
            application launch to reset locks on application reload
            */
            kony.ds.save([true], kony.licensevar.appLaunch);

            //only for thinclient channels e.g SPA,DW
            if (kony.os.deviceInfo().name === kony.license.constants.THIN_CLIENT
                && kony.license.doesLaunchParamsHaveCode(postAppInitArgument))
            {
                var wasAbleToReuseLastSession =  kony.license.reuseLastSession();
                if(wasAbleToReuseLastSession){
                    kony.license.log("last session reused inside postappinit");
                    return;
                }
            }

            //sdk will not create session any more since we have to avoid creating session when SPA app is relaunched for single window login
            //license will be self sufficient to create session on post-app init from now on
            kony.license.log("creating new session inside postappinit");
            kony.license.createSession();
            
            kony.license.pushKonySessionsToServer(true);
        }

        /*
         *  Name      : kony.license.setAppInitializationEventsOverride
         *  Author    : None
         *  Purpose   : Overrides the API setApplicationInitializationEvents. Prepends postappinit event with required session tracking method.
         *              If postappinit is undefiend, sets postappinit with required session tracking method.
         */
        kony.license.setAppInitializationEventsOverride = function() {
                var oldImplementation = kony.application.setApplicationInitializationEvents;
                function newImplementation(eventsDefinition) {
                    kony.license.log("setApplicationInitializationEvents events " + eventsDefinition);
                    kony.licensevar.isPostAppInitCalled = true;
                    if (kony.license.isCloud() === true) {
                        if (eventsDefinition !== undefined && eventsDefinition !== null) {
                            var userFunction = eventsDefinition.postappinit;
                            if (!kony.license.isNullOrUndefined(userFunction)) {
                                var wrapperPostAppInit = function (postAppInitArgument) {
                                    kony.license.prepareLicenseSessionOnPostAppInit(postAppInitArgument);
                                    var userForm = userFunction.apply(this,arguments);
                                    if (userForm !== undefined || userForm !== null) {
                                        return userForm;
                                    }
                                };
                                eventsDefinition.postappinit = wrapperPostAppInit;
                            } else {
                                eventsDefinition.postappinit = kony.license.prepareLicenseSessionOnPostAppInit;
                            }
                            
                            /*The below function gets defined only in thinclient channels due to APPPLT-7291
                            Below function defines appServiceAsync function, the license.js will be able to know
                            whether app was launched with code as launch params, and will ask sdk to do login.
                            The sdk will perform login and send result to license.
                            License would append login result in appServiceAsync eventObject
                             */
                            if (kony.os.deviceInfo().name === kony.license.constants.THIN_CLIENT) {
                                function doLoginWithCode(appServiceEventObjectArgument, doneCallback) {
                                    kony.license.log("Entering doLoginWithCode");
                                    if (!kony.license.doesLaunchParamsHaveCode(appServiceEventObjectArgument)) {
                                        kony.license.log("no code launch param found, skipping login for same window login");
                                        doneCallback();
                                    } else {
                                        kony.license.log("code launch param found, requesting sdk to complete login");
                                        var code = appServiceEventObjectArgument[kony.license.constants.LAUNCH_PARAMS].code;
                                        kony.sdk.completeSingleWindowLogin(code, doneCallback);
                                    }
                                }

                                var appServiceAsyncFunction = function (appServiceEventObjectArgument, callback) {
                                    kony.license.log("Entering appServiceAsyncFunction");
                                    doLoginWithCode(appServiceEventObjectArgument, function (loginResponse) {
                                        if (!kony.license.isNullOrUndefined(loginResponse)) {
                                            kony.license.log("appending loginResponse in eventObject");
                                            appServiceEventObjectArgument.loginResponse = loginResponse;
                                        }

                                        kony.license.log("Exiting appServiceAsyncFunction");
                                        callback(appServiceEventObjectArgument);
                                    })
                                };
                                
                                eventsDefinition.appServiceAsync = appServiceAsyncFunction;
                            }
                        }
                    }
                    return oldImplementation(eventsDefinition);
                }
                kony.application.setApplicationInitializationEvents = newImplementation;
        }
        /*
         *  Name      : kony.license.apiOverride
         *  Author    : None
         *  Purpose   : Sets initial application callbacks. Calls the API overriding functions
         */
       kony.license.apiOverride =function() {
                kony.license.log("Entering apiOverride..");
                //Overriding APIs
                if (deviceInfo.name !== "thinclient") {
                    kony.license.setAppCallbacksOverride();
                } else {
                    //in SPA/DW kony.application.addApplicationCallbacks function is a stub.
                    kony.licensevar.isInteractive = true;
                }
                kony.license.invokeServiceAsyncOverride();
                kony.license.invokeServiceSyncOverride();
                kony.license.setAppInitializationEventsOverride();
        }

        kony.license.apiOverride();
        kony.application.addApplicationCallbacks(kony.licensevar.callbacksObjList);
        if (deviceInfo.name !== "thinclient") {
            Object.seal(kony.license);
            Object.freeze(kony.license);
        }
        kony.license.log("license loading completed");
}

//License Network Layer
kony.license.invokeIST = function(url, params, successCallback, failureCallback, options) {
    if(typeof(url)==="undefined" || url === undefined || url === null || url === ""){
        failureCallback("license url can't be null or empty");
        return;
    }

    var headers = {"Content-Type":"application/x-www-form-urlencoded"};
    //kony.sdk can be undefined in case where sdk is absent in project eg.(fp apps of 7.x versions) or unable to load
    if(kony.hasOwnProperty("sdk") && kony.sdk.getCurrentInstance && kony.sdk.getCurrentInstance()){
        url = kony.sdk.getCurrentInstance().appendGlobalParams(url, headers, params);
    }

    var httpRequest = new kony.net.HttpRequest();
    if(options && options["httpRequestOptions"] && options["httpRequestOptions"] instanceof Object && options["httpRequestOptions"]["timeoutIntervalForRequest"]){
        httpRequest.timeout = options["httpRequestOptions"]["timeoutIntervalForRequest"] * 1000;
    }
    httpRequest.open("POST", url);

    function localRequestCallback(result) {
        var readyState = Number(httpRequest.readyState.toString());
        var status = Number(httpRequest.status.toString());
        kony.license.log("localRequestCallback in state :"+readyState+" with status :"+status);
        var response = null;
        if (readyState === 4) {
            var isFailure = true;
            if ((status >= 200 && status < 300)|| status === 504) {
                if (status!== 504){
                    try{
                        response = JSON.parse(JSON.stringify(httpRequest.response)); //copying response
                        if(typeof(response) === "string"){
                            response = JSON.parse(response);	
                        }
                        response.url = url;
                        if(response && (typeof(response.opstatus) === "undefined" || response.opstatus == 0)){
                            isFailure = false;
                        }
                    } catch (e){
                        kony.license.log("error while extracting response :"+e);
                    } 
                } else{
                    isFailure = false;
                }
            }
            if( isFailure === true){
                var errorResponse = {
                    "error": "failure in sending IST call with status as :" + status,
                    "url" : url
                };
                failureCallback(errorResponse);
            } else{
                successCallback(response);
            }
        }
    }

    //setting params
    paramsTable = new kony.net.FormData();
    for (var key in params) {
        if (typeof(params[key]) != "undefined") {
            if (typeof(params[key]) !== "string") {
                params[key] = JSON.stringify(params[key]);
            }
            paramsTable.append((key), (params[key]));
        }
    }
    kony.license.log("paramsTable formed is "+paramsTable.toString());
    //setting headers
    for (var headerKey in headers ) {
        if(headers.hasOwnProperty(headerKey)){
            httpRequest.setRequestHeader(headerKey , headers[headerKey]);
        }
    }   
    //setting listener
    httpRequest.onReadyStateChange = localRequestCallback;
    //disabling integrity as integrity is never supported in IST,
    //for consistency we should also not send req headers containing integrity headers even though the headers will be ignored by MW
    //This should have been done as a part of MFSDK-4957
    if (httpRequest.hasOwnProperty("disableIntegrityCheck")) {
        httpRequest.disableIntegrityCheck = true;
    }
    //sending IST
    httpRequest.send(paramsTable);
    
}


function cloudSessionCallback() {
    kony.license.log("Cloud session timed out.");
    kony.ds.remove("konyLastAccessTime");
    kony.ds.remove("konyUUID");
    kony.ds.remove("konyCustomReportData");
    kony.ds.remove("konyOfflineAccessData");
    kony.license.pushKonySessionsToServer();
    kony.cloud.appevents.unregisterforidletimeout();
    kony.cloud.appevents.registerforidletimeout(30, cloudSessionCallback);
}

kony.license.startLicenseService(); /*
  * kony-sdk-ide Version 202305.0.0
  */
 /**
  * Kony namespace
  * @namespace kony
  */
 if (typeof(kony) === "undefined") {
   kony = {};
 }
 /**
  * Constructor for creating the kony client instance.
  * @class
  * @classdesc kony Class
  * @memberof kony
  */
 kony.sdk = function() {
   var currentObj = this;
   KNYMobileFabric = this;
   this.mainRef = {};
   var clientParams = {};
   this.tokens = {};
   this.currentClaimToken = null;
   this.globalRequestParams = {
     "headers": {},
     "queryparams": {},
     "bodyparams": {}
   };
   var userId = "";
   var integrityCustomSecurityKey = null;
   this.reportingheaders_allowed = false;
   this.enableWithCredentialsGloabally = false;
   if (kony.sdk.getSdkType() === kony.sdk.constants.SDK_TYPE_IDE && typeof(kony.setUserID) === 'function') {
     var userIDflagGet = kony.ds.read("userIDFromLicenseFlag");
     if (kony.sdk.isNullOrUndefined(userIDflagGet)) {
       var userIDflagSet = [];
       userIDflagSet.push("false");
       kony.ds.save(userIDflagSet, "userIDFromLicenseFlag");
     }
   }
   if (kony.internal && kony.internal.sdk && kony.internal.sdk.Services) {
     this.internalSdkObject = new kony.internal.sdk.Services();
   }
   this.getUserId = function() {
     return userId;
   };
   this.setCurrentUserId = function(newUserID) {
     userId = newUserID;
   };
   this.getSessionId = function() {
     if (!konyRef.sessionId) {
       var sessionId = kony.ds.read(kony.sdk.constants.KONYUUID);
       if (sessionId) {
         konyRef.sessionId = sessionId[0];
       } else {
         kony.sdk.logsdk.error("Session id is not available");
         konyRef.sessionId = "";
       }
     }
     return konyRef.sessionId;
   };
   this.setSessionId = function(newSessionId) {
     konyRef.sessionId = newSessionId;
   };
   this.setClientParams = function(clientParamsMap) {
     clientParams = clientParamsMap;
   };
   this.getClientParams = function() {
     return clientParams;
   };
   this.globalRequestParamType = {
     headers: "headers",
     queryParams: "queryparams",
     bodyParams: "bodyparams"
   };
   this.getGlobalRequestParams = function(paramType) {
     kony.sdk.logsdk.trace("Entering getGlobalRequestParams");
     if (kony.sdk.isNullOrUndefined(paramType)) {
       return currentObj.globalRequestParams;
     } else if (paramType === currentObj.globalRequestParamType.headers) {
       return currentObj.globalRequestParams.headers;
     } else if (paramType === currentObj.globalRequestParamType.queryParams) {
       return currentObj.globalRequestParams.queryparams;
     } else if (paramType === currentObj.globalRequestParamType.bodyParams) {
       return currentObj.globalRequestParams.bodyparams;
     }
   };
   this.setGlobalRequestParam = function(paramName, paramValue, paramType) {
     kony.sdk.logsdk.trace("Entering setGlobalRequestParam");
     if (typeof(paramName) === 'string' && typeof(paramValue) === 'string' && typeof(paramType) === 'string') {
       if (paramType === currentObj.globalRequestParamType.headers) {
         currentObj.globalRequestParams.headers[paramName] = paramValue;
       } else if (paramType === currentObj.globalRequestParamType.queryParams) {
         currentObj.globalRequestParams.queryparams[paramName] = paramValue;
       } else if (paramType === currentObj.globalRequestParamType.bodyParams) {
         currentObj.globalRequestParams.bodyparams[paramName] = paramValue;
       }
       if (!(kony.sdk.getAType() === kony.sdk.constants.SDK_ATYPE_SPA || kony.sdk.getAType() === "watch")) {
         //invoke NFI only for android,ios and FFI for windows and logger
         kony.sdk.sdkCommons.setGlobalRequestParam(paramName, paramValue, paramType);
         kony.logger.setGlobalRequestParam(paramName, paramValue, paramType);
       }
     }
   };
   this.removeGlobalRequestParam = function(paramName, paramType) {
     kony.sdk.logsdk.trace("Entering removeGlobalRequestParam");
     if (typeof(paramName) === 'string' && typeof(paramType) === 'string') {
       if (paramType === currentObj.globalRequestParamType.headers && !kony.sdk.isNullOrUndefined(currentObj.globalRequestParams.headers[paramName])) {
         delete currentObj.globalRequestParams.headers[paramName];
       } else if (paramType === currentObj.globalRequestParamType.queryParams && !kony.sdk.isNullOrUndefined(currentObj.globalRequestParams.queryparams[paramName])) {
         delete currentObj.globalRequestParams.queryparams[paramName];
       } else if (paramType === currentObj.globalRequestParamType.bodyParams && !kony.sdk.isNullOrUndefined(currentObj.globalRequestParams.bodyparams[paramName])) {
         delete currentObj.globalRequestParams.bodyparams[paramName];
       }
       if (!(kony.sdk.getAType() === kony.sdk.constants.SDK_ATYPE_SPA || kony.sdk.getAType() === "watch")) {
         //invoke NFI only for android,ios and FFI for windows and logger
         kony.sdk.sdkCommons.removeGlobalRequestParam(paramName, paramType);
         kony.logger.removeGlobalRequestParam(paramName, paramType);
       }
     }
   };
   this.resetGlobalRequestParams = function() {
     kony.sdk.logsdk.trace("Entering resetGlobalRequestParams");
     currentObj.globalRequestParams = {
       "headers": {},
       "queryparams": {},
       "bodyparams": {}
     };
     if (!(kony.sdk.getAType() === kony.sdk.constants.SDK_ATYPE_SPA || kony.sdk.getAType() === "watch")) {
       //invoke NFI only for android,ios and FFI for windows and logger
       kony.sdk.sdkCommons.resetGlobalRequestParams();
       kony.logger.resetGlobalRequestParams();
     }
   };
   this.appendGlobalHeaders = function(headers) {
     kony.sdk.logsdk.perf("Executing appendGlobalHeaders");
     var globalHeaders = currentObj.getGlobalRequestParams(currentObj.globalRequestParamType.headers);
     if (!kony.sdk.isNullOrUndefined(globalHeaders)) {
       if (kony.sdk.isNullOrUndefined(headers)) {
         headers = {};
       }
       for (var obj in globalHeaders) {
         if (kony.sdk.isNullOrUndefined(headers[obj])) {
           headers[obj] = globalHeaders[obj];
         }
       }
     }
     kony.sdk.logsdk.perf("Executing Finished appendGlobalHeaders");
   };
   this.appendGlobalBodyParams = function(params) {
     kony.sdk.logsdk.perf("Executing appendGlobalBodyParams");
     var globalBodyParams = currentObj.getGlobalRequestParams(currentObj.globalRequestParamType.bodyParams);
     if (!kony.sdk.isNullOrUndefined(globalBodyParams)) {
       if (kony.sdk.isNullOrUndefined(params)) {
         params = {};
       }
       for (var obj in globalBodyParams) {
         if (kony.sdk.isNullOrUndefined(params[obj])) {
           params[obj] = globalBodyParams[obj];
         }
       }
     }
     kony.sdk.logsdk.perf("Executing Finished appendGlobalBodyParams");
   };
   this.appendGlobalQueryParams = function(url) {
     kony.sdk.logsdk.perf("Executing appendGlobalQueryParams");
     var globalQueryParams = currentObj.getGlobalRequestParams(currentObj.globalRequestParamType.queryParams);
     if (!kony.sdk.isNullOrUndefined(globalQueryParams) && Object.keys(globalQueryParams).length !== 0) {
       if (url.indexOf("?") < 0) {
         url = url + "?" + kony.sdk.util.objectToQueryParams(globalQueryParams);
       } else {
         url = url + "&" + kony.sdk.util.objectToQueryParams(globalQueryParams);
       }
     }
     kony.sdk.logsdk.perf("Executing Finished appendGlobalQueryParams");
     return url;
   };
   this.appendGlobalParams = function(url, headers, params) {
     kony.sdk.logsdk.perf("Executing appendGlobalParams");
     currentObj.appendGlobalHeaders(headers);
     currentObj.appendGlobalBodyParams(params);
     var result = currentObj.appendGlobalQueryParams(url);
     kony.sdk.logsdk.perf("Executing Finished appendGlobalParams");
     return result;
   };
   this.setAppSecurityKey = function(customSalt) {
     kony.sdk.logsdk.perf("Executing setAppSecurityKey");
     if (!kony.sdk.isNullOrUndefined(customSalt) && typeof customSalt === 'string') {
       integrityCustomSecurityKey = customSalt;
       kony.sdk.logsdk.perf("Executing Finished setAppSecurityKey");
       if (konyRef.mainRef.integrityKey === true) {
         setIntegrityParamsHandler();
       }
       return true;
     } else {
       var errorObj = {};
       errorObj[kony.sdk.constants.MF_ERROR_CODE] = kony.sdk.errorcodes.invalid_security_key;
       errorObj[kony.sdk.constants.MF_ERROR_MSG] = kony.sdk.errormessages.invalid_security_key;
       kony.sdk.logsdk.error(kony.sdk.errormessages.invalid_security_key);
       kony.sdk.logsdk.perf("Executing Finished setAppSecurityKey");
       return errorObj;
     }
   };
   this.getAppSecurityKey = function() {
     return integrityCustomSecurityKey;
   };
 };
 kony.mbaas = kony.sdk;
 kony.sdk.isDebugEnabled = true;
 kony.sdk.isInitialized = false;
 kony.sdk.currentInstance = null;
 kony.sdk.isLicenseUrlAvailable = true;
 kony.sdk.isOAuthLogoutInProgress = false;
 kony.sdk.constants = kony.sdk.constants || {};
 kony.sdk.version = "202305.0.0";
 kony.sdk.logsdk = new konySdkLogger();
 kony.sdk.syncService = null;
 kony.sdk.dataStore = kony.sdk.dataStore || new konyDataStore();
 kony.sdk.skipAnonymousCall = false;
 kony.sdk.convertPassthroughResponseToJson = false;
 kony.sdk.getDefaultInstance = function() {
   return kony.sdk.currentInstance;
 };
 // This is to be deprecated with getDefaultInstance
 kony.sdk.getCurrentInstance = function() {
   return kony.sdk.currentInstance;
 };
 // This is to be set by client to skip anonymous login calls.
 kony.sdk.skipAnonymousLoginCall = function(state) {
   // If enabled then client can only access public integration services.
   // If disabled then client can access protected integration services.
   // To access private client needs to get authenticated by an identity service.
   kony.sdk.skipAnonymousCall = state;
 };
 kony.sdk.claimsRefresh = function(callback, failureCallback) {
   kony.sdk.logsdk.trace("Entering kony.sdk.claimsRefresh");
   var konyRef = kony.sdk.getCurrentInstance();
   var networkProvider = new konyNetworkProvider();
   var loginWithAnonymousProvider = function(successCallback, failureCallback) {
     var identityObject = konyRef.getIdentityService("$anonymousProvider");
     identityObject.login(null, function(res) {
       successCallback();
     }, function(res) {
       kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getAuthErrObj(res));
     });
   };
   if (konyRef.currentClaimToken === null) {
     kony.sdk.logsdk.warn("claims Token is Unavialable");
     if (konyRef.isAnonymousProvider) {
       loginWithAnonymousProvider(callback, failureCallback);
     } else {
       kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getNullClaimsTokenErrObj());
     }
   } else if (kony.sdk.isClaimsTokenExpired(konyRef.claimTokenExpiry)) {
     if (konyRef.isAnonymousProvider) {
       loginWithAnonymousProvider(callback, failureCallback);
     } else {
       kony.sdk.fetchClaimsTokenFromServer(false, callback, failureCallback);
     }
   } else {
     callback();
   }
 };
 kony.sdk.isClaimsTokenExpired = function(claimsTokenExpVal) {
   // [MFSDK-4863] - Considering a delay of 60 Secs while checking the expiry of claims token
   // hence, deducting 60 secs from the currentTimeMillis while comparing expiry time
   var DELAY_IN_MILLIS = 60000;
   if (!kony.sdk.isNullOrUndefined(claimsTokenExpVal) && (Date.now() + DELAY_IN_MILLIS) > claimsTokenExpVal) {
     return true;
   } else {
     return false;
   }
 }
 kony.sdk.claimsAndProviderTokenRefresh = function(callback, failureCallback) {
   kony.sdk.logsdk.trace("Entering kony.sdk.claimsAndProviderTokenRefresh");
   kony.sdk.fetchClaimsTokenFromServer(true, callback, failureCallback);
 };
 /**
  * Checks for the etag in the response data. Gets the service doc & caches it if etag is updated.
  * @param data{JSON} response data from claimsRefresh or login.
  * @param callback{function} callback to be invoked.
  */
 function getLatestServiceDocIfAvailable(data, callback) {
   // Disabling this for phonegap and plain-js as there is no concept of auto-init there
   // Also, If konyRef.mainRef.config is not defined which means init is called again or konyRef is in invalid state.
   // Hence skipping service doc call.
   if (kony.sdk.getSdkType() !== kony.sdk.constants.SDK_TYPE_IDE || kony.sdk.isNullOrUndefined(konyRef.mainRef.config)) {
     kony.sdk.verifyAndCallClosure(callback);
     return;
   }
   var currentETag = konyRef.mainRef.config.service_doc_etag;
   var serverETag = data.service_doc_etag;
   if (!kony.sdk.isNullOrUndefined(serverETag) && (kony.sdk.isNullOrUndefined(currentETag) || currentETag != serverETag)) {
     kony.sdk.logsdk.info("Service doc update found.");
     var networkProvider = new konyNetworkProvider();
     var _serviceUrl = stripTrailingCharacter(konyRef.rec.url, "/") + "/appconfig";
     var headers = {};
     headers[kony.sdk.constants.APP_KEY_HEADER] = konyRef.mainRef.appKey;
     headers[kony.sdk.constants.APP_SECRET_HEADER] = konyRef.mainRef.appSecret;
     headers["X-HTTP-Method-Override"] = "GET";
     populateHeaderWithFabricAppVersion(headers);
     kony.sdk.logsdk.perf("Executing network call for getLatestServiceDocIfAvailable");
     //For /appConfig call, X-Kony-Integrity header should be set always
     setIntegrityParams.call(konyRef);
     var options = {};
     options[kony.sdk.constants.IGNORE_MESSAGE_INTEGRITY] = true;
     //sending extra an option "isAppConfigCall" for setting integrity for appConfig calls
     options[kony.sdk.constants.IS_APP_CONFIG_CALL] = true;
     networkProvider.post(_serviceUrl, null, headers, function(successResponse) {
       kony.sdk.util.checkAndUpdateIntegrityKey(successResponse);
       //Saving latest metadata(appKey, appSecret and serviceDoc) in DS
       //for next app launch
       kony.sdk.util.saveMetadatainDs(konyRef.mainRef.appKey, konyRef.mainRef.appSecret, successResponse);
       kony.sdk.logsdk.perf("Executing Finished network call for getLatestServiceDocIfAvailable");
       kony.sdk.verifyAndCallClosure(callback);
     }, function(failureResponse) {
       kony.sdk.logsdk.perf("Executing Finished network call for getLatestServiceDocIfAvailable");
       kony.sdk.logsdk.error("Refresh of serviceDoc failed:" + JSON.stringify(failureResponse));
       kony.sdk.verifyAndCallClosure(callback);
     }, null, options);
   } else {
     kony.sdk.verifyAndCallClosure(callback);
   }
 }
 kony.sdk.fetchClaimsTokenFromServer = function(isBackendTokenRefreshRequired, callback, failureCallback) {
   kony.sdk.logsdk.perf("Executing kony.sdk.fetchClaimsTokenFromServer");
   var konyRef = kony.sdk.getCurrentInstance();
   var networkProvider = new konyNetworkProvider();
   kony.sdk.logsdk.debug("claims token has expired. fetching new token and isBackendTokenRefreshRequired :", isBackendTokenRefreshRequired);
   var _serviceUrl = stripTrailingCharacter(konyRef.rec.url, "/");
   var _url = _serviceUrl + "/claims";
   var bodyParams = {};
   var refreshLoginTokenStoreUtilityObject = kony.sdk.util.getRefreshLoginTokenStoreUtility();
   if (isBackendTokenRefreshRequired) {
     kony.sdk.logsdk.debug('isBackendTokenRefreshRequired is ' + isBackendTokenRefreshRequired + ' in claims refresh');
     _url = _url + "?refresh=true";
     bodyParams[kony.sdk.constants.ENABLE_REFRESH_LOGIN] = true;
     //retrieve custom params
     if (!kony.sdk.util.isNullOrUndefinedOrEmptyObject(kony.sdk.customOAuthParmsForClaimsAndBackendTokenRefresh)) {
       var customOAuthParams = {};
       for (var provider in kony.sdk.customOAuthParmsForClaimsAndBackendTokenRefresh) {
         for (var paramKey in kony.sdk.customOAuthParmsForClaimsAndBackendTokenRefresh[provider]) {
           customOAuthParams[paramKey] = kony.sdk.customOAuthParmsForClaimsAndBackendTokenRefresh[provider][paramKey];
         }
       }
       //populating custom oAuth params
       kony.sdk.util.populateCustomOAuthParams(bodyParams, customOAuthParams);
     }
   }
   kony.sdk.logsdk.debug("service url is " + _url);
   if (konyRef.currentRefreshToken === null) {
     kony.sdk.logsdk.perf("Executing Finished network call for fetchClaimsTokenFromServer");
     kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getNullRefreshTokenErrObj());
   } else {
     var headers = {};
     headers[kony.sdk.constants.KONY_AUTHORIZATION_HEADER] = konyRef.currentRefreshToken;
     headers[kony.sdk.constants.HTTP_CONTENT_HEADER] = kony.sdk.constants.CONTENT_TYPE_FORM_URL_ENCODED;
     kony.sdk.logsdk.perf("Executing network call for fetchClaimsTokenFromServer");
     networkProvider.post(_url, bodyParams, headers, function(identityResponse) {
       kony.sdk.logsdk.perf("Executing Finished network call for fetchClaimsTokenFromServer");
       kony.sdk.logsdk.perf("Executing Finished kony.sdk.fetchClaimsTokenFromServer : refresh success");
       var response = kony.sdk.processClaimsSuccessResponse(identityResponse, konyRef, false);

       function serviceDocCallback() {
         if (!kony.sdk.isNullOrUndefined(identityResponse[kony.sdk.constants.LOGIN_PROFILES])) {
           kony.sdk.logsdk.debug("login profiles present in claims refresh");
           var listOfLoginProfiles = Object.keys(identityResponse[kony.sdk.constants.LOGIN_PROFILES]);
           refreshLoginTokenStoreUtilityObject.setInternalRefreshToken(listOfLoginProfiles, konyRef.currentRefreshToken);
         }
         if (isBackendTokenRefreshRequired && !kony.sdk.isNullOrUndefined(identityResponse[kony.sdk.constants.BACKEND_REFRESH_TOKENS])) {
           kony.sdk.logsdk.debug("trying to update backend tokens securely");
           var providerToLocalTokenObjectJSON = refreshLoginTokenStoreUtilityObject.getAllPersistedRefreshLoginProviderTokens();
           if (!kony.sdk.isNullOrUndefined(providerToLocalTokenObjectJSON)) {
             kony.sdk.logsdk.debug("retrieved local tokens securely");
             var providerToBackendResponseTokenJSON = identityResponse[kony.sdk.constants.BACKEND_REFRESH_TOKENS];
             //updating backend refresh tokens of the providers
             refreshLoginTokenStoreUtilityObject.setBulkBackendRefreshTokens(providerToBackendResponseTokenJSON);
           }
         }
         kony.sdk.verifyAndCallClosure(callback, response);
       }
       getLatestServiceDocIfAvailable(identityResponse, serviceDocCallback);
     }, function(data) {
       kony.sdk.logsdk.perf("Executing Finished network call for fetchClaimsTokenFromServer");
       kony.sdk.logsdk.error("failed to acquire refresh token", data);
       kony.sdk.processClaimsErrorResponse(data, konyRef, true, failureCallback);
     });
   }
 };
 kony.sdk.processClaimsSuccessResponse = function(data, konyRef, isAsync, callBack) {
   kony.sdk.logsdk.trace("Entering kony.sdk.processClaimsSuccessResponse");
   data = kony.sdk.formatSuccessResponse(data);
   konyRef.currentClaimToken = data.claims_token.value;
   konyRef.claimTokenExpiry = data.claims_token.exp;
   konyRef.currentRefreshToken = data.refresh_token;
   kony.logger.setClaimsToken();
   //if offline login enabled then updating the claimstoken in the store
   if (kony.sdk.offline.isOfflineEnabled && kony.sdk.offline.isOfflineEnabled == true) {
     kony.sdk.offline.updateAuthToken(data);
   }
   if (kony.sdk.offline.persistToken || kony.sdk.offline.isPersistentLoginResponseEnabled()) {
     kony.sdk.offline.updatePersistedToken(data);
   }
   if (!isAsync) {
     return {
       "message": "success"
     };
   } else if (callBack) {
     callBack();
   }
 };
 kony.sdk.processClaimsErrorResponse = function(data, konyRef, isAsync, callBack) {
   kony.sdk.logsdk.perf("Executing kony.sdk.processClaimsErrorResponse");
   //setting the anonymous provider as true to access the public protected urls without any issue
   konyRef.isAnonymousProvider = true;
   if (!isAsync) {
     var result = kony.sdk.error.getAuthErrObj(data);
     kony.sdk.logsdk.perf("Executing Finished kony.sdk.processClaimsErrorResponse");
     return result;
   } else if (callBack) {
     kony.sdk.verifyAndCallClosure(callBack, kony.sdk.error.getAuthErrObj(data));
   }
 };
 /**
  * Init success callback method.
  * @callback initSuccessCallback
  * @param {json} mainRef - Application Configuration
  */
 /**
  * Init failure callback method.
  * @callback initFailureCallback
  */
 /**
  * Initialization method for the kony SDK.
  * This method will fetch the app configuration from the kony server and stores in memory.
  * This method has to be invoked before invoking any other SDK methods.
  * @param {string} appKey - Appkey of the kony application
  * @param {string} appSecret - App Secret of the kony application
  * @param {string} serviceUrl - URL of the kony Server
  * @param {initSuccessCallback} successCallback  - Callback method on success
  * @param {initFailureCallback} failureCallback - Callback method on failure
  */
 kony.sdk.prototype.init = function(appKey, appSecret, serviceUrl, successCallback, failureCallback, initOptions) {
   // removing app metadata with key for the latest app metadata
   kony.sdk.logsdk.perf("Executing kony.sdk.prototype.init");
   kony.sdk.util.clearExistingWebsocketObject();
   kony.sdk.util.deleteMetadatafromDs();
   if (!(appKey && appSecret && serviceUrl)) {
     kony.sdk.logsdk.error("### init:: Invalid credentials passed");
     kony.sdk.verifyAndCallClosure(failureCallback, "Invalid initialization parameters passed. Please check appKey, appSecret and ServiceUrl parameters");
     return;
   }
   var networkProvider = new konyNetworkProvider();
   serviceUrl = serviceUrl.trim();
   this.mainRef.serviceUrl = serviceUrl;
   this.mainRef.appSecret = appSecret;
   this.mainRef.appKey = appKey;
   konyRef = this;
   KNYMobileFabric = this;
   //Initializing integrity key for the first time as false
   //If integrity is not set on server by default the value remains false
   konyRef.mainRef.integrityKey = false;
   kony.sdk.currentInstance = konyRef;
   var options = {};
   options[kony.sdk.constants.IGNORE_MESSAGE_INTEGRITY] = true;
   //sending extra an option "isAppConfigCall" for setting integrity for appConfig calls
   options[kony.sdk.constants.IS_APP_CONFIG_CALL] = true;
   setIntegrityParams.call(konyRef);
   kony.sdk.logsdk.trace("### init:: calling GET on appConfig to retrieve servicedoc");
   var headers = kony.sdk.getDefaultHeaders();
   headers[kony.sdk.constants.APP_KEY_HEADER] = appKey;
   headers[kony.sdk.constants.APP_SECRET_HEADER] = appSecret;
   headers["X-HTTP-Method-Override"] = "GET";
   //Resetting the value.
   kony.sdk.setFabricAppVersion(null);
   if (!kony.sdk.isNullOrUndefined(initOptions) && initOptions["MFAppVersion"]) {
     kony.sdk.setFabricAppVersion(initOptions["MFAppVersion"]);
   }
   populateHeaderWithFabricAppVersion(headers);
   kony.sdk.logsdk.perf("Executing network call for fetching servicedoc");
   networkProvider.post(serviceUrl, null, headers, function(data) {
     data = kony.sdk.formatSuccessResponse(data);
     kony.sdk.logsdk.info("### init::_doInit fetched servicedoc successfuly");
     kony.sdk.logsdk.debug("### init:: retrieved data from service doc", data);
     konyRef.mainRef.config = data;
     konyRef.servicedoc = data;
     konyRef.mainRef.appId = data.appId;
     var processServiceDocResult = konyRef.initWithServiceDoc(appKey, appSecret, data);
     if (processServiceDocResult === true) {
       kony.sdk.logsdk.info("### init::_doInit processing service document successful");
       kony.sdk.logsdk.debug("### init::_doInit saving done. Calling success callback", data);
       kony.sdk.initiateSession(konyRef);
       if (typeof(KNYMetricsService) !== "undefined" && kony.sdk.currentInstance.getMetricsService) {
         KNYMetricsService = kony.sdk.currentInstance.getMetricsService();
         if (KNYMetricsService && typeof(appConfig) !== "undefined" && kony.sdk.util.isJsonObject(appConfig) && appConfig.hasOwnProperty("eventTypes") && kony.sdk.isArray(appConfig.eventTypes) && appConfig.eventTypes.length !== 0) {
           KNYMetricsService.setEventTracking(appConfig.eventTypes);
         }
       }
       if (kony.sdk.skipAnonymousCall) {
         kony.sdk.logsdk.info("### init::skipping anonymous login call");
         // Enabling this flag to connect to any protected integration service.
         konyRef.isAnonymousProvider = true;
         kony.sdk.logsdk.perf("Executing Finished kony.sdk.prototype.init");
         kony.sdk.verifyAndCallClosure(successCallback, konyRef.mainRef);
       } else {
         var identityObject = kony.sdk.getCurrentInstance().getIdentityService("$anonymousProvider");
         identityObject.login(null, function(res) {
           kony.sdk.logsdk.perf("Executing Finished network call for fetching servicedoc");
           kony.sdk.logsdk.perf("Executing Finished kony.sdk.prototype.init");
           kony.sdk.verifyAndCallClosure(successCallback, konyRef.mainRef);
         }, function(res) {
           kony.sdk.logsdk.perf("Executing Finished network call for fetching servicedoc");
           kony.sdk.logsdk.perf("Executing Finished kony.sdk.prototype.init");
           kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getAuthErrObj(res));
         });
       }
     } else {
       kony.sdk.logsdk.error("### init::_doInit processing servicedoc failed. Calling failure callback");
       kony.sdk.logsdk.perf("Executing Finished network call for fetching servicedoc");
       kony.sdk.logsdk.perf("Executing Finished kony.sdk.prototype.init");
       kony.sdk.verifyAndCallClosure(failureCallback, JSON.stringify(processServiceDocResult));
     }
   }, function(error) {
     kony.sdk.logsdk.error("### init::_doInit fetching service document from Server failed", error);
     kony.sdk.logsdk.info("### init::_doInit  calling failure callback");
     kony.sdk.logsdk.perf("Executing Finished network call for fetching servicedoc");
     kony.sdk.isInitialized = false;
     kony.sdk.logsdk.perf("Executing Finished kony.sdk.prototype.init");
     kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getAuthErrObj(error));
   }, null, options);
 };
 kony.sdk.prototype.initWithServiceDoc = function(appKey, appSecret, serviceDoc) {
   kony.sdk.logsdk.perf("Executing kony.sdk.prototype.initWithServiceDoc");
   konyRef = this;
   var mSessionUrl = "";
   // initializing identity SID as empty string
   konyRef.idSid = "";
   // initializing refresh login record keeping Set.
   konyRef.refreshLoginProvidersSet = new Set();
   KNYMobileFabric = this;
   kony.sdk.currentInstance = this;
   var unprocessedServiceDoc = kony.sdk.cloneObject(serviceDoc);
   if (kony.sdk.getSdkType() === kony.sdk.constants.SDK_TYPE_IDE) {
     if (!kony.sdk.isNullOrUndefined(serviceDoc)) {
       kony.sdk.util.checkAndUpdateIntegrityKey(serviceDoc);
     }
   } else {
     //platform phonegap and plain-js doesn't support http integrity
     konyRef.mainRef.integrityKey = false;
   }
   if (serviceDoc instanceof kony.sdk.serviceDoc) {
     var servConfig = serviceDoc.toJSON();
     processServiceDocMap(servConfig);
   } else {
     return processServiceDocMap(serviceDoc);
   }

   function processServiceDocMap(servConfig) {
     for (var item in servConfig) {
       if (kony.sdk.isNullOrUndefined(servConfig[item]) || kony.sdk.isEmptyObject(servConfig[item])) {
         delete servConfig[item];
       }
     }
     kony.sdk.logsdk.debug("### init::_doInit::_processServiceDoc", servConfig);
     try {
       konyRef.mainRef.appKey = appKey;
       konyRef.mainRef.appSecret = appSecret;
       konyRef.mainRef.appId = servConfig.appId;
       konyRef.mainRef.config = serviceDoc;
       /* if (!servConfig.baseId) {
        throw new Exception(kony.sdk.errorConstants.INIT_FAILURE, "invalid baseId " + servConfig.baseId);
        } */
       konyRef.mainRef.baseId = servConfig.baseId;
       /* if (!servConfig.name) {
        throw new Exception(kony.sdk.errorConstants.INIT_FAILURE, "invalid name " + servConfig.name);
        } */
       konyRef.mainRef.name = servConfig.name;
       if (servConfig.login) {
         konyRef.login = servConfig.login;
       } else {
         konyRef.login = [];
       }
       var url = servConfig.selflink;
       if (url) {
         var lastPos = url.indexOf("/appconfig");
         if (lastPos != -1) {
           url = url.slice(0, lastPos);
         } else {
           throw new Exception(kony.sdk.errorConstants.INIT_FAILURE, "invalid self link");
         }
         var anonymousLoginProvider = {};
         anonymousLoginProvider.type = "anonymous";
         anonymousLoginProvider.url = url;
         anonymousLoginProvider.prov = "$anonymousProvider";
         konyRef.login.push(anonymousLoginProvider);
       }
       if (typeof(servConfig.integsvc) !== 'undefined') {
         kony.sdk.logsdk.info("### init::_doInit::_processServiceDoc parsing Integration services");
         konyRef.integsvc = servConfig.integsvc;
         kony.sdk.logsdk.debug("### init::_doInit::konyRef integration Services", konyRef.integsvc);
       }
       if (typeof(servConfig.services_meta) === 'object') {
         kony.sdk.logsdk.info("### init::_doInit::_processServiceDoc parsing Object services");
         kony.sdk.util.populateIndividualServiceLists(servConfig, konyRef);
       }
       if (typeof(servConfig.messagingsvc) !== 'undefined') {
         kony.sdk.logsdk.info("### init::_doInit::_processServiceDoc parsing Messaging services");
         konyRef.messagingsvc = servConfig.messagingsvc;
       }
       if (typeof(servConfig.logicsvc) !== 'undefined') {
         kony.sdk.logsdk.info("### init::_doInit::_processServiceDoc parsing Logic services");
         konyRef.logicsvc = servConfig.logicsvc;
       }
       if (typeof(servConfig.sync) !== 'undefined') {
         konyRef.sync = servConfig.sync;
       }
       if (servConfig.identity_features && servConfig.identity_features.reporting_params_header_allowed) {
         kony.sdk.logsdk.info("### init::_doInit::_processServiceDoc parsing Identity features");
         konyRef.reportingheaders_allowed = servConfig.identity_features.reporting_params_header_allowed;
       }
       if (kony.sdk.isLicenseUrlAvailable) {
         if (servConfig.reportingsvc && servConfig.reportingsvc.custom && servConfig.reportingsvc.session) {
           konyRef.customReportingURL = servConfig.reportingsvc.custom;
           konyRef.sessionReportingURL = servConfig.reportingsvc.session;
           mSessionUrl = konyRef.sessionReportingURL;
           if (mSessionUrl) {
             var lastIndex = mSessionUrl.lastIndexOf("/");
             if (lastIndex !== -1) {
               var networkUrl = mSessionUrl.substring(0, lastIndex + 1);
               //set the Websocket URL
               if (kony.serverEvents) {
                 konyRef.serverEventsUrl = (networkUrl + kony.sdk.constants.SERVER_EVENTS_URL_ENDPOINT).replace("http", "ws");
                 initializeServerEvents();
               }
               //Set the logger networkpersistor URL
               if (kony.logger.isNativeLoggerAvailable()) {
                 var networkPersistor = kony.logger.createNetworkPersistor();
                 networkPersistor.URL = networkUrl + kony.logger.networkPersistorUrlEndpoint;
                 kony.logger.setPersistorConfig(networkPersistor);
               }
             }
           }
         } else {
           throw new Exception(kony.sdk.errorConstants.INIT_FAILURE, "invalid url for reporting service");
         }
       }
       if (konyRef.internalSdkObject) {
         konyRef.internalSdkObject.initWithServiceDoc(appKey, appSecret, servConfig);
         if (konyRef.internalSdkObject.setClientParams) {
           if (appConfig) {
             konyRef.internalSdkObject.setClientParams({
               "aid": appConfig.appId,
               "aname": appConfig.appName,
               "aversion": appConfig.appVersion
             });
           } else {
             konyRef.internalSdkObject.setClientParams(konyRef.getClientParams());
           }
         }
         kony.sdk.logsdk.info("### init::internal sdk object initialized");
       }
       kony.sdk.logsdk.info("### init::_doInit::_processServiceDoc parsing service document done");
       kony.sdk.isInitialized = true;
       konyRef.isAnonymousProvider = true;
       if (kony.sdk.metric && kony.os.deviceInfo().name === kony.sdk.constants.PLATFORM_SPA) {
         kony.sdk.metric.flushEvents();
       }
       //checking for licenseCall
       if (!kony.sdk.isNullOrUndefined(servConfig.reportingsvc)) {
         kony.sdk.setLicenseCall(appKey, appSecret, unprocessedServiceDoc);
       }
       //making this check for plain-js and phoneGap in android.
       if (kony.sdk.getSdkType() !== kony.sdk.constants.SDK_TYPE_PLAIN_JS && kony.sdk.getSdkType() !== kony.sdk.constants.SDK_TYPE_PHONEGAP) {
         if (kony.sdk.getPlatformName() === kony.sdk.constants.PLATFORM_ANDROID && (appConfig.isSSOEnabled === true || appConfig.isSSOEnabled === "true")) {
           kony.sdk.util.initializeSSO();
         }
       }
       var sdkType = kony.sdk.getSdkType();
       var type = kony.sdk.getAType();
       var platformName = kony.sdk.getPlatformName();
       if (sdkType == kony.sdk.constants.SDK_TYPE_IDE && ((type === kony.sdk.constants.SDK_ATYPE_NATIVE) || (type === kony.sdk.constants.SDK_ATYPE_SPA))) {
         if ((!kony.sdk.isNullOrUndefined(konyRef.offlineObjectsvc)) && !(kony.sdk.isEmptyObject(konyRef.offlineObjectsvc))) {
           konyRef.OfflineObjects = new kony.sdk.OfflineObjects(konyRef.offlineObjectsvc);
         }
       }
       if (kony.license) {
         if (kony.licensevar && kony.licensevar.changeHandlers && kony.licensevar.changeHandlers.length == 0 && kony.license.registerChangeListener) {
           kony.license.registerChangeListener(konyRef.sessionChangeHandler);
           konyRef.overrideUserIdFlag = true;
         }
       }
       if (konyRef.mainRef.integrityKey === true) {
         setIntegrityParamsHandler();
       } else {
         resetIntegrityParams();
         if (!(kony.sdk.getAType() === kony.sdk.constants.SDK_ATYPE_SPA || kony.sdk.getAType() === "watch")) {
           //invoke NFI only for android,ios and FFI for windows 
           kony.sdk.httpIntegrity.removeIntegrityCheck();
         }
       }
       // Generating SDK Client UUID for service calls and server events
       if (kony.sdk.getSdkType() !== kony.sdk.constants.SDK_TYPE_PHONEGAP) {
         kony.sdk.util.checkAndGenerateClientUUID();
       }
       kony.sdk.logsdk.perf("Executing Finished kony.sdk.prototype.initWithServiceDoc");
       return true;
     } catch (err) {
       kony.sdk.logsdk.error("### init::_doInit::_processServiceDoc failed with an exception: ", err);
       return ("processing the ServiceDoc failed with an exception: " + JSON.stringify(err));
     }
   }
 };
 kony.sdk.prototype.sessionChangeHandler = function(changes) {
   kony.sdk.logsdk.perf("Executing kony.sdk.prototype.sessionChangeHandler");
   var konyRef = kony.sdk.getCurrentInstance();
   konyRef.getMetricsService();
   var sessionId = null;
   var userId = null;
   if (!kony.sdk.util.isNullOrEmptyString(changes["sessionId"])) {
     sessionId = changes["sessionId"];
     konyRef.setSessionId(sessionId);
     if (konyRef.internalSdkObject) {
       sessionId = sessionId + "," + kony.sdk.util.getSessionType();
     }
     if (konyRef.metricsServiceObject && konyRef.metricsServiceObject.setSessionId) {
       konyRef.metricsServiceObject.setSessionId(sessionId);
     }
   }
   if (changes["userId"] != undefined) {
     konyRef.overrideUserIdFlag = true;
     userId = changes["userId"];
     konyRef.setCurrentUserId(userId);
     if (konyRef.metricsServiceObject && konyRef.metricsServiceObject.setUserId) {
       konyRef.metricsServiceObject.setUserId(userId);
     }
   }
   kony.sdk.logsdk.perf("Executing Finished kony.sdk.prototype.sessionChangeHandler");
 };

 function setIntegrityParams() {
   var integrityParams = {
     "algo": kony.sdk.constants.HASHING_ALGORITHM,
     "headerName": kony.sdk.constants.INTEGRITY_HEADER,
     "validateResp": true,
     "passthroughHeaderName": kony.sdk.constants.PASSTHROUGH_RESPONSE_HEADER
   };
   if (!kony.sdk.isNullOrUndefined(konyRef.getAppSecurityKey())) {
     integrityParams["salt"] = konyRef.getAppSecurityKey();
   } else {
     integrityParams["salt"] = konyRef.mainRef.appSecret;
   }
   //commenting integrity global header as only appConfig call requires integrity enabled
   //if not set by the server
   //konyRef.mainRef.integrityKey = true;
   konyRef.mainRef.integrityParams = integrityParams;
 }

 function resetIntegrityParams() {
   konyRef.mainRef.integrityKey = false;
   konyRef.mainRef.integrityParams = {};
 }

 function setIntegrityParamsHandler() {
   setIntegrityParams();
   try {
     if (!(kony.sdk.getAType() === kony.sdk.constants.SDK_ATYPE_SPA || kony.sdk.getAType() === "watch")) {
       //invoke NFI only for android and ios.
       kony.sdk.httpIntegrity.setIntegrityCheck(konyRef.mainRef.integrityParams);
     }
   } catch (e) {
     kony.sdk.logsdk.warn("Invalid Integrity properties received");
     throw new Exception(kony.sdk.errorConstants.INTEGRITY_FAILURE, "Invalid Integrity properties");
   }
 }
 /**
  * MFSDK
  * Created by KH1969 on 18-01-2018.
  * Copyright  2018 Kony. All rights reserved.
  */
 /**
  * Constructor for ClientCache service, uses lruCache.js internally to save key, value pairs.
  * This is a singleton class, object gets created for the first time of instantiation and the same object is
  * returned for next initializations.
  *
  * @param size {Number} Maximum size of the cache. It should be non zero positive number.
  * @return {kony.sdk.ClientCache}
  *
  */
 kony.sdk.ClientCache = function(size) {
   if (typeof kony.sdk.ClientCache.instance === 'object') return kony.sdk.ClientCache.instance;
   var lruCacheObj = null;
   if (size === undefined || size === null) lruCacheObj = new lruCache(kony.sdk.constants.DEFAULT_CACHE_SIZE);
   else if (typeof size != 'number' || size <= 0) {
     kony.sdk.logsdk.warn("cache cannot be created of size <= 0");
     return null;
   } else lruCacheObj = new lruCache(size);
   /**
    * Gets the response cached for the key. Returns null if not found.
    * @param key {string}
    * @return {null|object}
    */
   this.get = function(key) {
     return lruCacheObj.get(key);
   }
   /**
    * Gets the boolean assertion for key existence in the cache.
    * @param key {string}
    * @return {boolean}
    */
   this.has = function(key) {
     return lruCacheObj.has(key);
   }
   /**
    * Adds the key, value pair to cache.
    * @param key {string}
    * @param value {string}
    * @param expiryTime {number} Expiry time in seconds.
    */
   this.add = function(key, value, expiryTime) {
     lruCacheObj.add(key, value, expiryTime);
   }
   /**
    * Removes the key, value from cache.
    * @param key {string}
    */
   this.remove = function(key) {
     lruCacheObj.remove(key);
   }
   kony.sdk.ClientCache.instance = this;
 }
 /**
  * MFSDK
  * Created by KH1969 on 18-01-2018.
  * Copyright  2018 Kony. All rights reserved.
  */
 /**
  * Constructor for standalone LRU page replacement implementation.
  * Implementation is done using a double linked list data structure and a hashmap.
  * Upon every insert & get the head gets updated to the newest element.
  * Cached nodes gets removed if size is more than the requested capacity.
  * Default cache size is 100.
  *
  * Should not be called by the developer.
  *
  *  Below is the list structure if elements are inserted in the order A, B, C & D

  *  Head = D, Tail = A
  *  D--(older)-->C--(older)-->B--(older)-->A--(older)-->NULL
  *  NULL<--(newer)--D<--(newer)--C<--(newer)--B<--(newer)--A
  *
  *  Now if B is accessed the list structure will be modified as,
  *  Head = B, Tail = A
  *
  *  B--(older)-->D--(older)-->C--(older)-->A--(older)-->NULL
  *  NULL<--(newer)--B<--(newer)--D<--(newer)--C<--(newer)--A
  */
 lruCache = function(size) {
   var LOG_PREFIX = "SDK_CACHE ";
   if (size === undefined || size === null) this.capacity = kony.sdk.constants.DEFAULT_CACHE_SIZE;
   else if (typeof size != 'number' || size <= 0) {
     kony.sdk.logsdk.warn("cache cannot be created of size <= 0");
     return null;
   } else this.capacity = size;
   this.length = 0;
   this.map = {};
   // save the head and tail so we can update it easily
   this.head = null;
   this.tail = null;
   /**
    * Gets the current time in seconds.
    * @returns {number}
    */
   function getCurrentTimeInSeconds() {
     return Math.floor(new Date().getTime() / 1000);
   }
   /**
    * Double linked list data structure.
    * @param key
    * @param value
    */
   function cacheNode(key, value, expiry) {
     this.key = key;
     this.val = value;
     this.newer = null; // Next newer node
     this.older = null; // Previous older node
     this.expiryTime = 0;
     if (expiry !== undefined && typeof expiry === 'number' && expiry != 0) {
       this.expiryTime = getCurrentTimeInSeconds() + expiry;
     }
   }
   /**
    * Shuffles the cache by last recently used.
    * @param key
    */
   function shuffleLRUCache(key) {
     var node = this.map[key];
     if (this.head === node) {
       // No need to shuffle the cache, as the head itself is the recently accessed node.
       return;
     }
     // Head will not have newer node.
     if (node.newer) {
       node.newer.older = node.older;
     } else {
       this.head = node.older;
     }
     // Tail will not have older node.
     if (node.older) {
       node.older.newer = node.newer;
     } else {
       this.tail = node.newer;
     }
     // Now node is detached. Place it at head.
     // Updates are done in this way
     // 1: node--(older)-->head
     // 2: null<--(newer)--node
     // 3: node<--(newer)--head
     // 4: node is assigned to head. So current head got updated to node.
     node.older = this.head;
     node.newer = null;
     if (this.head) {
       this.head.newer = node;
     }
     this.head = node;
   }
   /**
    * Returns the current size of the cache.
    * @returns {number}
    */
   this.getSize = function() {
     return this.length;
   }
   /**
    * Adds the key value pair to the cache.
    * Key gets removed upon expiry, expiry time is calculated by currentTimeInSeconds + expiryTime.
    * If no expiryTime is specified then key will not expire.
    * @param key {String}
    * @param value {Object}
    * @param expiryTime {Number}
    */
   this.add = function(key, value, expiryTime) {
     if (key === undefined || value === undefined || key === null || value === null) return;
     // update the value for existing entries
     if (this.has(key)) {
       this.map[key].val = value;
       kony.sdk.logsdk.debug(LOG_PREFIX + "Key: " + key + " updated");
       shuffleLRUCache.call(this, key);
       return;
     }
     if (this.length >= this.capacity) {
       // remove the least recently used item
       this.remove(this.tail.key)
     }
     var node = new cacheNode(key, value, expiryTime);
     // Additions are done in this way
     // 1: node--(older)-->head
     // 2: node<--(newer)--head
     // 3: node is assigned to head. So current head got updated to node.
     // 4: tail = node, if there is no tail node then current node is tail node. This happens only for the first add.
     node.older = this.head;
     // if have head, we need re-connect node with other nodes older than head
     if (this.head) {
       this.head.newer = node;
     }
     this.head = node;
     // if no tail which means first insert, set the tail to node too
     if (!this.tail) {
       this.tail = node;
     }
     this.map[key] = node;
     this.length++;
     kony.sdk.logsdk.debug(LOG_PREFIX + "Key: " + key + " added");
   }
   /**
    * Gets the cached node by key. Returns null if key is not found.
    * The key is removed if it is expired, returns null here as well.
    * @param key {String}
    * @returns {Object}
    */
   this.get = function(key) {
     if (this.has(key)) {
       if (this.map[key].expiryTime != 0 && getCurrentTimeInSeconds() > this.map[key].expiryTime) {
         this.remove(key);
         kony.sdk.logsdk.debug(LOG_PREFIX + "Key: " + key + " expired");
         return null;
       }
       shuffleLRUCache.call(this, key);
       return this.map[key].val;
     } else {
       return null;
     }
   }
   /**
    * Removes the key, value from the cache by key.
    * @param key {String} Key to delete from the cache
    */
   this.remove = function(key) {
     if (this.has(key)) {
       var node = this.map[key];
       // Head node will not have newer node.
       if (node.newer) {
         node.newer.older = node.older;
       } else {
         this.head = node.older;
       }
       // Tail node will not have older node.
       if (node.older) {
         node.older.newer = node.newer;
       } else {
         this.tail = node.newer;
       }
       delete this.map[key];
       node = null;
       this.length--;
     }
   }
   /**
    * Clears the cache.
    */
   this.clear = function() {
     this.map = {};
     this.length = 0;
   }
   /**
    * Check if key exists.
    * @param key {string} Key to be found in the cache
    * @returns {boolean}
    */
   this.has = function(key) {
     return this.map.hasOwnProperty(key);
   }
   /**
    * Updates the cache size.
    * @param size {number}
    */
   this.setMaxCacheSize = function(size) {
     //    Todo: If requested size < capacity remove the last (N - size) nodes from tail.
     kony.sdk.logsdk.debug(LOG_PREFIX + "updating cache size from " + this.capacity + " to " + size);
     this.capacity = size;
   }
 }
 /**
  * Method to create the configuration service instance
  * @returns {ConfigurationService} Configuration service instance
  */
 kony.sdk.prototype.getConfigurationService = function() {
   kony.sdk.logsdk.perf("Executing kony.sdk.prototype.getConfigurationService")
   if (!kony.sdk.isInitialized) {
     throw new Exception(kony.sdk.errorConstants.INIT_FAILURE, kony.sdk.constants.INIT_FAILURE_MESSAGE + " Configuration service.");
   }
   var configObj = new ConfigurationService(this);
   kony.sdk.logsdk.perf("Executing Finished kony.sdk.prototype.getConfigurationService")
   if (configObj) {
     return configObj;
   } else {
     throw new Exception(kony.sdk.errorConstants.CONFIGURATION_FAILURE, "Error in creating configuration object");
   }
 };
 /**
  * Should not be called by the developer.
  * @class
  * @classdesc Configuration service instance for fetching client app properties.
  */
 function ConfigurationService(konyRef) {
   var istUrl = konyRef.mainRef.config.reportingsvc.session.split("/IST")[0];
   kony.sdk.logsdk.debug("IST url fetched from service doc is :" + istUrl);
   var configUrl = istUrl + kony.sdk.constants.GET_CLIENT_PROPERTY_URL;
   kony.sdk.logsdk.debug("Configuration url formed is :" + configUrl);
   var networkProvider = new konyNetworkProvider();
   /**
    * Configuration svc method to get all the client app properties which is configured in admin console.
    * @successCallback this is called on successfull retrieval of properties
    * @failureCallback this is called on failure in retrieving properties
    * @returns {json} key value pair of all client app properties
    */
   this.getAllClientAppProperties = function(successCallback, failureCallback) {
     function fetchClientPropertiesHandler() {
       _getAllClientAppProperties(successCallback, failureCallback);
     }
     if (kony.sdk.skipAnonymousCall) {
       fetchClientPropertiesHandler();
     } else {
       kony.sdk.claimsRefresh(fetchClientPropertiesHandler, failureCallback);
     }
   };

   function _getAllClientAppProperties(successCallback, failureCallback) {
     kony.sdk.logsdk.trace("Entering into _getAllClientAppProperties");
     var defaultHeaders = kony.sdk.getDefaultHeaders();
     if (!kony.sdk.skipAnonymousCall) {
       var token = konyRef.currentClaimToken;
       if (!token) {
         token = kony.sdk.getCurrentInstance().currentClaimToken;
       }
       defaultHeaders[kony.sdk.constants.KONY_AUTHORIZATION_HEADER] = token;
     }
     var options = {};
     options[kony.sdk.constants.IGNORE_MESSAGE_INTEGRITY] = true;
     networkProvider.get(configUrl, null, defaultHeaders, function(res) {
       kony.sdk.logsdk.trace("Entering Configuration service network success");
       kony.sdk.logsdk.debug("response from server for client properties is :" + JSON.stringify(res));
       var tempArray = ["httpresponse", kony.sdk.constants.MF_OPSTATUS];
       var tempJSON = {};
       for (var key in res) {
         if (tempArray.indexOf(key.toLowerCase()) > -1) {
           continue;
         }
         tempJSON[key] = res[key];
       }
       kony.sdk.verifyAndCallClosure(successCallback, tempJSON);
     }, function(xhr, status, err) {
       kony.sdk.logsdk.trace("Entering Configuration service network error");
       if (xhr && !(status && err)) {
         err = xhr;
       }
       kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getObjectServiceErrObj(err));
     }, null, options);
   }
 }
 kony.sdk.constants = {
   /**Logger Constants**/
   LOGGER_NAME: "MFSDK",
   SYNC_LOGGER_NAME: "SYNCV1",
   APP_LOGGER_NAME: "KonyLogger",
   /**Network constants**/
   LAUNCHMODE_DEEPLINK: 3,
   DEEPLINK_VALID_PARAM: "code",
   HASHING_ALGORITHM: "SHA256",
   REMOVE_INTEGRITY_CHECK: "removeIntegrityCheck",
   SET_INTEGRITY_CHECK: "setIntegrityCheck",
   DISABLE_INTEGRITY_CHECK: "disableIntegrityCheck",
   DEFAULT_CACHE_SIZE: 100,
   GET_CLIENT_PROPERTY_URL: "/metadata/configurations/client/properties",
   DEFAULT_CACHE_EXPIRY_TIME: 0, //Which means it doesn't expire in the application session.
   QUERY_PARAMS: "queryParams",
   QUERY: "query",
   BODY_PARAMS: "bodyParams",
   OAUTH_SESSION_RESPONSE_TYPE: "oauth_session_response_type",
   /**Service ID's for Identity Calls**/
   GET_BACKEND_TOKEN: "getBackendToken",
   GET_SECURITY_ATTRIBUTES: "getSecurityAttributes",
   GET_USER_ATTRIBUTES: "getUserAttributes",
   GET_USER_DATA: "getUserData",
   GET_PROFILE: "getProfile",
   KEY_PROVIDER: "provider",
   KEY_INCLUDE_PROFILE: "include_profile",
   OAUTH_TOKEN_URL: "/oauth2/token",
   KEY_HTTP_REQUEST_OPTIONS: "httpRequestOptions",
   KEY_XML_HTTP_REQUEST_OPTIONS: "xmlHttpRequestOptions",
   ENABLE_WITH_CREDENTIALS: "enableWithCredentials",
   KEY_GRANT_TYPE: "grant_type",
   KEY_REFRESH_TOKEN: "refresh_token",
   KEY_BACKEND_REFRESH_TOKEN: "backend_refresh_token",
   KEY_AUTH_REFRESH_TOKEN: "auth_refresh_token",
   KEY_URL: "url",
   KEY_APP_CHALLENGE_METHOD: "app_challenge_method",
   APP_VERIFIER: "app_verifier",
   APP_CHALLENGE: "app_challenge",
   APP_CHALLENGE_METHOD_VALUE: "S256",
   PKCE_CODE_MAX_LENGTH: 128,
   IS_ENABLE_IDENTITY_PKCE: "is_enable_identity_pkce",
   ENABLE_IDENTITY_PKCE: "enable_identity_pkce",
   /** Identity Options**/
   OAUTH_REDIRECT_SUCCESS_URL: "success_url",
   /** ETAG_ID Constants **/
   ETAGID: "etagID",
   TOOLS_ETAG_ID: "tools_etagID",
   /** Init flags**/
   IS_APP_CONFIG_CALL: "isAppConfigCall",
   /** Multifactor auth related constants**/
   IS_MFA_ENABLED: "is_mfa_enabled",
   MFA_META: "mfa_meta",
   //OAuth for IE11 Workaround Constants, MFSDK-3657
   IE11_CROSS_DOMAIN_OAUTH_BASE_URL: "IE11CrossDomainOAuthBaseUrl",
   KNY_OAUTH_REDIRECT_HTML: "KNYOAuthRedirect.html",
   KNY_OAUTH_CALLBACK_HTML: "KNYOAuthCallback.html",
   KNY_OAUTH_REDIRECT_URL: "kny_oauth_redirect_url",
   KNY_OAUTH_PROTOCOL_PARAM: "kny_protocol_param",
   /**HttpMethods and header constants**/
   HTTP_METHOD_GET: "GET",
   HTTP_METHOD_POST: "POST",
   HTTP_METHOD_DELETE: "DELETE",
   HTTP_CONTENT_HEADER: "Content-Type",
   HTTP_REQUEST_HEADER_ACCEPT: "Accept",
   HEADER: "header",
   /**Content Type Value Constants**/
   CONTENT_TYPE_FORM_URL_ENCODED: "application/x-www-form-urlencoded",
   //Added a new content-type based on the bug MFSDK-5665
   CONTENT_TYPE_FORM_URL_ENCODED_CHARSET_UTF8: "application/x-www-form-urlencoded;charset=utf-8",
   CONTENT_TYPE_JSON: "application/json",
   //Added a new content-type based on the bug MFSDK-4096
   CONTENT_TYPE_JSON_CHARSET_UTF8: "application/json;charset=utf-8",
   CONTENT_TYPE_OCTET_STREAM: "application/octet-stream",
   CONTENT_TYPE_TEXT_HTML: "text/html",
   CONTENT_TYPE_TEXT_PLAIN: "text/plain",
   /**SDK Plugin Type**/
   SDK_TYPE_IDE: "js",
   SDK_TYPE_PHONEGAP: "phonegap",
   SDK_TYPE_PLAIN_JS: "plain-js",
   /**APP Session Type**/
   APP_SESSION_INTERACTIVE: "I",
   APP_SESSION_NON_INTERACTIVE: "NI",
   /**SDK Architecture Type**/
   SDK_ATYPE_NATIVE: "native",
   SDK_ATYPE_SPA: "spa",
   /**Device platform**/
   PLATFORM_WINDOWS: "windows",
   PLATFORM_ANDROID: "android",
   PLATFORM_IOS: "ios",
   PLATFORM_THIN_CLIENT: "web",
   //kony.os.device.info() for SPA returns thinclient
   PLATFORM_SPA: "thinclient",
   /***Metrics Constants**/
   REPORTING_PARAMS: "konyreportingparams",
   KEY_DEVICE_ID: "deviceID",
   KONY_METRICS_BUFFER: "konyMetricsBuffer",
   KONY_CUSTOM_REPORT_DATA: "konyCustomReportData",
   EVENT_BUFFER_MAX_COUNT: "eventBufferMaxCount",
   EVENT_BUFFER_AUTO_FLUSH_COUNT: "eventBufferAutoFlushCount",
   EVENT_SUB_TYPE: "evtSubType",
   FORM_ID: "formID",
   WIDGET_ID: "widgetID",
   FLOW_TAG: "flowTag",
   BUFFER: "BUFFER",
   CONFIG_TYPE: "confType",
   /**Headers**/
   APP_KEY_HEADER: "X-Kony-App-Key",
   APP_SECRET_HEADER: "X-Kony-App-Secret",
   KONY_AUTHORIZATION_HEADER: "X-Kony-Authorization",
   AUTHORIZATION_HEADER: "Authorization",
   REPORTING_HEADER: "X-Kony-ReportingParams",
   INTEGRITY_HEADER: "X-Kony-Integrity",
   DEVICEID_HEADER: "X-Kony-DeviceId",
   API_VERSION_HEADER: "X-Kony-API-Version",
   APP_VERSION_HEADER: "X-Kony-App-Version",
   SDK_TYPE_HEADER: "X-Kony-SDK-Type",
   SDK_VERSION_HEADER: "X-Kony-SDK-Version",
   PLATFORM_TYPE_HEADER: "X-Kony-Platform-Type",
   REQUEST_ID_HEADER: "X-Kony-RequestId",
   HTTP_OVERRIDE_HEADER: "X-HTTP-Method-Override",
   /**Mobilefabric constants**/
   HTTP_STATUS_CODE: "httpStatusCode",
   MF_OPSTATUS: "opstatus",
   MF_CODE: "mfcode",
   MF_ERROR_MSG: "errmsg",
   MF_ERROR_CODE: "errcode",
   MF_SERVICE: "service",
   KEY_RESPONSE_CODE: "responsecode",
   KEY_HTTP_RESPONSE: "httpresponse",
   HTTP_CODE_400: 400,
   HTTP_CODE_401: 401,
   /**Engagement service API constants**/
   SUBSCRIBE_AUDIENCE: "/subscribeaudience",
   BEACON_UPDATE: "/beaconupdate",
   RICH_PUSH_MESSAGE: "/messages/rich/",
   LAST_ACTIVE_DATE: "lastActiveDate",
   KSID: "ksid",
   AUTH_TOKEN: "authToken",
   DEVICE_AUTHTOKEN_HEADER: "X-Device-AuthToken",
   FUNCTION_STRING: "function",
   /**Parsed Template Constants**/
   PROCESSED_TEMPLATE: "processedTemplate",
   MISSING_VARIABLES: "missingVariables",
   /**Mandatory Binary Params**/
   FILE_PATH: "FilePath",
   RAW_BYTES: "rawBytes",
   FILE_OBJECT: "fileObject",
   FILE_NAME: "fileName",
   /**Miscellaneous**/
   KONYUUID: "konyUUID",
   BROWSER_WIDGET: "browserWidget",
   INIT_FAILURE_MESSAGE: "SDK is not initialized, call init before invoking any operation on",
   DISABLE_INTEGRITY: "disableIntegrity",
   PASSTHROUGH: "passthrough",
   BINARY_DATATYPE: "binary",
   JSON_DATA: "jsondata",
   IGNORE_MESSAGE_INTEGRITY: "ignoreMessageIntegrity",
   KEY_MESSAGE: "message",
   KEY_CODE: "code",
   EQUAL_TO: "=",
   /** License Constants **/
   LICENSE_SESSION_TIMEOUT_IN_MILLIS: 14400000,
   LICENSE_BG_TO_FG_SESSION_TIMEOUT_IN_MILLIS: 1800000,
   LICENSE_KONY_OFFLINE_ACCESS_DATA: "konyOfflineAccessData",
   /** SSO Constants **/
   DW_SSO_TOKEN_KEY: "ssoAuth",
   SSO_TOKEN_KEY: "ssoTokenKey",
   SSO_SECRET_KEY: "ssoSecretKey",
   SSO_ENCRYPTION_KEY: "ssoencryption",
   /** Encryption Constants **/
   ENCRYPTION_ALGO_AES: "aes",
   HASH_FUNCTION_MD5: "md5",
   HASH_FUNCTION_SHA2: "sha2",
   ENC_TYPE_PASSPHRASE: "passphrase",
   ENC_PASSPHRASE_HASH_ALGO: "passphrasehashalgo",
   AES_ALGO_KEY_STRENGTH_128: 128,
   AES_ALGO_KEY_STRENGTH_256: 256,
   ENCRYPTION_APPCONFIG_FLAG: "appConfig_v1",
   SHARED_CLIENT_IDENTIFIER: "shared_client_identifier",
   MOBILE_FABRIC_SERVICE_DOC: "mobileFabricServiceDoc",
   /** Auth Providers Types **/
   AUTH_PROVIDER_TYPE_SAML: "saml",
   AUTH_PROVIDER_TYPE_OAUTH2: "oauth2",
   /**Persist login constants**/
   PERSISTED_AUTH_RESPONSE: "persistedAuthResponse",
   PERSIST_LOGIN_RESPONSE_FLAG: "persistLoginResponseFlag",
   CUSTOM_DATA_SAVE_HANDLE: "customDataSaveHandle",
   /**single window login constants**/
   NO_POP_UP: "noPopup",
   LOGIN_OPTIONS: "loginOptions",
   URL_TYPE: "url_type",
   METADATA_MANAGER_FOR_LOGIN_IN_SAME_WINDOW_OBJECT: "metadata_manager_for_login_in_same_window_object",
   APP_VERIFIER_MW_STORE_ENDPOINT: "/ClientState",
   IS_ERROR: "isError",
   LOGIN_RESPONSE: "LOGIN_RESPONSE",
   SINGLE_WINDOW_LOGIN_BODY_PARAMS: "single_window_login_body_params",
   KEY_IS_SAME_WINDOW: "isSameWindow",
   KEY_METADATA_SDK_LOGIN_FOR_SAME_WINDOW: "key_metadata_sdk_login_for_same_window",
   KEY_APPCONFIG_FOR_SINGLE_WINDOW_LOGIN: "appConfigForSingleWindowLogin",
   /**Offline login constants**/
   OFFLINE_LOGIN_AUTH_RESPONSE: "authResponse",
   /** Passthrough constant **/
   PASSTHROUGH_RESPONSE_HEADER: "X-Kony-Passthrough",
   /**Server events constants**/
   SERVER_EVENTS_URL_ENDPOINT: "ServerEvents/Stream",
   SERVER_EVENTS_CLOSE_CONNECTION: "closeConnection",
   PERSISTED_REFRESH_LOGIN_PROVIDER_TOKENS: "persistedRefreshLoginProviderTokens",
   INTERNAL_REFRESH_TOKEN: "internalRefreshToken",
   BACKEND_REFRESH_TOKEN: "backendRefreshToken",
   ENABLE_REFRESH_LOGIN: "enable_refresh_login",
   BACKEND_REFRESH_TOKENS: "backend_refresh_tokens",
   RETAIN_BACKEND_REFRESH_TOKEN: "retain_backend_refresh_token",
   LOGIN_PROFILES: "profiles",
   LOGIN_PROVIDER_TYPE: "provider_type",
   /**Integration service constants**/
   INTEGRATION_SERVICE_KEY: "integsvc",
   INTEGRATION_INTERNAL_LOGOUT_URL: "_internal_logout",
   INTEGRATION_INTERNAL_CLEAR_SESSION_ENDPOINT: "clearSession",
   /** SDK Universal Constants **/
   CLIENT_SDK_UUID: "clientUUID",
   CLIENT_SDK_UNIVERSAL_SALT: "sdkIdentifier",
   /**custom params for oauth**/
   CUSTOM_QUERY_PARAMS_FOR_OAUTH: "customQueryParamsForOAuth",
   CUSTOM_OAUTH_PARAMS: "customOAuthParams",
   LOGOUT_OPTIONS: "logoutOptions"
 };
 if (typeof(kony.sdk) === "undefined") {
   kony.sdk = {};
 }
 if (typeof(kony.sdk.error) === "undefined") {
   kony.sdk.error = {};
 }
 kony.sdk.error.getAuthErrObj = function(errResponse) {
   kony.sdk.logsdk.trace("Entering into kony.sdk.error.getAuthErrObj");
   if (errResponse && errResponse.httpresponse) {
     delete errResponse.httpresponse;
   }
   if (errResponse && errResponse[kony.sdk.constants.MF_ERROR_MSG]) {
     errResponse["message"] = errResponse[kony.sdk.constants.MF_ERROR_MSG];
     delete errResponse.errmsg;
   }
   try {
     var mfcode = errResponse[kony.sdk.constants.MF_CODE];
     var message = errResponse["message"];
     var details = errResponse["details"];
     if (mfcode) {
       return kony.sdk.error.getMFcodeErrObj(mfcode, message, details, "");
     }
     return errResponse;
   } catch (err) {
     return errResponse;
   }
 }
 kony.sdk.error.getNullClaimsTokenErrObj = function() {
   kony.sdk.logsdk.trace("Entering into kony.sdk.error.getNullClaimsTokenErrObj");
   var errorObj = {};
   errorObj.opstatus = kony.sdk.errorcodes.cliams_token_null
   errorObj.message = kony.sdk.errormessages.cliams_token_null
   errorObj.details = {};
   errorObj.mfcode = "";
   return errorObj;
 }
 kony.sdk.error.getIdentitySessionInactiveErrObj = function() {
   kony.sdk.logsdk.trace("Entering into kony.sdk.error.getIdentitySessionInactiveErrObj");
   var errorObj = {};
   errorObj.opstatus = kony.sdk.errorcodes.identity_session_inactive
   errorObj.message = kony.sdk.errormessages.identity_session_inactive
   errorObj.details = {};
   errorObj.mfcode = "";
   return errorObj;
 }
 kony.sdk.error.getNullRefreshTokenErrObj = function() {
   kony.sdk.logsdk.trace("Entering into kony.sdk.error.getNullRefreshTokenErrObj");
   var errorObj = {};
   errorObj.opstatus = kony.sdk.errorcodes.invalid_session_or_token_expiry
   errorObj.message = kony.sdk.errormessages.invalid_session_or_token_expiry
   errorObj.details = {};
   errorObj.mfcode = "";
   return errorObj;
 }
 kony.sdk.error.getIntegrationErrObj = function(errResponse) {
   kony.sdk.logsdk.trace("Entering into kony.sdk.error.getIntegrationErrObj");
   try {
     var mfcode = errResponse[kony.sdk.constants.MF_CODE];
     var message = errResponse[kony.sdk.constants.MF_ERROR_MSG];
     var details = errResponse["mferrmsg"];
     var service = errResponse[kony.sdk.constants.MF_SERVICE];
     if (!service) {
       service = "";
     }
     if (!details) {
       details = "";
     }
     var errorMessagePrefixForIntegration = "";
     if (service) {
       errorMessagePrefixForIntegration = "Integration Service Request Failed for " + service + ":";
     } else {
       errorMessagePrefixForIntegration = "Integration Service Request Failed:";
     }
     if (mfcode) {
       return kony.sdk.error.getMFcodeErrObj(mfcode, message, details, errorMessagePrefixForIntegration);
     }
     return errResponse;
   } catch (err) {
     return errResponse;
   }
 }
 kony.sdk.error.getLogicErrObj = function(errResponse) {
   kony.sdk.logsdk.trace("Entering into kony.sdk.error.getLogicErrObj");
   try {
     var mfcode = errResponse[kony.sdk.constants.MF_CODE];
     var message = errResponse[kony.sdk.constants.MF_ERROR_MSG];
     var details = errResponse["mferrmsg"];
     var service = errResponse[kony.sdk.constants.MF_SERVICE];
     if (!service) {
       service = "";
     }
     if (!details) {
       details = "";
     }
     var errorMessagePrefixForLogic = "";
     if (service) {
       errorMessagePrefixForLogic = "Logic Service Request Failed for " + service + ":";
     } else {
       errorMessagePrefixForLogic = "Logic Service Request Failed:";
     }
     if (mfcode) {
       return kony.sdk.error.getMFcodeErrObj(mfcode, message, details, errorMessagePrefixForLogic);
     }
     return errResponse;
   } catch (err) {
     return errResponse;
   }
 }
 kony.sdk.error.getMFcodeErrObj = function(mfcode, message, details, errMessagePrefix) {
   kony.sdk.logsdk.trace("Entering into kony.sdk.error.getMFcodeErrObj");
   var errorObj = {};
   errorObj.details = {};
   if (details) {
     errorObj.details = details;
   }
   errorObj.mfcode = mfcode;
   if (mfcode === "Auth-4") {
     if (!message) {
       message = kony.sdk.errormessages.invalid_user_credentials
     }
     errorObj.opstatus = kony.sdk.errorcodes.invalid_user_credentials
     errorObj.message = errMessagePrefix + message;
   } else if (mfcode === "Auth-9") {
     if (!message) {
       message = kony.sdk.errormessages.invalid_app_credentials
     }
     errorObj.opstatus = kony.sdk.errorcodes.invalid_app_credentials
     errorObj.message = errMessagePrefix + message;
   } else if (mfcode === "Auth-3") {
     if (!message) {
       message = kony.sdk.errormessages.invalid_user_app_credentials
     }
     errorObj.opstatus = kony.sdk.errorcodes.invalid_user_app_credentials
     errorObj.message = errMessagePrefix + message;
   } else if ((mfcode === "Auth-5") || (mfcode === "Auth-6") || (mfcode === "Gateway-31") || (mfcode === "Gateway-33") || (mfcode === "Gateway-35") || (mfcode === "Gateway-36") || (mfcode === "Auth-46") || (mfcode === "Auth-55")) {
     errorObj.opstatus = kony.sdk.errorcodes.invalid_session_or_token_expiry
     errorObj.message = errMessagePrefix + kony.sdk.errormessages.invalid_session_or_token_expiry
   } else if (mfcode === "Auth-7" || mfcode === "Auth-27") {
     if (!message) {
       message = errMessagePrefix + kony.sdk.errormessages.invalid_user_app_services
     }
     errorObj.opstatus = kony.sdk.errorcodes.invalid_user_app_services
     errorObj.message = message;
   } else if (mfcode === "Auth-128") {
     errorObj.message = kony.sdk.errormessages.invalid_pkce_params;
     errorObj.opstatus = kony.sdk.errorcodes.invalid_pkce_params;
   } else if (mfcode === "Auth-129") {
     errorObj.details.errmsg = kony.sdk.errormessages.CORS_disabled_at_identity;
     errorObj.details.message = kony.sdk.errormessages.CORS_disabled_at_identity;
     errorObj.message = kony.sdk.errormessages.CORS_disabled_at_identity
     errorObj.opstatus = kony.sdk.errorcodes.CORS_disabled_at_identity;
   } else {
     errorObj.opstatus = kony.sdk.errorcodes.default_code
     errorObj.message = errMessagePrefix + kony.sdk.errormessages.default_message
   }
   return errorObj;
 }

 function getAuthErrorMessage(mfcode) {
   kony.sdk.logsdk.trace("Entering into getAuthErrorMessage");
   if (mfcode === "Auth-4") {
     return kony.sdk.errormessages.invalid_user_credentials
   } else if (mfcode === "Auth-9") {
     return kony.sdk.errormessages.invalid_app_credentials
   } else if (mfcode === "Auth-3") {
     return kony.sdk.errormessages.invalid_user_app_credentials
   } else if ((mfcode === "Auth-5") || (mfcode === "Auth-6") || (mfcode === "Gateway-31") || (mfcode === "Gateway-33") || (mfcode === "Gateway-35") || (mfcode === "Gateway-36") || (mfcode === "Auth-46") || (mfcode === "Auth-55")) {
     return kony.sdk.errormessages.invalid_session_or_token_expiry
   } else if (mfcode === "Auth-7" || mfcode === "Auth-27") {
     return kony.sdk.errormessages.invalid_user_app_services
   } else {
     return mfcode + ":" + kony.sdk.errormessages.default_message
   }
 }
 kony.sdk.error.getSingleWindowLoginErrObj = function(errorCode, errorMessage) {
   var errorObject = {};
   errorObject[kony.sdk.constants.KEY_CODE] = errorCode;
   errorObject[kony.sdk.constants.KEY_MESSAGE] = errorMessage;
   return errorObject;
 }
 kony.sdk.error.getErrObj = function(errorCode, errorMessage) {
   var err = {};
   err[kony.sdk.constants.KEY_CODE] = errorCode;
   err[kony.sdk.constants.KEY_MESSAGE] = errorMessage;
   return err;
 }
 kony.sdk.error.getObjectServiceErrObj = function(errResponse) {
   kony.sdk.logsdk.trace("Entering into kony.sdk.error.getObjectServiceErrObj");
   try {
     var mfcode = errResponse[kony.sdk.constants.MF_CODE];
     var message = errResponse[kony.sdk.constants.MF_ERROR_MSG];
     var details = errResponse["mferrmsg"];
     var service = errResponse[kony.sdk.constants.MF_SERVICE];
     if (!service) {
       service = "";
     }
     if (!details) {
       details = "";
     }
     var errorMessagePrefixForIntegration = "";
     if (service) {
       errorMessagePrefixForIntegration = "Object Service Request Failed for " + service + ":";
     } else {
       errorMessagePrefixForIntegration = "Object Service Request Failed:";
     }
     if (mfcode) {
       return kony.sdk.error.getMFcodeErrObj(mfcode, message, details, errorMessagePrefixForIntegration);
     }
     return errResponse;
   } catch (err) {
     return errResponse;
   }
 }
 kony.sdk.error.getClientErrObj = function(errCode, errMsg) {
   kony.sdk.logsdk.trace("Entering into kony.sdk.error.getClientErrObj");
   var errObj = new Object();
   errObj.opstatus = kony.sdk.errorcodes.clientvalidation_error_opstatus;
   errObj.errmsg = errMsg;
   errObj.errcode = errCode;
   return errObj;
 }
 kony.sdk.error.getMessagingError = function(errMsg) {
   kony.sdk.logsdk.trace("Entering into kony.sdk.error.getMessagingError");
   var errObj = new Object();
   errObj.opstatus = kony.sdk.errorcodes.messaging_service_fail;
   errObj.errmsg = kony.sdk.errormessages.messaging_service_fail + errMsg;
   errObj.errcode = kony.sdk.errorcodes.messaging_service_fail;
   return errObj;
 }
 kony.sdk.error.getConfigServiceErrObject = function(errResponse) {
   kony.sdk.logsdk.trace("Entering into kony.sdk.error.getConfigServiceErrObject");
   try {
     var mfcode = errResponse[kony.sdk.constants.MF_CODE];
     var message = errResponse[kony.sdk.constants.MF_ERROR_MSG];
     var details = errResponse["mferrmsg"];
     var service = errResponse[kony.sdk.constants.MF_SERVICE];
     if (!service) {
       service = "";
     }
     if (!details) {
       details = "";
     }
     var errorMessagePrefixForIntegration = "";
     if (service) {
       errorMessagePrefixForIntegration = "Configuration Service Request Failed for " + service + ":";
     } else {
       errorMessagePrefixForIntegration = "Configuration Service Request Failed:";
     }
     if (mfcode) {
       return kony.sdk.error.getMFcodeErrObj(mfcode, message, details, errorMessagePrefixForIntegration);
     }
     return errResponse;
   } catch (err) {
     return errResponse;
   }
 };
 kony.sdk.error.getIntegrityErrorMessage = function(httpRequest, url) {
   kony.sdk.logsdk.trace("Entering into kony.sdk.error.getIntegrityErrorMessage");
   var errorMessage = {};
   errorMessage.httpresponse = {};
   errorMessage[kony.sdk.constants.MF_OPSTATUS] = kony.sdk.errorcodes.integrity_check_failed;
   errorMessage[kony.sdk.constants.MF_ERROR_MSG] = kony.sdk.errormessages.integrity_check_failed;
   errorMessage[kony.sdk.constants.MF_ERROR_CODE] = kony.sdk.errorcodes.integrity_check_failed;
   errorMessage[kony.sdk.constants.HTTP_STATUS_CODE] = httpRequest.status.toString();
   errorMessage.httpresponse["response"] = httpRequest.response;
   errorMessage.httpresponse.headers = httpRequest.getAllResponseHeaders();
   errorMessage.httpresponse.url = url;
   errorMessage.httpresponse.responsecode = httpRequest.status.toString();
   return errorMessage;
 };
 kony.sdk.error.getOperationFailedErrorMessage = function(httpRequest, url) {
   kony.sdk.logsdk.trace("Entering into kony.sdk.error.getOperationFailedErrorMessage");
   var errorMessage = {};
   errorMessage[kony.sdk.constants.MF_OPSTATUS] = httpRequest.response.opstatus;
   errorMessage[kony.sdk.constants.MF_ERROR_MSG] = kony.sdk.errormessages.server_operation_failed;
   errorMessage[kony.sdk.constants.MF_ERROR_CODE] = kony.sdk.errorcodes.server_operation_failed;
   errorMessage[kony.sdk.constants.HTTP_STATUS_CODE] = httpRequest.status.toString();
   var httpResponse = {};
   httpResponse.response = httpRequest.response;
   httpResponse.headers = httpRequest.getAllResponseHeaders();
   httpResponse.responsecode = httpRequest.status.toString();
   httpResponse.url = url;
   errorMessage.httpResponse = httpResponse;
   return errorMessage;
 };
 if (typeof(kony.sdk) === "undefined") {
   kony.sdk = {};
 }
 if (typeof(kony.sdk.errorcodes) === "undefined") {
   kony.sdk.errorcodes = {};
 }
 if (typeof(kony.sdk.errormessages) === "undefined") {
   kony.sdk.errormessages = {};
 }
 kony.sdk.errorcodes.invalid_user_credentials = 101;
 kony.sdk.errormessages.invalid_user_credentials = "Invalid User Credentials.";
 kony.sdk.errorcodes.invalid_app_credentials = 102;
 kony.sdk.errormessages.invalid_app_credentials = "Invalid App Credentials.";
 kony.sdk.errorcodes.invalid_user_app_credentials = 103;
 kony.sdk.errormessages.invalid_user_app_credentials = "Invalid User/App Credentials.";
 kony.sdk.errorcodes.invalid_session_or_token_expiry = 104;
 kony.sdk.errormessages.invalid_session_or_token_expiry = "Session/Token got invalidated in the backend.Please login.";
 kony.sdk.errorcodes.invalid_user_app_services = 105;
 kony.sdk.errormessages.invalid_user_app_services = "Invalid provider in appServices.";
 kony.sdk.errorcodes.cliams_token_null = 106;
 kony.sdk.errormessages.cliams_token_null = "Claims Token is Unavialable";
 kony.sdk.errorcodes.identity_session_inactive = 107;
 kony.sdk.errormessages.identity_session_inactive = "Identity Provider's sessions is not active. Please login";
 kony.sdk.errorcodes.refresh_login_tokens_null_or_undefined = 108;
 kony.sdk.errormessages.refresh_login_tokens_null_or_undefined = "Required refresh tokens to enable refresh login are null or undefined";
 kony.sdk.errorcodes.app_verifier_save_failed = 109;
 kony.sdk.errormessages.app_verifier_save_failed = "Unable to store app verifier at middleware server";
 kony.sdk.errorcodes.app_verifier_retrieve_failed = 110;
 kony.sdk.errormessages.app_verifier_retrieve_failed = "Unable to retrieve app verifier from middleware server";
 kony.sdk.errorcodes.invalid_custom_data_save_handle = 111;
 kony.sdk.errormessages.invalid_custom_data_save_handle = "CustomDataSaveHandle should be function and should " + "accept successCallback and failureCallback";
 kony.sdk.errorcodes.custom_data_save_handle_failed = 112;
 kony.sdk.errormessages.custom_data_save_handle_failed = "CustomDataSaveHandle failed by user";
 kony.sdk.errorcodes.partial_login_error = 113;
 kony.sdk.errormessages.partial_login_error = "The application was launched with code query param but is not a continued login process";
 kony.sdk.errorcodes.CORS_disabled_at_identity = 114;
 kony.sdk.errormessages.CORS_disabled_at_identity = "Login Failed. PKCE parameters are missing, please check if CORS setting is properly configured in Fabric Identity";
 kony.sdk.errorcodes.invalid_pkce_params = 115;
 kony.sdk.errormessages.invalid_pkce_params = "Invalid PKCE params";
 kony.sdk.errorcodes.invalid_appconfig = 116;
 kony.sdk.errormessages.invalid_appconfig = "Appconfig is null or undefined.";
 kony.sdk.errorcodes.error_no_metadata_found = 117;
 kony.sdk.errormessages.error_no_metadata_found = "No metadata was found to continue with single window login";
 kony.sdk.errorcodes.invalid_auth_code = 118;
 kony.sdk.errormessages.invalid_auth_code = "No Auth Code found in the Url.";
 kony.sdk.errorcodes.pkce_params_generation_failed = 119;
 kony.sdk.errormessages.pkce_params_generation_failed = "Login Failed. Error occured while generating PKCE parameters.";
 kony.sdk.errorcodes.default_code = 100;
 kony.sdk.errormessages.default_message = "UnhandledMFcode";
 kony.sdk.errorcodes.unknown_error_code = 1000;
 kony.sdk.errormessages.unknown_error_message = "An unknown error has occured";
 kony.sdk.errorcodes.connectivity_error_code = 1011;
 kony.sdk.errormessages.connectivity_error_message = "An error occurred while making the request. Please check device connectivity, server url and request parameters";
 kony.sdk.errorcodes.invalid_json_code = 1013;
 kony.sdk.errormessages.invalid_json_message = "Invalid Json response was returned";
 kony.sdk.errorcodes.request_timed_out_code = 1014;
 kony.sdk.errormessages.request_timed_out_message = "Request to server has timed out";
 kony.sdk.errorcodes.offline_auth_failed = 1015;
 kony.sdk.errormessages.offline_auth_failed = "Offline Authentication failed, User should atleast login once when network connectivity is available.";
 kony.sdk.errorcodes.servicedoc_unavailable = 1016;
 kony.sdk.errormessages.servicedoc_unavailable = "MBAAS app is not initialized properly. Service document is unavailable.";
 kony.sdk.errorcodes.transient_login_fail = 1017;
 kony.sdk.errormessages.transient_login_fail = "Transient Login failed, Previous Identity Token expired in backend.";
 kony.sdk.errorcodes.messaging_service_fail = 1018;
 kony.sdk.errormessages.messaging_service_fail = "Failure in Messaging Service. ";
 kony.sdk.errorcodes.integrity_check_failed = 1019;
 kony.sdk.errormessages.integrity_check_failed = "Http message Body Integrity Check failed.";
 kony.sdk.errorcodes.invalid_security_key = 1023;
 kony.sdk.errormessages.invalid_security_key = "Security key should be a non empty string.";
 kony.sdk.errorcodes.server_operation_failed = 1020;
 kony.sdk.errormessages.server_operation_failed = "Operation Failed on server";
 kony.sdk.errorcodes.populating_template_failed = 1021;
 kony.sdk.errormessages.populating_template_failed = "Template population failed, template parameters are invalid or template is malformed";
 kony.sdk.errorcodes.service_unavailable = 1022;
 kony.sdk.errormessages.service_unavailable_message = "Service unavailable or cannot connect to host";
 kony.sdk.errorcodes.connection_timeout = 1023;
 kony.sdk.errormessages.connection_timeout_message = "Network call failed due to connection timeout";
 kony.sdk.errorcodes.clientvalidation_error_opstatus = 112233;
 //Invaild API's for phonegap and plain-js
 kony.sdk.errorcodes.invalid_api = 7000;
 kony.sdk.errormessages.invalid_api = "Invalid Operation name, Operation Failed.";
 //Object Service Error Messages
 kony.sdk.errorcodes.invalid_dataobject_instance = 90001;
 kony.sdk.errormessages.invalid_dataobject_instance = "Provided dataobject is invalid and should be instance of kony.sdk.dto.DataObject";
 kony.sdk.errorcodes.primarykey_unavailable = 90002;
 kony.sdk.errormessages.primarykey_unavailable = "Primary Keys missing, Operation Failed";
 kony.sdk.errorcodes.null_or_undefined = 90003;
 kony.sdk.errormessages.null_or_undefined = " cannot be null or undefined";
 kony.sdk.errorcodes.transaction_failed = 90004;
 kony.sdk.errormessages.transaction_failed = "Some error occurred, Operation Failed";
 kony.sdk.errorcodes.norecords_to_delete = 90005;
 kony.sdk.errormessages.norecords_to_delete = "No records deleted with the specified criteria";
 kony.sdk.errorcodes.invalid_queryparams_instance = 90006;
 kony.sdk.errormessages.invalid_queryparams_instance = "Provided queryParams is invalid and should be a json object";
 kony.sdk.errorcodes.invalid_params_instance = 90007;
 kony.sdk.errormessages.invalid_params_instance = "Provided params are invalid";
 kony.sdk.errorcodes.invalid_object = 90008;
 kony.sdk.errormessages.invalid_object = "Invalid object name, Operation Failed.";
 kony.sdk.errorcodes.invalid_blob = 90009;
 kony.sdk.errormessages.invalid_blob = "Failed to read from binary file, either the file does not exist or invalid";
 kony.sdk.errorConstants = {
   INIT_FAILURE: "INIT_FAILURE",
   DATA_STORE_EXCEPTION: "DATASTORE_FAILURE",
   AUTH_FAILURE: "AUTH_FAILURE",
   INTEGRATION_FAILURE: "INTEGRATION_FAILURE",
   MESSAGING_FAILURE: "MESSAGING_FAILURE",
   SYNC_FAILURE: "SYNC_FAILURE",
   METRICS_FAILURE: "METRICS_FAILURE",
   MISC_FAILURE: "MISCELLANEOUS_FAILURE",
   OBJECT_FAILURE: "OBJECT_FAILURE",
   LOGIC_SERVICE_FAILURE: "LOGIC_SERVICE_FAILURE",
   SYNC_V2_FAILURE: "SYNC_V2_FAILURE",
   CONFIGURATION_URL_FAILURE: "CONFIGURATION_URL_FAILURE",
   CONFIGURATION_FAILURE: "CONFIGURATION_FAILURE",
   INTEGRITY_FAILURE: "INTEGRITY_FAILURE",
   INVALID_API_FAILURE: "INVALID_API_FAILURE"
 };
 kony.sdk.offline = kony.sdk.offline || {};
 kony.sdk.sso = kony.sdk.sso || {};
 kony.sdk.pkceUtilityInstance = null;
 kony.sdk.isSSOLoginSuccess = kony.sdk.isSSOLoginSuccess || true;
 kony.sdk.customOAuthParmsForClaimsAndBackendTokenRefresh = {};
 /**
  * This method will complete OAuth login in plainJS
  * @param successCallback
  * @param failureCallback
  */
 kony.sdk.performNoPopUpLogin = function(successCallback, failureCallback) {
   var metaDataManagerForLoginInSameWindow = kony.sdk.util.getMetaDataManagerForLoginInSameWindow();
   metaDataManagerForLoginInSameWindow.initialize();
   metaDataManagerForLoginInSameWindow.loadSavedMetaData();
   var appConfigString = metaDataManagerForLoginInSameWindow.getItem(kony.sdk.constants.KEY_APPCONFIG_FOR_SINGLE_WINDOW_LOGIN);
   var url = window.location.href;
   var queryParamsAsString = url.split("?")[1];
   var codeValue = null;
   if (!kony.sdk.isNullOrUndefined(queryParamsAsString) && queryParamsAsString.indexOf(kony.sdk.constants.DEEPLINK_VALID_PARAM + kony.sdk.constants.EQUAL_TO) !== -1) {
     var queryParamsAsArray = queryParamsAsString.split('&');
     for (var index = 0; index < queryParamsAsArray.length; index++) {
       var keyValueAsArray = queryParamsAsArray[index].split(kony.sdk.constants.EQUAL_TO);
       if (keyValueAsArray[0] === kony.sdk.constants.DEEPLINK_VALID_PARAM) {
         codeValue = keyValueAsArray[1];
         break;
       }
     }
   }
   kony.application.removeQueryParamsByKey(kony.sdk.constants.DEEPLINK_VALID_PARAM);
   if (!kony.sdk.isNullOrUndefined(appConfigString) && kony.sdk.isJson(appConfigString)) {
     appConfig = JSON.parse(appConfigString);
     var sdkInstance = new kony.sdk();
     sdkInstance.initWithServiceDoc(appConfig.appKey, appConfig.appSecret, appConfig.svcDoc);
     if (!kony.sdk.isNullOrUndefined(codeValue)) {
       kony.sdk.logsdk.info("kony.sdk.performNoPopUpLogin: Auth Code found in url, completing single window login.");
       kony.sdk.completeSingleWindowLogin(codeValue, validateAndInvokeCallback);
     } else {
       // Invoking failureCallback only when code is null and single window login is still in progress.
       // Checking the status of single window login from metadata.
       kony.sdk.logsdk.error("kony.sdk.performNoPopUpLogin: No Auth Code found in Url.");
       var errorObject = kony.sdk.error.getSingleWindowLoginErrObj(kony.sdk.errorcodes.invalid_auth_code, kony.sdk.errormessages.invalid_auth_code);
       metaDataManagerForLoginInSameWindow.destroy();
       kony.sdk.verifyAndCallClosure(failureCallback, errorObject);
     }
   } else {
     if (!kony.sdk.isNullOrUndefined(codeValue)) {
       // Invoking failureCallback when code is NOT null and metadata is NOT found.
       kony.sdk.logsdk.error("kony.sdk.performNoPopUpLogin: No metadata found.");
       var errorObject = kony.sdk.error.getSingleWindowLoginErrObj(kony.sdk.errorcodes.invalid_appconfig, kony.sdk.errormessages.invalid_appconfig);
       metaDataManagerForLoginInSameWindow.destroy();
       kony.sdk.verifyAndCallClosure(failureCallback, errorObject);
     } else {
       metaDataManagerForLoginInSameWindow.destroy();
     }
   }

   function validateAndInvokeCallback(res) {
     if (!kony.sdk.isNullOrUndefined(res)) {
       if (!res.isError) {
         kony.sdk.logsdk.info("kony.sdk.performNoPopUpLogin: Single window login completed successfully.");
         kony.sdk.verifyAndCallClosure(successCallback, res[kony.sdk.constants.LOGIN_RESPONSE]);
       } else {
         kony.sdk.logsdk.error("kony.sdk.performNoPopUpLogin: Single window login failed with error : " + JSON.stringify(res));
         kony.sdk.verifyAndCallClosure(failureCallback, res[kony.sdk.constants.LOGIN_RESPONSE]);
       }
     } else {
       kony.sdk.logsdk.error("kony.sdk.performNoPopUpLogin: Single window login failed.");
       kony.sdk.verifyAndCallClosure(failureCallback);
     }
   }
 }
 /**
  * This function will resume the oauth2 login process after oauth code retrieval part.
  * This function takes auth code as input and will call loginCompleteCallback with appropriate repsonse
  * @param code
  * @param loginCompleteCallback
  */
 kony.sdk.completeSingleWindowLogin = function(code, loginCompleteCallback) {
   kony.sdk.logsdk.info("Entering completeSingleWindowLogin");
   kony.application.removeQueryParamsByKey(kony.sdk.constants.DEEPLINK_VALID_PARAM);
   if (kony.sdk.isNullOrUndefined(code)) {
     kony.sdk.logsdk.info("code is undefined");
     return loginCompleteCallback();
   }
   var bodyParams = {};
   var loginOptions = null;
   var metaDataManagerForLoginInSameWindow = kony.sdk.util.getMetaDataManagerForLoginInSameWindow();

   function performTokenCall(networkResponseJSON) {
     kony.sdk.logsdk.info("Entering performTokenCall");
     if (is_enable_identity_pkce === true && !kony.sdk.isNullOrUndefined(networkResponseJSON[kony.sdk.constants.APP_VERIFIER])) {
       bodyParams[kony.sdk.constants.APP_VERIFIER] = networkResponseJSON[kony.sdk.constants.APP_VERIFIER];
     }
     bodyParams[kony.sdk.constants.DEEPLINK_VALID_PARAM] = code;
     delete loginOptions[kony.sdk.constants.NO_POP_UP]; //avoiding circular logins
     //make login
     var options = {};
     options[kony.sdk.constants.LOGIN_OPTIONS] = loginOptions;
     options[kony.sdk.constants.SINGLE_WINDOW_LOGIN_BODY_PARAMS] = bodyParams; //this param will tell us to by pass auth code process
     var provider = metaDataManagerForLoginInSameWindow.getItem(kony.sdk.constants.KEY_PROVIDER);
     var sdkInstance = kony.sdk.getDefaultInstance();
     var identityInstance = sdkInstance.getIdentityService(provider);
     identityInstance.login(options, successCallback, failureCallback);
   }

   function successCallback(successResponse) {
     var successLoginResponse = {};
     successLoginResponse[kony.sdk.constants.IS_ERROR] = false;
     successLoginResponse[kony.sdk.constants.LOGIN_RESPONSE] = successResponse;
     kony.sdk.logsdk.info("Exiting completeSingleWindowLogin with success");
     kony.sdk.verifyAndCallClosure(loginCompleteCallback, successLoginResponse)
   }

   function failureCallback(errorObject) {
     var errorLoginResponse = {};
     errorLoginResponse[kony.sdk.constants.IS_ERROR] = true;
     errorLoginResponse[kony.sdk.constants.LOGIN_RESPONSE] = errorObject;
     metaDataManagerForLoginInSameWindow.destroy();
     kony.sdk.logsdk.info("Exiting completeSingleWindowLogin with failure");
     kony.sdk.verifyAndCallClosure(loginCompleteCallback, errorLoginResponse)
   }
   metaDataManagerForLoginInSameWindow.initialize();
   metaDataManagerForLoginInSameWindow.loadSavedMetaData(); //gets the saved data from local
   loginOptions = metaDataManagerForLoginInSameWindow.getItem(kony.sdk.constants.LOGIN_OPTIONS);
   is_enable_identity_pkce = metaDataManagerForLoginInSameWindow.getItem(kony.sdk.constants.ENABLE_IDENTITY_PKCE);
   if (kony.sdk.isNullOrUndefined(loginOptions)) {
     kony.sdk.logsdk.error(kony.sdk.errormessages.partial_login_error);
     var errorObject = kony.sdk.error.getSingleWindowLoginErrObj(kony.sdk.errorcodes.partial_login_error, kony.sdk.errormessages.partial_login_error);
     kony.sdk.verifyAndCallClosure(failureCallback, errorObject);
     return;
   }
   if (is_enable_identity_pkce === true) {
     metaDataManagerForLoginInSameWindow.retrieveAppVerifier(performTokenCall, failureCallback);
   } else {
     performTokenCall({});
   }
 }
 /**
  * Method to create the Identity service instance with the provided provider name.
  * @param {string} providerName - Name of the provider
  * @returns {IdentityService} Identity service instance
  */
 kony.sdk.prototype.getIdentityService = function(providerName) {
   kony.sdk.logsdk.perf("Executing kony.sdk.prototype.getIdentityService");
   if (!kony.sdk.isInitialized) {
     throw new Exception(kony.sdk.errorConstants.INIT_FAILURE, kony.sdk.constants.INIT_FAILURE_MESSAGE + " Identity service.");
   }
   var provider = null;
   if (providerName) {
     if (this.login != null) {
       for (var i = 0; i < this.login.length; i++) {
         var rec = this.login[i];
         if ((rec.alias && rec.alias.toUpperCase() === providerName.toUpperCase()) || (rec.prov.toUpperCase() === providerName.toUpperCase())) {
           provider = new IdentityService(this, rec);
           break;
         }
       }
       if (provider === null) {
         throw new Exception(kony.sdk.errorConstants.AUTH_FAILURE, "Invalid providerName");
       }
       //TODO: what if the providerName is not passed by the user? 
       kony.sdk.logsdk.perf("Executing Finished kony.sdk.prototype.getIdentityService");
       kony.sdk.logsdk.debug("### auth:: returning authService for providerName = " + provider.getProviderName());
       return provider;
     }
   } else {
     throw new Exception(kony.sdk.errorConstants.AUTH_FAILURE, "Invalid providerName");
   }
 };
 /**
  * Should not be called by the developer.
  * @class
  * @classdesc Identity service instance for handling login/logout calls.
  */
 function IdentityService(konyRef, rec) {
   kony.sdk.logsdk.perf("Executing IdentityService");
   var networkProvider = new konyNetworkProvider();
   var dataStore = new konyDataStore();
   var serviceObj = rec;
   konyRef.rec = rec;
   var is_mfa_enabled = false;
   if (!kony.sdk.isNullOrUndefined(rec[kony.sdk.constants.IS_MFA_ENABLED])) {
     is_mfa_enabled = rec[kony.sdk.constants.IS_MFA_ENABLED];
   }
   var mfa_meta = {};
   if (!kony.sdk.isNullOrUndefined(rec[kony.sdk.constants.MFA_META])) {
     mfa_meta = rec[kony.sdk.constants.MFA_META];
   }
   var mainRef = konyRef.mainRef;
   var user_attributes = {};
   var offlineEnabled = false;
   var persistToken = false;
   if (serviceObj === undefined || serviceObj.prov == undefined || serviceObj.type == undefined) {
     throw new Exception(kony.sdk.errorConstants.INIT_FAILURE, "Invalid service url and service type");
   }
   var _type = serviceObj.type;
   var _serviceUrl = stripTrailingCharacter(serviceObj.url, "/");
   var _providerName = serviceObj.prov;
   var is_enable_identity_pkce = serviceObj.enable_identity_pkce === true;
   //refresh login changes
   var refreshLoginEnabled = false;
   var refreshLoginTokenStoreUtilityObject = kony.sdk.util.getRefreshLoginTokenStoreUtility();
   var metaDataManagerForLoginInSameWindow = kony.sdk.util.getMetaDataManagerForLoginInSameWindow();
   var providerType = rec[kony.sdk.constants.LOGIN_PROVIDER_TYPE];
   kony.sdk.logsdk.debug("### AuthService:: initialized for provider " + _providerName + " with type " + _type);

   function isLoggedIn() {
     if (kony.sdk.getCurrentInstance() && kony.sdk.getCurrentInstance().tokens && kony.sdk.getCurrentInstance().tokens.hasOwnProperty(_providerName) && !kony.sdk.isNullOrUndefined(kony.sdk.getCurrentInstance().tokens[_providerName]) && Object.keys(kony.sdk.getCurrentInstance().tokens[_providerName]).length !== 0) {
       return true;
     }
     return false;
   }
   var dsKey = _serviceUrl + "::" + _providerName + "::" + _type + "::RAW";

   function resetAllCurrentTokens(konyRef, _providerName) {
     kony.sdk.resetProviderKeys(konyRef, _providerName);
   }
   /**
    * Register / Sign-Up a new user asynchronously and executes the given callback.
    * @param {object} params - Userid, password, firstName, lastname, phone)
    * e.g. {
    *     "userid":"john.doe@abc.com",
    *     "password":"Qwerty@123"'
    *		"first_name":"John",
    *		"last_name":"Doe",
    *		"phone":"1234569870"		// Phone- Not mandatory
    * }
    * @param {function} successCallback  - Callback method on success
    * @param {function} failureCallback - Callback method on failure
    * @param {object} options
    */
   this.register = function(params, successCallback, failureCallback, options) {
     kony.sdk.logsdk.perf("Executing Register");

     function invokeAjaxCall(url, params, headers) {
       headers = kony.sdk.addDefaultHeaders(headers);
       headers[kony.sdk.constants.KONY_AUTHORIZATION_HEADER] = konyRef.currentClaimToken;
       headers[kony.sdk.constants.APP_KEY_HEADER] = mainRef.appKey;
       headers[kony.sdk.constants.APP_SECRET_HEADER] = mainRef.appSecret;
       headers[kony.sdk.constants.SDK_TYPE_HEADER] = kony.sdk.getSdkType();
       headers[kony.sdk.constants.SDK_VERSION_HEADER] = kony.sdk.version;
       headers[kony.sdk.constants.PLATFORM_TYPE_HEADER] = kony.sdk.getPlatformName();
       headers[kony.sdk.constants.HTTP_REQUEST_HEADER_ACCEPT] = kony.sdk.constants.CONTENT_TYPE_JSON;
       headers[kony.sdk.constants.HTTP_CONTENT_HEADER] = kony.sdk.constants.CONTENT_TYPE_FORM_URL_ENCODED;
       populateHeaderWithFabricAppVersion(headers);
       if (konyRef.reportingheaders_allowed) {
         if (!kony.sdk.isNullOrUndefined(reportingData)) {
           headers[kony.sdk.constants.REPORTING_HEADER] = reportingData;
         }
       }
       var networkOptions = kony.sdk.util.checkAndFetchNetworkProviderOptions(options, false);
       networkProvider.post(url, params, headers, localSuccessCallback, localFailureCallback, null, networkOptions);
     }

     function localFailureCallback(error) {
       kony.sdk.logsdk.perf("Register finished with Failure");
       kony.sdk.verifyAndCallClosure(failureCallback, error);
     }

     function localSuccessCallback(data) {
       kony.sdk.logsdk.perf("Register finished with Success");
       var response = {};
       response["status"] = data.status;
       kony.sdk.verifyAndCallClosure(successCallback, response);
     }
     kony.sdk.logsdk.debug("### AuthService:: Invoked Register call  for provider " + _providerName);
     var reportingData = null;
     if (kony.sdk.isNullOrUndefined(params)) {
       throw new Exception(kony.sdk.errorConstants.AUTH_FAILURE, "Missing required params to register function");
     }

     function invokeSignUp() {
       var endPointUrl = _serviceUrl + "/signup/register?provider=" + _providerName;
       reportingData = kony.sdk.getEncodedReportingParamsForSvcid("register_" + _providerName);
       params["provider"] = _providerName;
       invokeAjaxCall(endPointUrl, params, null);
     }
     kony.sdk.claimsRefresh(invokeSignUp, failureCallback);
   };

   function genericPostLoginSuccessCallback(networkResponse, successCallback) {
     var response = processLoginSuccessResponse(networkResponse, konyRef, false);
     if (!kony.sdk.isNullOrUndefined(response.mfa_response) && !kony.sdk.isNullOrUndefined(response.mfa_response[kony.sdk.constants.IS_MFA_ENABLED])) {
       is_mfa_enabled = response.mfa_response[kony.sdk.constants.IS_MFA_ENABLED];
       mfa_meta = response.mfa_response[kony.sdk.constants.MFA_META];
       delete response.mfa_response;
     }

     function serviceDocCallback() {
       //if refresh login is enabled, store the required internal refresh and backend refresh tokens in data store
       if (refreshLoginEnabled) {
         konyRef.refreshLoginProvidersSet.add(_providerName);
         storeRefreshLoginTokens(networkResponse);
       }
       kony.sdk.verifyAndCallClosure(successCallback, response);
     }
     /**
      * This function checks whether the required refresh tokens exist as part of login response
      * @param {Object} data - containing login response containing security attributes as well
      * @returns {boolean} - true if the required refresh tokens available to make refresh login else false
      */
     function areRequiredRefreshTokensForRefreshLoginAvailable(data) {
       if (kony.sdk.isNullOrUndefined(konyRef.currentRefreshToken) || kony.sdk.isNullOrUndefined(data[kony.sdk.constants.BACKEND_REFRESH_TOKENS]) || kony.sdk.isNullOrUndefined(data[kony.sdk.constants.BACKEND_REFRESH_TOKENS][_providerName])) {
         return false;
       }
       return true;
     }
     /**
      * This function stores backend and internal refresh tokens in data store for subsequent refresh login
      * @param data containing security attributes
      */
     function storeRefreshLoginTokens(data) {
       kony.sdk.logsdk.info("Entering storeRefreshLoginTokens");
       if (!areRequiredRefreshTokensForRefreshLoginAvailable(data)) {
         kony.sdk.logsdk.error("required refresh tokens doesn't exist in data store to enable refresh login");
         var errObject = kony.sdk.error.getClientErrObj(kony.sdk.errorcodes.refresh_login_tokens_null_or_undefined, kony.sdk.errormessages.refresh_login_tokens_null_or_undefined);
         //adding errObject to login response
         Object.assign(response, errObject);
         return;
       }
       var tokensData = {};
       tokensData[kony.sdk.constants.INTERNAL_REFRESH_TOKEN] = konyRef.currentRefreshToken;
       tokensData[kony.sdk.constants.BACKEND_REFRESH_TOKEN] = data[kony.sdk.constants.BACKEND_REFRESH_TOKENS][_providerName];
       kony.sdk.logsdk.info("storing provider specific internal and backend refresh tokens");
       refreshLoginTokenStoreUtilityObject.storeTokens(_providerName, tokensData);
       //setting the internal refresh token for current loggedin providers in data store based on login profiles
       if (!kony.sdk.isNullOrUndefined(data[kony.sdk.constants.LOGIN_PROFILES])) {
         var listOfLoginProfiles = Object.keys(data[kony.sdk.constants.LOGIN_PROFILES]);
         refreshLoginTokenStoreUtilityObject.setInternalRefreshToken(listOfLoginProfiles, konyRef.currentRefreshToken);
       }
     }
     getLatestServiceDocIfAvailable(networkResponse, serviceDocCallback);
   }
   /**
    * Login with the given credentials asynchronously and executes the given callback.
    * @param {object} options - User name and password
    * @param {function} successCallback  - Callback method on success
    * @param {function} failureCallback - Callback method on failure
    */
   this.login = function(options, successCallback, failureCallback) {
     kony.sdk.logsdk.perf("Executing Login");
     kony.sdk.pkceUtilityInstance = null;
     var continueOnRefreshError = true;
     var customQueryParamsForOAuth = null;
     var customOAuthParams = null;
     var isSingleWindowLoginEnabled = false;
     var customDaveSaveHandleFunction = null;

     function invokeAjaxCall(url, params, headers) {
       headers = kony.sdk.addDefaultHeaders(headers);
       kony.sdk.util.populateAuthorizationHeaderForLogin(headers, _providerName);
       if (kony.sdk.isNullOrUndefined(mainRef.appKey) || kony.sdk.isNullOrUndefined(mainRef.appSecret)) {
         var formID = "P:" + _type;
         var widgetID = "AK:" + mainRef.appKey + ",  AS:" + mainRef.appSecret;
         var flowTag = "Login Call";
         kony.sdk.util.recordAndFlushCustomEvent("INVALID APP CREDENTIALS", formID, widgetID, flowTag, null);
       }
       headers[kony.sdk.constants.APP_KEY_HEADER] = mainRef.appKey;
       headers[kony.sdk.constants.APP_SECRET_HEADER] = mainRef.appSecret;
       headers[kony.sdk.constants.SDK_TYPE_HEADER] = kony.sdk.getSdkType();
       headers[kony.sdk.constants.SDK_VERSION_HEADER] = kony.sdk.version;
       headers[kony.sdk.constants.PLATFORM_TYPE_HEADER] = kony.sdk.getPlatformName();
       headers[kony.sdk.constants.HTTP_REQUEST_HEADER_ACCEPT] = kony.sdk.constants.CONTENT_TYPE_JSON;
       headers[kony.sdk.constants.HTTP_CONTENT_HEADER] = kony.sdk.constants.CONTENT_TYPE_FORM_URL_ENCODED;
       populateHeaderWithFabricAppVersion(headers);
       //populating custom oAuth params
       if (providerType === kony.sdk.constants.AUTH_PROVIDER_TYPE_OAUTH2) {
         kony.sdk.util.populateCustomOAuthParams(params, customOAuthParams);
       }
       if (konyRef.reportingheaders_allowed) {
         // get reporting data for login operation
         var reportingData = kony.sdk.getEncodedReportingParamsForSvcid("login_" + _providerName);
         if (reportingData != null && reportingData != undefined) {
           try {
             headers[kony.sdk.constants.REPORTING_HEADER] = reportingData;
           } catch (error) {
             kony.sdk.logsdk.error("### login::error while parsing metrics payload" + error);
           }
         }
       }
       var endPointUrl = null;
       if (_type === "anonymous") {
         endPointUrl = _serviceUrl + url;
       } else {
         endPointUrl = _serviceUrl + url + "?provider=" + _providerName;
         params["provider"] = _providerName;
       }
       //Save the user entered form data to a temporary store and only if login is successful, we store the value in this to proper credentials store.
       if (kony.sdk.getSdkType() === kony.sdk.constants.SDK_TYPE_IDE && (_type === "basic" || (options && options["userid"] && options["password"])) && offlineEnabled === true) {
         kony.sdk.offline.saveTempUserCredentials(options);
         if (!kony.sdk.isNetworkAvailable()) {
           kony.sdk.offline.loginOffline(_providerName, function(cachedAuthResponse) {
             kony.sdk.logsdk.info("successfully authenticated offline");
             processLoginSuccessResponse(cachedAuthResponse, konyRef, true, successCallback);
           }, function(error) {
             kony.sdk.logsdk.error("offline authentication also failed");
             resetAllCurrentTokens(konyRef, _providerName);
             if (failureCallback) {
               failureCallback(kony.sdk.error.getAuthErrObj(error));
             }
           });
           return;
         }
       }
       var networkOptions = {};
       if (!kony.sdk.isNullOrUndefined(options)) {
         if (!kony.sdk.isNullOrUndefined(options["httpRequestOptions"]) && options["httpRequestOptions"] instanceof Object) {
           networkOptions["httpRequestOptions"] = options["httpRequestOptions"];
         }
         if (!kony.sdk.isNullOrUndefined(options["xmlHttpRequestOptions"]) && options["xmlHttpRequestOptions"] instanceof Object) {
           networkOptions["xmlHttpRequestOptions"] = options["xmlHttpRequestOptions"];
         }
         if (!kony.sdk.isNullOrUndefined(options["include_profile"])) {
           params["include_profile"] = params["include_profile"] ? params["include_profile"] : options["include_profile"];
         }
         //Passing enable_refresh_login as body param to login call to get the backend refresh token as part of initial login response
         if (refreshLoginEnabled) {
           params[kony.sdk.constants.ENABLE_REFRESH_LOGIN] = true;
           konyRef.refreshLoginProvidersSet.add(_providerName);
         } else {
           if (konyRef.refreshLoginProvidersSet.has(_providerName)) {
             konyRef.refreshLoginProvidersSet.delete(_providerName);
           }
         }
       }
       if (is_enable_identity_pkce) {
         if (kony.sdk.isNullOrUndefined(networkOptions[kony.sdk.constants.KEY_XML_HTTP_REQUEST_OPTIONS])) {
           networkOptions[kony.sdk.constants.KEY_XML_HTTP_REQUEST_OPTIONS] = {};
         }
         networkOptions[kony.sdk.constants.KEY_XML_HTTP_REQUEST_OPTIONS][kony.sdk.constants.ENABLE_WITH_CREDENTIALS] = true;
       }
       networkProvider.post(endPointUrl, params, headers, function(data) {
         genericPostLoginSuccessCallback(data, successCallback);
       }, function(data) {
         processLoginErrorResponse(data, konyRef, true, failureCallback)
       }, null, networkOptions);
     }

     function loginHelper(url, params, headers, isError, errorObject) {
       kony.sdk.logsdk.trace("Entering loginHelper, isError = " + isError);
       if (isError) {
         var err = {};
         if (!kony.sdk.isNullOrUndefined(errorObject)) {
           err = errorObject;
         } else {
           err.message = "Login Failed";
           err.opstatus = kony.sdk.errorcodes.transient_login_fail;
           err.code = (params && params.error) ? params.error : "";
         }
         kony.sdk.verifyAndCallClosure(failureCallback, err);
         return;
       }
       if (!kony.sdk.isNullOrUndefined(konyRef.currentClaimToken) && !konyRef.isAnonymousProvider) {
         kony.sdk.claimsRefresh(function(res) {
           invokeAjaxCall(url, params, headers);
         }, function(err) {
           if (continueOnRefreshError) {
             kony.sdk.logsdk.error("### AuthService::login claimsRefresh failed, performing force login");
             invokeAjaxCall(url, params, headers);
           } else {
             kony.sdk.logsdk.error("### AuthService::login claimsRefresh failed, invoking failurecallback");
             err.message = kony.sdk.errormessages.transient_login_fail;
             err.opstatus = kony.sdk.errorcodes.transient_login_fail;
             kony.sdk.verifyAndCallClosure(failureCallback, err);
           }
         });
       } else {
         kony.sdk.logsdk.info("### AuthService::login Claims token unavailable, performing regular login");
         invokeAjaxCall(url, params, headers);
       }
     }

     function loginForDeeplink(deeplinkOptions) {
       kony.sdk.logsdk.trace("Entering loginForDeeplink");
       if (deeplinkOptions) {
         var code = deeplinkOptions[kony.sdk.constants.DEEPLINK_VALID_PARAM];
         var urlType = deeplinkOptions["urlType"];
         try {
           kony.sdk.logsdk.debug("### AuthService::login received authorization code");
           loginHelper("/" + urlType + "/" + "token", {
             code: code
           }, {});
         } catch (err) {
           kony.sdk.logsdk.error("exception ::" + err);
           failureCallback();
         }
       }
     }

     function extractLoginOptions(loginOptions) {
       if (!kony.sdk.isNullOrUndefined(loginOptions)) {
         offlineEnabled = loginOptions["isOfflineEnabled"] || false;
         kony.sdk.offline.isOfflineEnabled = kony.sdk.offline.isOfflineEnabled || offlineEnabled;
         kony.sdk.sso.isSSOEnabled = loginOptions["isSSOEnabled"] || false;
         customQueryParamsForOAuth = loginOptions[kony.sdk.constants.CUSTOM_QUERY_PARAMS_FOR_OAUTH];
         if (loginOptions["continueOnRefreshError"] === false) {
           continueOnRefreshError = false;
         }
         if (loginOptions["persistLoginResponse"] === true) {
           persistToken = true;
           dataStore.setItem(kony.sdk.constants.PERSIST_LOGIN_RESPONSE_FLAG, true);
           kony.sdk.offline.persistToken = true;
         }
         refreshLoginEnabled = false;
         if (providerType === kony.sdk.constants.AUTH_PROVIDER_TYPE_OAUTH2) {
           //Extracting enable_refresh_login flag from login options
           if (typeof loginOptions[kony.sdk.constants.ENABLE_REFRESH_LOGIN] === "boolean") {
             refreshLoginEnabled = loginOptions[kony.sdk.constants.ENABLE_REFRESH_LOGIN];
           } else {
             kony.sdk.logsdk.warn("the value of " + kony.sdk.constants.ENABLE_REFRESH_LOGIN + " should be of boolean type");
           }
           //Extracting customOAuthParams from login options
           customOAuthParams = loginOptions[kony.sdk.constants.CUSTOM_OAUTH_PARAMS];
           if (!kony.sdk.util.isNullOrUndefinedOrEmptyObject(customOAuthParams)) {
             kony.sdk.customOAuthParmsForClaimsAndBackendTokenRefresh[_providerName] = {};
             //populating custom oAuth params in global kony.sdk.customOAuthParmsForClaimsAndBackendTokenRefresh object so that these
             // params will be used in /claims?refresh=true call which happens when server throws 401 status code incase of service call
             // failure
             kony.sdk.util.populateCustomOAuthParams(kony.sdk.customOAuthParmsForClaimsAndBackendTokenRefresh[_providerName], customOAuthParams);
           }
         }
         //no popup option in single window login are only meant for SPA/DW and PlainJS apps
         if (kony.sdk.getPlatformName() === kony.sdk.constants.PLATFORM_THIN_CLIENT && loginOptions[kony.sdk.constants.NO_POP_UP] === true && !kony.sdk.isNullOrUndefined(kony.license.saveCurrentSessionForReuse)) {
           isSingleWindowLoginEnabled = true;
           customDaveSaveHandleFunction = loginOptions[kony.sdk.constants.CUSTOM_DATA_SAVE_HANDLE];
           if (!kony.sdk.util.isPlatformPlainJS() && kony.sdk.getSdkType() !== kony.sdk.constants.SDK_TYPE_PHONEGAP) {
             kony.license.saveCurrentSessionForReuse();
           }
           metaDataManagerForLoginInSameWindow.initialize();
           metaDataManagerForLoginInSameWindow.setItem(kony.sdk.constants.LOGIN_OPTIONS, loginOptions);
           metaDataManagerForLoginInSameWindow.setItem(kony.sdk.constants.KEY_PROVIDER, _providerName);
           metaDataManagerForLoginInSameWindow.setItem(kony.sdk.constants.URL_TYPE, "/" + _type + "/token");
         }
       } else {
         kony.sdk.sso.isSSOEnabled = false;
       }
     }

     function extractOauthOptions(authOptions) {
       var _oauthOptions = {};
       _oauthOptions[kony.sdk.constants.CUSTOM_QUERY_PARAMS_FOR_OAUTH] = customQueryParamsForOAuth;
       _oauthOptions[kony.sdk.constants.IS_ENABLE_IDENTITY_PKCE] = is_enable_identity_pkce === true;
       if (kony.sdk.util.isValidString(authOptions[kony.sdk.constants.IE11_CROSS_DOMAIN_OAUTH_BASE_URL])) {
         _oauthOptions[kony.sdk.constants.IE11_CROSS_DOMAIN_OAUTH_BASE_URL] = authOptions[kony.sdk.constants.IE11_CROSS_DOMAIN_OAUTH_BASE_URL];
       }
       if (kony.sdk.util.hasBrowserWidget(authOptions)) {
         _oauthOptions[kony.sdk.constants.BROWSER_WIDGET] = authOptions[kony.sdk.constants.BROWSER_WIDGET];
       } else {
         if (authOptions["UseDeviceBrowser"]) {
           //Validating to check the existence of param "UseDeviceBrowser".
           // if found login url will be opened in device native browser, else in browser widget.
           _oauthOptions["UseDeviceBrowser"] = authOptions["UseDeviceBrowser"];
         }
         if (authOptions[kony.sdk.constants.OAUTH_REDIRECT_SUCCESS_URL]) {
           //Validating to check the existence of param "success_url".
           // if found after login success we will redirect to the url specified in param "success_url".
           var success_url = authOptions[kony.sdk.constants.OAUTH_REDIRECT_SUCCESS_URL];
           //Encoding is being done specifically for android because, in android kony.application.openUrl is not
           // opening the url without encoding where as in ios its encoding and opening.
           if (kony.sdk.getPlatformName() === kony.sdk.constants.PLATFORM_ANDROID) {
             //decoding and encoding, to handle the case where in the user himself is giving us the encoded value.
             success_url = encodeURIComponent(decodeURIComponent(success_url));
           }
           _oauthOptions[kony.sdk.constants.OAUTH_REDIRECT_SUCCESS_URL] = success_url;
         }
       }
       //no popup in single window login are only meant for SPA/DW and PlainJS apps
       if (kony.sdk.getPlatformName() === kony.sdk.constants.PLATFORM_THIN_CLIENT && isSingleWindowLoginEnabled === true) {
         _oauthOptions[kony.sdk.constants.NO_POP_UP] = isSingleWindowLoginEnabled;
         _oauthOptions[kony.sdk.constants.CUSTOM_DATA_SAVE_HANDLE] = customDaveSaveHandleFunction;
         _oauthOptions[kony.sdk.constants.METADATA_MANAGER_FOR_LOGIN_IN_SAME_WINDOW_OBJECT] = metaDataManagerForLoginInSameWindow;
       }
       return _oauthOptions;
     }

     function isMFVersionCompatible() {
       //To provide backward compatibility, if MF is an older it will not have the changes for blocking the popup or opening the login url in the native browser.
       //Identity will add a new tuple in the service doc "identity_meta". SDK will validate the compatibility with the existance of serviceDoc["identity_meta"][<priovider_name>]["success_url"]
       if (mainRef && mainRef.config && mainRef.config.identity_meta && mainRef.config.identity_meta[_providerName] && mainRef.config.identity_meta[_providerName]["success_url"]) {
         return true;
       }
       return false;
     }

     function performBasicOrCustomLogin(basicLoginOptions) {
       if (kony.sdk.sso.isSSOEnabled === false) {
         // check for mandatory params only if auth type is basic.(includes custom auth mandatory fields)
         if (_type == "basic") {
           var mandatory_fields = ["userid", "password"];
           if (serviceObj.mandatory_fields && kony.sdk.isArray(serviceObj.mandatory_fields)) {
             mandatory_fields = serviceObj.mandatory_fields;
           }
           for (var i = 0; i < mandatory_fields.length; ++i) {
             if (kony.sdk.isNullOrUndefined(basicLoginOptions[mandatory_fields[i]])) {
               throw new Exception(kony.sdk.errorConstants.AUTH_FAILURE, " Require " + mandatory_fields[i]);
             }
           }
         }
       }
       var payload = {};
       for (var option in basicLoginOptions) {
         payload[option] = basicLoginOptions[option];
       }
       loginHelper("/login", payload, {});
     }

     function performOauthOrSamlLogin(authOptions) {
       // Older oAuth versions support POST calls with userid and password. (e.g. Salesforce)
       // Check if the developer has provided userid and password for oAuth, These calls don't require browser widget
       if (authOptions.hasOwnProperty("userid") && authOptions.hasOwnProperty("password")) {
         performBasicOrCustomLogin(authOptions);
       } else {
         // Check if SSO is enabled and SSO token is neither null nor empty
         if (kony.sdk.isSSOLoginSuccess && kony.sdk.sso.isSSOEnabled == true && !kony.sdk.util.isNullOrEmptyString(kony.sdk.util.getSSOToken())) {
           // call SSO login according to the identity type
           if (_type === "oauth2") {
             loginHelper("/oauth2/token", {}, {});
           } else if (_type === "saml") {
             loginHelper("/saml/token", {}, {});
           } else {
             loginHelper("/login", {}, {});
           }
         } else {
           //only for thin clients where code is already present and we need to do token call
           if (kony.sdk.getPlatformName() === kony.sdk.constants.PLATFORM_THIN_CLIENT && !kony.sdk.isNullOrUndefined(authOptions[kony.sdk.constants.SINGLE_WINDOW_LOGIN_BODY_PARAMS])) {
             var bodyParams = authOptions[kony.sdk.constants.SINGLE_WINDOW_LOGIN_BODY_PARAMS];
             var urlType = metaDataManagerForLoginInSameWindow.getItem(kony.sdk.constants.URL_TYPE);
             metaDataManagerForLoginInSameWindow.destroy(); // no longer needed saved data
             loginHelper(urlType, bodyParams, {}); //token call
           } else {
             OAuthHandler(_serviceUrl, _providerName, mainRef.appKey, loginHelper, _type, extractOauthOptions(authOptions), isMFVersionCompatible());
           }
         }
       }
     }
     kony.sdk.logsdk.debug("### AuthService::login Invoked login for provider " + _providerName + " of type " + _type);
     if (typeof(options) == 'undefined') {
       throw new Exception(kony.sdk.errorConstants.AUTH_FAILURE, "Missing required number of arguments to login function");
     }
     if (options !== null) {
       // extract and set respective login option values like isOfflineEnabled, isSSOEnabled etc.
       extractLoginOptions(options["loginOptions"]);
     } else {
       options = {};
     }
     if (_type === "anonymous") {
       konyRef.isAnonymousProvider = true;
       loginHelper("/login", {}, {});
     } else if (_type == "basic") {
       performBasicOrCustomLogin(options);
     } else {
       performOauthOrSamlLogin(options);
     }
   };
   /**
    * validateMfa validates the multi factor authentication parameters
    * @param {object} mfaParams- 2nd factor authentic param
    * @param {function} successCallback  - Callback method on success
    * @param {function} failureCallback - Callback method on failure
    */
   this.validateMfa = function(mfaParams, successCallback, failureCallback, options) {
     kony.sdk.logsdk.debug("AuthService::validateMfa Invoked login for provider " + _providerName + " of type " + _type);

     function performValidateCall(urlMFA, params) {
       var headers = kony.sdk.getDefaultHeaders();
       headers[kony.sdk.constants.KONY_AUTHORIZATION_HEADER] = konyRef.currentClaimToken;
       headers[kony.sdk.constants.APP_KEY_HEADER] = mainRef.appKey;
       headers[kony.sdk.constants.APP_SECRET_HEADER] = mainRef.appSecret;
       headers[kony.sdk.constants.SDK_TYPE_HEADER] = kony.sdk.getSdkType();
       headers[kony.sdk.constants.SDK_VERSION_HEADER] = kony.sdk.version;
       headers[kony.sdk.constants.PLATFORM_TYPE_HEADER] = kony.sdk.getPlatformName();
       headers[kony.sdk.constants.HTTP_REQUEST_HEADER_ACCEPT] = kony.sdk.constants.CONTENT_TYPE_JSON;
       headers[kony.sdk.constants.HTTP_CONTENT_HEADER] = kony.sdk.constants.CONTENT_TYPE_FORM_URL_ENCODED;
       populateHeaderWithFabricAppVersion(headers);
       if (konyRef.reportingheaders_allowed) {
         headers[kony.sdk.constants.REPORTING_HEADER] = kony.sdk.getEncodedReportingParamsForSvcid("login_" + _providerName);
       }
       var endPointUrl = _serviceUrl + urlMFA + "?provider=" + _providerName;
       var networkOptions = kony.sdk.util.checkAndFetchNetworkProviderOptions(options);
       networkProvider.post(endPointUrl, params, headers, function(data) {
         var response = processLoginSuccessResponse(data, konyRef, false);
         kony.sdk.verifyAndCallClosure(successCallback, response);
       }, function(data) {
         processLoginErrorResponse(data, konyRef, true, failureCallback)
       }, null, networkOptions);
     }
     if (kony.sdk.isNullOrUndefined(mfaParams)) {
       throw new Exception(kony.sdk.errorConstants.AUTH_FAILURE, " mfaParams are null");
     }
     var payload = {};
     payload["provider"] = _providerName;
     for (var key in mfaParams) {
       payload[key] = mfaParams[key];
     }
     if (!kony.sdk.isNullOrUndefined(konyRef.currentClaimToken) && !konyRef.isAnonymousProvider) {
       kony.sdk.claimsRefresh(function(res) {
         performValidateCall("/login/mfa", payload)
       }, function(err) {
         kony.sdk.logsdk.error("AuthService::validateMfa claimsRefresh failed, invoking failurecallback");
         err.message = kony.sdk.errormessages.transient_login_fail;
         err.opstatus = kony.sdk.errorcodes.transient_login_fail;
         kony.sdk.verifyAndCallClosure(failureCallback, err);
       })
     } else {
       kony.sdk.logsdk.error("AuthService::validateMfa Claims token unavailable, please login");
       err.message = kony.sdk.errormessages.offline_auth_failed;
       err.opstatus = kony.sdk.errorcodes.offline_auth_failedl;
       kony.sdk.verifyAndCallClosure(failureCallback, err);
     }
   };
   /**
    * getMfaDetails functions lets the user to know whether 2factor security is enabled
    * @return {boolean}
    **/
   this.getMfaDetails = function() {
     var mfaDetails = {};
     mfaDetails[kony.sdk.constants.IS_MFA_ENABLED] = is_mfa_enabled;
     mfaDetails[kony.sdk.constants.MFA_META] = mfa_meta;
     return mfaDetails;
   };
   /**
    * Tries to get persisted token from local store and update sdk.
    */
   this.usePersistedLogin = function() {
     kony.sdk.logsdk.perf("Executing usePersistedLogin");
     var stringifiedResponse = kony.sdk.offline.getUserAuthInformation(kony.sdk.constants.PERSISTED_AUTH_RESPONSE);
     if (stringifiedResponse && kony.sdk.isJson(stringifiedResponse)) {
       kony.sdk.logsdk.debug("### PersistLogin: Persisted auth response retrieved succcessfully");
       var persistedAuthResponse = JSON.parse(stringifiedResponse);
       // To support multilogin we are checking for the existence of provider name in profiles.
       if (persistedAuthResponse && persistedAuthResponse.profiles && persistedAuthResponse.profiles[_providerName]) {
         konyRef.isAnonymousProvider = false;
         processMultipleProvidersResponse(persistedAuthResponse, _providerName);
         kony.sdk.logsdk.perf("Executing Finished usePersistedLogin");
         return true;
       }
     } else {
       kony.sdk.logsdk.debug("### PersistLogin: Failed to retrieve persisted auth response");
     }
     kony.sdk.logsdk.perf("Executing Finished usePersistedLogin");
     return false;
   };
   var processMultipleProvidersResponse = function(data, providerName) {
     if (data && data.profiles) {
       konyRef.isAnonymousProvider = false;
       for (var provider in data.profiles) {
         if (!konyRef.tokens[provider]) {
           konyRef.tokens[provider] = {};
         }
         konyRef.tokens[provider].profile = data.profiles[provider];
       }
     } else if (data && providerName && data.profile) {
       konyRef.isAnonymousProvider = false;
       konyRef.tokens[providerName].profile = data.profile;
     }
     if (data && providerName && data.provider_token) {
       konyRef.tokens[providerName].provider_token = data.provider_token;
     }
     if (data && data.provider_tokens) {
       for (var provider in data.provider_tokens) {
         if (!konyRef.tokens[provider]) {
           konyRef.tokens[provider] = {};
         }
         if (!konyRef.tokens[provider].provider_token) {
           konyRef.tokens[provider].provider_token = {}
         }
         konyRef.tokens[provider].provider_token.value = data.provider_tokens[provider];
       }
     }
     konyRef.currentClaimToken = data.claims_token.value;
     konyRef.claimTokenExpiry = data.claims_token.exp;
     konyRef.currentRefreshToken = data.refresh_token;
     if (!kony.sdk.isNullOrUndefined(data.claims_token.session_id)) {
       konyRef.idSid = data.claims_token.session_id;
     }
     if (!konyRef.isAnonymousProvider && !kony.sdk.isNullOrUndefined(data.claims_token[kony.sdk.constants.IS_MFA_ENABLED])) {
       for (var providerPosition = 0; providerPosition < konyRef.login.length; providerPosition++) {
         if (konyRef.login[providerPosition].prov === providerName) {
           //we are doing this so that if user makes anoher identity object with same provider , is_mfa_enabled value can be available
           konyRef.login[providerPosition][kony.sdk.constants.IS_MFA_ENABLED] = data.claims_token[kony.sdk.constants.IS_MFA_ENABLED];
           konyRef.login[providerPosition][kony.sdk.constants.MFA_META] = data.claims_token[kony.sdk.constants.MFA_META];
           var result = {};
           result[kony.sdk.constants.IS_MFA_ENABLED] = data.claims_token[kony.sdk.constants.IS_MFA_ENABLED];
           result[kony.sdk.constants.MFA_META] = data.claims_token[kony.sdk.constants.MFA_META];
           return result;
         }
       }
     }
   };
   var processLoginSuccessResponse = function(data, konyRef, isAsync, callBack) {
     kony.sdk.logsdk.perf("Executing processLoginSuccessResponse");
     var response = {};
     data = kony.sdk.formatSuccessResponse(data);
     if (_type !== "anonymous" && !konyRef.tokens[_providerName]) {
       konyRef.tokens[_providerName] = {};
     }
     kony.sdk.logsdk.info("### AuthService::login successful. Retrieved Data::");
     var result = processMultipleProvidersResponse(data, _providerName)
     if (!kony.sdk.isNullOrUndefined(result) && !kony.sdk.isNullOrUndefined(result[kony.sdk.constants.IS_MFA_ENABLED])) {
       response.mfa_response = result;
     }
     kony.sdk.logsdk.info("### AuthService::login extracted token. Calling success callback");
     if (kony.sdk.sso.isSSOEnabled === true) {
       if (data.sso_token) {
         var isSSOSaved = kony.sdk.util.saveSSOToken(kony.sdk.util.addOrUpdateSSOTokenWithProvider(data.sso_token, _providerName));
         if (isSSOSaved === true) {
           kony.sdk.isSSOLoginSuccess = true;
           kony.sdk.logsdk.info("### SSOLoginService::SSOToken being saved successfully.");
         } else {
           kony.sdk.logsdk.info("### SSOLoginService::Failed to save SSOToken.This might result in failure of corresponding sso Logins. Please check the configuration params");
         }
       } else {
         kony.sdk.logsdk.info("### SSOLoginService::Unable to fetch sso token.");
       }
     }
     if (data.profile && data.profile != undefined && data.profile.user_attributes != undefined) {
       user_attributes = data.profile.user_attributes;
     }
     if (data.profile) {
       kony.sdk.overrideUserId(data.profile.userid);
     }
     if (kony.sdk.getSdkType() === kony.sdk.constants.SDK_TYPE_IDE) {
       //We store the user credentials and the success auth response only on successful online login.
       if (kony.sdk.offline.isOfflineEnabled === true) {
         if (kony.sdk.isNetworkAvailable() && offlineEnabled && _type === "basic") {
           kony.sdk.offline.updateSuccessUserCredentials(_providerName);
         }
         kony.sdk.offline.saveUserAuthInformation("authResponse", data);
       }
       if (_type !== "anonymous") {
         if (persistToken || kony.sdk.offline.persistToken || kony.sdk.offline.isPersistentLoginResponseEnabled()) {
           kony.sdk.offline.saveUserAuthInformation(kony.sdk.constants.PERSISTED_AUTH_RESPONSE, data);
         }
       }
     }
     kony.logger.setClaimsToken();
     if (!isAsync) {
       return response;
     } else if (callBack) {
       delete response.mfa_response;
       kony.sdk.verifyAndCallClosure(callBack, response);
     }
   };
   var processLoginErrorResponse = function(data, konyRef, isAsync, callBack) {
     kony.sdk.logsdk.perf("Executing processLoginErrorResponse");
     kony.sdk.logsdk.info("### AuthService::login Calling failure callback");
     /*resetting all the token in case of error */
     resetAllCurrentTokens(konyRef, _providerName);
     if (kony.sdk.sso.isSSOEnabled === true) {
       if (data.mfcode == "Auth-55") {
         kony.sdk.util.deleteSSOToken();
       }
       kony.sdk.isSSOLoginSuccess = false;
     }
     if (!isAsync) {
       return kony.sdk.error.getAuthErrObj(data);
     } else if (callBack) {
       callBack(kony.sdk.error.getAuthErrObj(data));
     }
   };
   /**
    * Login anonymous with the given credentials synchronously and executes the given callback.
    * @param {object} options - User name and password
    */
   this.anonymousLoginSync = function(options) {
     kony.sdk.logsdk.perf("Executing anonymousLoginSync");
     konyRef.isAnonymousProvider = false;
     var reportingData = kony.sdk.getEncodedReportingParamsForSvcid("login_" + _providerName);
     kony.sdk.logsdk.debug("### AuthService::login Invoked login for provider " + _providerName + " of type " + _type);
     if (typeof(options) == 'undefined') {
       throw new Exception(kony.sdk.errorConstants.AUTH_FAILURE, "Missing required number of arguments to login function");
     }

     function invokeAjaxCall(url, params, headers) {
       headers = kony.sdk.addDefaultHeaders(headers);
       headers[kony.sdk.constants.APP_KEY_HEADER] = mainRef.appKey;
       headers[kony.sdk.constants.APP_SECRET_HEADER] = mainRef.appSecret;
       headers[kony.sdk.constants.HTTP_REQUEST_HEADER_ACCEPT] = kony.sdk.constants.CONTENT_TYPE_JSON;
       if (konyRef.reportingheaders_allowed) {
         if (reportingData != null && reportingData != undefined) {
           try {
             headers[kony.sdk.constants.REPORTING_HEADER] = reportingData;
           } catch (error) {
             kony.sdk.logsdk.error("### anonymousLoginSync::error while parsing metrics payload" + error);
           }
         }
       }
       var endPointUrl = null;
       if (_type === "anonymous") {
         endPointUrl = _serviceUrl + url;
       } else {
         endPointUrl = _serviceUrl + url + "?provider=" + _providerName;
         params["provider"] = _providerName;
       }
       var data = networkProvider.postSync(endPointUrl, params, headers);
       if (data.opstatus == 0) {
         return processLoginSuccessResponse(data, konyRef, false);
       } else {
         return processLoginErrorResponse(data, konyRef, false);
       }
     }
     konyRef.isAnonymousProvider = true;
     kony.sdk.logsdk.info("### AuthService::login Adapter type is anonymous");
     var headers = kony.sdk.getDefaultHeaders();
     headers[kony.sdk.constants.HTTP_CONTENT_HEADER] = kony.sdk.constants.CONTENT_TYPE_FORM_URL_ENCODED;
     var result = invokeAjaxCall("/login", {}, headers);
     kony.sdk.logsdk.perf("Executing Finished anonymousLoginSync");
     return result;
   };
   /**
    * Logout and executes the given callback.
    * @param {function} successCallback  - Callback method on success
    * @param {function} failureCallback - Callback method on failure
    * @param {object} options - additional options for logout
    */
   this.logout = function(successCallback, failureCallback, options) {
     kony.sdk.logsdk.trace("Entering logout");

     function logoutHandler() {
       _logout(successCallback, failureCallback, options);
     }

     function claimsRefreshFailureCallback() {
       kony.sdk.logsdk.error("### AuthService::logout claimsRefresh failed");
       logoutHandler();
     }
     //if the user logged in using offline logout
     if (offlineEnabled == true && kony.sdk.getSdkType() === kony.sdk.constants.SDK_TYPE_IDE && _type === "basic" && !kony.sdk.isNetworkAvailable()) {
       logoutHandler();
     } else {
       kony.sdk.claimsRefresh(logoutHandler, claimsRefreshFailureCallback);
     }
   };

   function _logout(successCallback, failureCallback, options) {
     var customOAuthParams = null;

     function extractLogoutOptions(logoutOptions) {
       if (!kony.sdk.util.isNullOrUndefinedOrEmptyObject(logoutOptions)) {
         if (providerType === kony.sdk.constants.AUTH_PROVIDER_TYPE_OAUTH2) {
           customOAuthParams = logoutOptions[kony.sdk.constants.CUSTOM_OAUTH_PARAMS];
         }
       }
     }

     function invokeLogoutHelper(formData, invokeLogoutSuccess, invokeLogoutFailure) {
       var claimsTokenValue = null;
       var reportingData = kony.sdk.getEncodedReportingParamsForSvcid("logout_" + _providerName);
       if (!kony.sdk.isNullOrUndefined(konyRef.currentClaimToken)) {
         claimsTokenValue = konyRef.currentClaimToken;
       }
       formdata.provider = _providerName;
       var url = "";
       //type (/oauth2/) should be added in the url for oauth2 provider only (not even in saml though it is similar to oauth2)
       if (_type == kony.sdk.constants.AUTH_PROVIDER_TYPE_OAUTH2 && kony.sdk.getSdkType() == kony.sdk.constants.SDK_TYPE_IDE) {
         url = _serviceUrl + "/oauth2/logout?provider=" + _providerName;
       } else {
         url = _serviceUrl + "/logout?provider=" + _providerName;
       }
       var headers = kony.sdk.getDefaultHeaders();
       headers[kony.sdk.constants.KONY_AUTHORIZATION_HEADER] = claimsTokenValue;
       headers[kony.sdk.constants.HTTP_REQUEST_HEADER_ACCEPT] = "*/*";
       headers[kony.sdk.constants.HTTP_CONTENT_HEADER] = kony.sdk.constants.CONTENT_TYPE_FORM_URL_ENCODED;
       if (konyRef.reportingheaders_allowed) {
         if (reportingData != null && reportingData != undefined) {
           try {
             headers[kony.sdk.constants.REPORTING_HEADER] = reportingData;
           } catch (error) {
             kony.sdk.logsdk.error("### login::error while parsing metrics payload" + error);
           }
         }
       }
       //populating custom oAuth params
       if (providerType === kony.sdk.constants.AUTH_PROVIDER_TYPE_OAUTH2) {
         kony.sdk.util.populateCustomOAuthParams(formData, customOAuthParams);
       }
       populateHeaderWithFabricAppVersion(headers);
       networkProvider.post(url, formdata, headers, function(data) {
         kony.sdk.logsdk.info("AuthService::logout successfully logged out. Calling success callback");

         function serviceDocCallback() {
           logoutSuccess(data);
           return;
         }
         getLatestServiceDocIfAvailable(data, serviceDocCallback);
       }, function(err) {
         kony.sdk.isOAuthLogoutInProgress = false;
         kony.sdk.logsdk.error("### AuthService::logout logged out Failed. Calling failure callback");
         kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getAuthErrObj(err));
       });
     }

     function logoutSuccess(data) {
       kony.sdk.logsdk.trace("Entering logoutSuccess from Identity.");
       data = kony.sdk.formatSuccessResponse(data);
       delete konyRef.tokens[_providerName];
       var pastClaimsToken = konyRef.currentClaimToken;
       var doesSessionNeedsToBeCleanedAtMW = true;
       if (konyRef.refreshLoginProvidersSet.has(_providerName)) {
         konyRef.refreshLoginProvidersSet.delete(_providerName);
       }
       //reset all current keys
       kony.sdk.resetCurrentKeys(konyRef, _providerName);
       //processing multiple profiles
       if (data && data.claims_token) {
         processMultipleProvidersResponse(data);
         konyRef.isAnonymousProvider = false;
         doesSessionNeedsToBeCleanedAtMW = false;
         if (!kony.sdk.isNullOrUndefined(data[kony.sdk.constants.LOGIN_PROFILES])) {
           var listOfLoginProfiles = Object.keys(data[kony.sdk.constants.LOGIN_PROFILES]);
           //setting the internal refresh token for current logged-in providers in secured storage based on login profiles
           refreshLoginTokenStoreUtilityObject.setInternalRefreshToken(listOfLoginProfiles, konyRef.currentRefreshToken);
         }
       }
       if (offlineEnabled) {
         kony.sdk.offline.isOfflineEnabled = false;
         kony.sdk.offline.removeUserAuthInformation();
         kony.sdk.offline.removeUserCredentials(_providerName);
       }
       if (persistToken || kony.sdk.offline.persistToken || kony.sdk.offline.isPersistentLoginResponseEnabled()) {
         kony.sdk.offline.removePersistedUserAuthInformation();
         persistToken = false;
         kony.sdk.offline.persistToken = false;
         dataStore.setItem(kony.sdk.constants.PERSIST_LOGIN_RESPONSE_FLAG, false);
       }
       // slo : Single Logout out
       //deleting all SSO token as the backend session has expired.
       if (slo === true || slo === "true") {
         kony.sdk.util.deleteSSOToken();
       } else if (!kony.sdk.util.isNullOrEmptyString(kony.sdk.util.getSSOTokenForProvider(_providerName))) {
         //removing SSO token for the provider.
         kony.sdk.util.deleteSSOTokenForProvider(_providerName);
       }
       //reset global customOAuthParams for the logged out provider from global kony.sdk.customOAuthParmsForClaimsAndBackendTokenRefresh
       if ((providerType === kony.sdk.constants.AUTH_PROVIDER_TYPE_OAUTH2) && !kony.sdk.util.isNullOrUndefinedOrEmptyObject(kony.sdk.customOAuthParmsForClaimsAndBackendTokenRefresh[_providerName])) {
         kony.sdk.customOAuthParmsForClaimsAndBackendTokenRefresh[_providerName] = {};
       }
       if (doesSessionNeedsToBeCleanedAtMW) {
         //user has no active provider logged in left, we should go for session deletion with MW
         var middlewareSessionInvalidationURL = konyRef[kony.sdk.constants.INTEGRATION_SERVICE_KEY]
           [kony.sdk.constants.INTEGRATION_INTERNAL_LOGOUT_URL] + '/' + kony.sdk.constants.INTEGRATION_INTERNAL_CLEAR_SESSION_ENDPOINT;
         var headers = {};
         headers[kony.sdk.constants.KONY_AUTHORIZATION_HEADER] = pastClaimsToken;
         var options = {};
         options[kony.sdk.constants.IGNORE_MESSAGE_INTEGRITY] = true;
         networkProvider.post(middlewareSessionInvalidationURL, null, headers, function(successResponseFromMW) {
           kony.sdk.logsdk.trace('Entering logoutSuccess from Middleware with message' + successResponseFromMW[kony.sdk.constants.KEY_MESSAGE]);
           kony.sdk.isOAuthLogoutInProgress = false;
           kony.sdk.verifyAndCallClosure(successCallback, {});
         }, function(errorResponseFromMW) {
           kony.sdk.isOAuthLogoutInProgress = false;
           kony.sdk.logsdk.error('Entering logoutFailure from Middleware with error message -' + errorResponseFromMW[kony.sdk.constants.MF_ERROR_MSG]);
           var errObject = kony.sdk.error.getAuthErrObj(errorResponseFromMW);
           errObject[kony.sdk.constants.KEY_MESSAGE] = 'Failed to invalidate session with middleware,' + ' It\'s good idea to close all browser windows.';
           kony.sdk.verifyAndCallClosure(failureCallback, errObject);
         }, null, options);
       } else {
         kony.sdk.isOAuthLogoutInProgress = false;
         kony.sdk.verifyAndCallClosure(successCallback, {});
       }
     }
     kony.sdk.logsdk.debug("### AuthService::logout invoked on provider " + _providerName + " of type " + _type);
     var slo = false;
     if (!kony.sdk.isNullOrUndefined(options) && (options["slo"] === true || options["slo"] === false)) {
       slo = options["slo"];
     }
     var formdata = {};
     formdata = {
       "slo": slo
     };
     //extract logout options
     if (!kony.sdk.util.isNullOrUndefinedOrEmptyObject(options)) {
       extractLogoutOptions(options[kony.sdk.constants.LOGOUT_OPTIONS]);
     }
     if (!isLoggedIn()) {
       kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getIdentitySessionInactiveErrObj());
     } else if ((_type == kony.sdk.constants.AUTH_PROVIDER_TYPE_OAUTH2 || _type == kony.sdk.constants.AUTH_PROVIDER_TYPE_SAML) && kony.sdk.getSdkType() == kony.sdk.constants.SDK_TYPE_IDE) {
       if (!kony.sdk.isOAuthLogoutInProgress) {
         kony.sdk.isOAuthLogoutInProgress = true;
         var callback_invoke = true;
         var oauth_status;

         function oAuthCallback(status) {
           oauth_status = status;
           //Workaround to get around redirects
           if (callback_invoke) {
             callback_invoke = false;
             kony.timer.schedule("oAuthCallbackHandle", function() {
               if (oauth_status) invokeLogoutHelper(formdata, logoutSuccess, failureCallback);
               else kony.sdk.verifyAndCallClosure(failureCallback, {});
             }, 3, false);
           }
         }
         var oauthOptions = {};
         oauthOptions["logout"] = true;
         oauthOptions["slo"] = slo;
         if (kony.sdk.util.hasBrowserWidget(options)) {
           oauthOptions[kony.sdk.constants.BROWSER_WIDGET] = options[kony.sdk.constants.BROWSER_WIDGET];
         }
         OAuthHandler(_serviceUrl, _providerName, mainRef.appKey, oAuthCallback, _type, oauthOptions);
       }
     } else {
       //if the user logged in using offline login
       if (kony.sdk.offline.isOfflineEnabled == true && kony.sdk.getSdkType() === kony.sdk.constants.SDK_TYPE_IDE && _type === "basic" && !kony.sdk.isNetworkAvailable()) {
         kony.sdk.logsdk.info("AuthService::offline logout successfully logged out. Calling success callback");
         logoutSuccess();
         return;
       }
       invokeLogoutHelper(formdata, logoutSuccess, failureCallback);
     }
   }
   /**
    * Fetch the backend datasource token.
    * @param {boolean} fromserver - Flag to force fetch from server only.
    * @param {object} options - Options
    * @param {function} successCallback  - Callback method on success
    * @param {function} failureCallback - Callback method on failure
    */
   this.getBackendToken = function(fromserver, options, successCallback, failureCallback) {
     kony.sdk.logsdk.perf("Executing getBackendToken");

     function _claimsRefreshSuccess(token) {
       kony.sdk.logsdk.perf("Executing Finished getBackendToken : status success");
       kony.sdk.logsdk.trace("Entering _claimsRefreshSuccess with valid token");
       processMultipleProvidersResponse(token, _providerName);
       //konyRef.currentBackEndToken = token.provider_token;
       //if offline login enabled then updating the backend token in the store
       if (kony.sdk.offline.isOfflineEnabled && kony.sdk.offline.isOfflineEnabled == true) {
         kony.sdk.offline.updateAuthToken(token);
       }
       if (persistToken || kony.sdk.offline.persistToken || kony.sdk.offline.isPersistentLoginResponseEnabled()) {
         kony.sdk.offline.updatePersistedToken(kony.sdk.constants.PERSISTED_AUTH_RESPONSE, token);
       }
       //if the provider has refresh tokens , we should update internal refresh tokens
       if (!kony.sdk.isNullOrUndefined(refreshLoginTokenStoreUtilityObject.getInternalRefreshToken(_providerName))) {
         // update current provider's internal refresh token
         refreshLoginTokenStoreUtilityObject.setInternalRefreshToken(_providerName, konyRef.currentRefreshToken);
         // we need to update tokens for for multiple providers
         if (!kony.sdk.isNullOrUndefined(token[kony.sdk.constants.LOGIN_PROFILES])) {
           var listOfLoginProfiles = Object.keys(token[kony.sdk.constants.LOGIN_PROFILES]);
           //for multiple providers setting the internal refresh token for current logged-in providers in secured storage based on login profiles
           refreshLoginTokenStoreUtilityObject.setInternalRefreshToken(listOfLoginProfiles, konyRef.currentRefreshToken);
         }
         //if user gave options to refresh backend refresh tokens, we should update backend tokens as well
         if (doesStoredRefreshTokensNeedsUpdate) {
           var providerToBackendResponseTokenJSON = token[kony.sdk.constants.BACKEND_REFRESH_TOKENS];
           //updating backend refresh tokens of the providers
           refreshLoginTokenStoreUtilityObject.setBulkBackendRefreshTokens(providerToBackendResponseTokenJSON);
         }
       }
       kony.sdk.verifyAndCallClosure(successCallback, konyRef.tokens[_providerName].provider_token);
     }

     function _claimsRefreshFailure(error) {
       kony.sdk.logsdk.perf("Executing Finished getBackendToken : status failure");
       kony.sdk.logsdk.trace("Entering _claimsRefreshFailure");
       kony.sdk.logsdk.info("### AuthService::getBackendToken fetching refresh failed. Calling failure callback");
       // konyRef.tokens[_providerName] = null;
       // konyRef.currentBackEndToken = null;
       kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getAuthErrObj(error));
     }
     kony.sdk.logsdk.debug("### AuthService::getBackendToken called for provider " + _providerName + " of type " + _type);
     if (!isLoggedIn()) {
       kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getIdentitySessionInactiveErrObj());
     }
     var claimsOptions = null;
     var doesStoredRefreshTokensNeedsUpdate = false;
     if (options && options.refresh && options.refresh === true) {
       claimsOptions = {
         "requestParams": {
           "refresh": "true"
         }
       };
       claimsOptions[kony.sdk.constants.BODY_PARAMS] = {};
       if (!kony.sdk.isNullOrUndefined(refreshLoginTokenStoreUtilityObject.getBackendRefreshToken(_providerName))) {
         doesStoredRefreshTokensNeedsUpdate = true;
         claimsOptions[kony.sdk.constants.BODY_PARAMS][kony.sdk.constants.ENABLE_REFRESH_LOGIN] = true;
       }
       //populating custom oAuth params
       if (providerType === kony.sdk.constants.AUTH_PROVIDER_TYPE_OAUTH2) {
         //reset earlier oAuth params in kony.sdk.customOAuthParmsForClaimsAndBackendTokenRefresh for the current provider
         if (!kony.sdk.util.isNullOrUndefinedOrEmptyObject(options[kony.sdk.constants.CUSTOM_OAUTH_PARAMS])) {
           kony.sdk.customOAuthParmsForClaimsAndBackendTokenRefresh[_providerName] = {};
           //populating custom oAuth params in global kony.sdk.customOAuthParmsForClaimsAndBackendTokenRefresh object so that
           // these params will be used in /claims?refresh=true call which happens when server throws 401 status code incase
           // of service call failure
           kony.sdk.util.populateCustomOAuthParams(kony.sdk.customOAuthParmsForClaimsAndBackendTokenRefresh[_providerName], options[kony.sdk.constants.CUSTOM_OAUTH_PARAMS]);
         }
         //populating custom oAuth params in body params for this refresh call
         if (!kony.sdk.util.isNullOrUndefinedOrEmptyObject(kony.sdk.customOAuthParmsForClaimsAndBackendTokenRefresh[_providerName])) {
           kony.sdk.util.populateCustomOAuthParams(claimsOptions[kony.sdk.constants.BODY_PARAMS], kony.sdk.customOAuthParmsForClaimsAndBackendTokenRefresh[_providerName]);
         }
       }
     }
     if (fromserver != undefined && fromserver === true) {
       kony.sdk.logsdk.info("### AuthService::getBackendToken fromserver is enabled. Trying to login");
       _claimsRefresh(claimsOptions, _claimsRefreshSuccess, _claimsRefreshFailure);
     } else {
       if (konyRef.tokens[_providerName]) {
         var val = konyRef.tokens[_providerName];
         var _exp = val.provider_token.exp;
         kony.sdk.logsdk.debug("token expiry time: " + _exp);
         kony.sdk.logsdk.debug("Current time: " + (new Date().getTime()));
         if (_exp && _exp < (new Date().getTime())) {
           kony.sdk.logsdk.info("### AuthService::getBackendToken Token expired. Fetching refresh from claims api");
           _claimsRefresh(claimsOptions, _claimsRefreshSuccess, _claimsRefreshFailure);
         } else {
           kony.sdk.logsdk.info("### AuthService::getBackendToken present token is valid/doesn't have expiry time. Calling success callback");
           //konyRef.currentBackEndToken = val.provider_token;
           kony.sdk.verifyAndCallClosure(successCallback, konyRef.tokens[_providerName].provider_token);
         }
       } else {
         kony.sdk.logsdk.info("### AuthService::getBackendToken failed for find info for key " + dsKey + "in database. calling failure callback");
         kony.sdk.verifyAndCallClosure(failureCallback, null);
       }
     }
   };
   /**
    * Get profile.
    * @param {boolean} fromserver - Flag to force fetch from server only.
    * @param {function} successCallback  - Callback method on success
    * @param {function} failureCallback - Callback method on failure
    */
   this.getProfile = function(fromserver, successCallback, failureCallback) {
     kony.sdk.logsdk.trace("Entering getProfile");
     if (!isLoggedIn()) {
       kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getIdentitySessionInactiveErrObj());
     } else if (fromserver && fromserver == true) {
       profileRefresh(function(token) {
         konyRef.tokens[_providerName].profile = token;
         kony.sdk.verifyAndCallClosure(successCallback, token);
       }, failureCallback)
     } else {
       if (konyRef.tokens[_providerName]) {
         var val = konyRef.tokens[_providerName];
         kony.sdk.verifyAndCallClosure(successCallback, val.profile);
       } else {
         kony.sdk.verifyAndCallClosure(failureCallback, null);
       }
     }
   };
   /**
    * Get the provider name.
    * @returns {string} Provider name.
    */
   this.getProviderName = function() {
     return _providerName;
   };
   /**
    * Get the provider type.
    * @returns {string} Provider type.
    */
   this.getProviderType = function() {
     return _type;
   };
   /**
    * Get the generic session data type.
    * @returns {string} session data.
    */
   this.getUserData = function(successCallback, failureCallback) {
     kony.sdk.logsdk.trace("Entering getUserData (Get the generic session data type)");
     if (!isLoggedIn()) {
       kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getIdentitySessionInactiveErrObj());
     } else {
       var userDataUrl = _serviceUrl + "/session/user_data";
       var options = {};
       options["invokedFrom"] = kony.sdk.constants.GET_USER_DATA;
       getSessionData(userDataUrl, successCallback, failureCallback, options);
     }
   };
   /**
    * Get the user attributes returned by a provider
    * @returns {string} user attributes.
    */
   this.getUserAttributes = function(successCallback, failureCallback) {
     kony.sdk.logsdk.trace("Entering getUserAttributes");
     if (!isLoggedIn()) {
       kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getIdentitySessionInactiveErrObj());
     } else if (user_attributes && Object.keys(user_attributes).length === 0) {
       var userAttributesUrl = _serviceUrl + "/session/user_attributes?provider=" + _providerName;
       var options = {};
       options["invokedFrom"] = kony.sdk.constants.GET_USER_ATTRIBUTES;
       getSessionData(userAttributesUrl, function(res) {
         user_attributes = res;
         kony.sdk.verifyAndCallClosure(successCallback, user_attributes);
       }, failureCallback, options);
     } else {
       if (konyRef.currentClaimToken === null) {
         kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getNullClaimsTokenErrObj());
       } else {
         kony.sdk.verifyAndCallClosure(successCallback, user_attributes);
       }
     }
   };
   /**
    * Get the security attributes returned by a provider
    * @returns {string} security attributes.
    */
   this.getSecurityAttributes = function(successCallback, failureCallback) {
     kony.sdk.logsdk.trace("Entering getSecurityAttributes");
     if (!isLoggedIn()) {
       kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getIdentitySessionInactiveErrObj());
     } else {
       var securityAttributesUrl = _serviceUrl + "/session/security_attributes?provider=" + _providerName;
       var options = {};
       options["invokedFrom"] = kony.sdk.constants.GET_SECURITY_ATTRIBUTES;
       getSessionData(securityAttributesUrl, successCallback, failureCallback, options);
     }
   };
   /**
    * Refresh the already created Login
    * @param {function} successCallback  - Callback method on success
    * @param {function} failureCallback - Callback method on failure
    * @param {object} options - network options
    */
   this.refreshLogin = function(successCallback, failureCallback, options) {
     kony.sdk.logsdk.perf("Executing refreshLogin");
     var internalRefreshToken = refreshLoginTokenStoreUtilityObject.getInternalRefreshToken(_providerName);
     if (kony.sdk.isNullOrUndefined(internalRefreshToken)) {
       kony.sdk.logsdk.perf("Executing finished refreshLogin");
       kony.sdk.logsdk.error("Tokens absent for refreshing login provider" + _providerName);
       kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getIdentitySessionInactiveErrObj());
     } else {
       var urlObject = {};
       urlObject[kony.sdk.constants.KEY_URL] = null;
       var headers = kony.sdk.getDefaultHeaders();
       var bodyParams = {};
       var networkOptions = {};

       function checkClaimsRefreshAndSetNetworkParameters(urlObject, headers, bodyParams, networkOptions, setterCompletionCallback) {
         kony.sdk.logsdk.perf("Executing checkClaimsRefreshAndSetNetworkParameters");

         function setNetworkParameters() {
           kony.sdk.logsdk.perf("Executing setNetworkParameters");
           headers[kony.sdk.constants.APP_KEY_HEADER] = mainRef.appKey;
           headers[kony.sdk.constants.APP_SECRET_HEADER] = mainRef.appSecret;
           headers[kony.sdk.constants.SDK_TYPE_HEADER] = kony.sdk.getSdkType();
           headers[kony.sdk.constants.SDK_VERSION_HEADER] = kony.sdk.version;
           headers[kony.sdk.constants.PLATFORM_TYPE_HEADER] = kony.sdk.getPlatformName();
           headers[kony.sdk.constants.HTTP_REQUEST_HEADER_ACCEPT] = kony.sdk.constants.CONTENT_TYPE_JSON;
           headers[kony.sdk.constants.HTTP_CONTENT_HEADER] = kony.sdk.constants.CONTENT_TYPE_FORM_URL_ENCODED;
           populateHeaderWithFabricAppVersion(headers);
           if (konyRef.reportingheaders_allowed) {
             try {
               var reportingData = kony.sdk.getEncodedReportingParamsForSvcid('refreshLogin_' + _providerName);
               if (!kony.sdk.isNullOrUndefined(reportingData)) {
                 headers[kony.sdk.constants.REPORTING_HEADER] = reportingData;
               }
             } catch (error) {
               kony.sdk.logsdk.error('### login::error while parsing metrics payload in refresh login' + error);
             }
           }
           if (!kony.sdk.isNullOrUndefined(options)) {
             if (!kony.sdk.isNullOrUndefined(options[kony.sdk.constants.KEY_INCLUDE_PROFILE]) && options[kony.sdk.constants.KEY_INCLUDE_PROFILE] instanceof Object) {
               networkOptions[kony.sdk.constants.KEY_INCLUDE_PROFILE] = options[kony.sdk.constants.KEY_INCLUDE_PROFILE];
             }
             if (!kony.sdk.isNullOrUndefined(options[kony.sdk.constants.KEY_HTTP_REQUEST_OPTIONS]) && options[kony.sdk.constants.KEY_HTTP_REQUEST_OPTIONS] instanceof Object) {
               networkOptions[kony.sdk.constants.KEY_HTTP_REQUEST_OPTIONS] = options[kony.sdk.constants.KEY_HTTP_REQUEST_OPTIONS];
             }
             if (!kony.sdk.isNullOrUndefined(options[kony.sdk.constants.KEY_INCLUDE_PROFILE])) {
               bodyParams[kony.sdk.constants.KEY_INCLUDE_PROFILE] = options[kony.sdk.constants.KEY_INCLUDE_PROFILE];
             }
           }
           //populating custom oAuth params
           if (!kony.sdk.util.isNullOrUndefinedOrEmptyObject(options)) {
             kony.sdk.util.populateCustomOAuthParams(bodyParams, options[kony.sdk.constants.CUSTOM_OAUTH_PARAMS]);
           }
           bodyParams[kony.sdk.constants.KEY_PROVIDER] = _providerName;
           bodyParams[kony.sdk.constants.KEY_GRANT_TYPE] = kony.sdk.constants.KEY_REFRESH_TOKEN;
           bodyParams[kony.sdk.constants.KEY_BACKEND_REFRESH_TOKEN] = refreshLoginTokenStoreUtilityObject.getBackendRefreshToken(_providerName);
           bodyParams[kony.sdk.constants.KEY_AUTH_REFRESH_TOKEN] = internalRefreshToken;
           bodyParams[kony.sdk.constants.ENABLE_REFRESH_LOGIN] = true;
           refreshLoginEnabled = true;
           urlObject[kony.sdk.constants.KEY_URL] = _serviceUrl + kony.sdk.constants.OAUTH_TOKEN_URL + '?' + kony.sdk.constants.KEY_PROVIDER + '=' + _providerName;
           kony.sdk.logsdk.perf("Executing finished setNetworkParameters & checkClaimsRefreshAndSetNetworkParameters");
           setterCompletionCallback();
         }
         kony.sdk.claimsRefresh(function(response) {
           headers = kony.sdk.addDefaultHeaders(headers);
           headers[kony.sdk.constants.KONY_AUTHORIZATION_HEADER] = konyRef.currentClaimToken;
           setNetworkParameters();
         }, function(error) {
           setNetworkParameters();
         });
       }
       checkClaimsRefreshAndSetNetworkParameters(urlObject, headers, bodyParams, networkOptions, makeRefreshLoginCallToIdentity);
       /**
        * checks if network status is 400 or 401 then we have to delete secured stored refresh login tokens
        * @param networkResponse
        * @return boolean
        */
       function doesStoredTokensNeedsToBeRemoved(networkResponse) {
         var deleteRefreshToken = false;
         if (!kony.sdk.isNullOrUndefined(options) && !kony.sdk.isNullOrUndefined(options[kony.sdk.constants.RETAIN_BACKEND_REFRESH_TOKEN])) {
           if (typeof options[kony.sdk.constants.RETAIN_BACKEND_REFRESH_TOKEN] === "boolean" && options[kony.sdk.constants.RETAIN_BACKEND_REFRESH_TOKEN]) {
             kony.sdk.logsdk.debug("Not deleting refresh token as retain_backend_refresh_token flag is set to true.");
             return deleteRefreshToken;
           }
         }
         if (!kony.sdk.isNullOrUndefined(networkResponse)) {
           if (networkResponse.hasOwnProperty(kony.sdk.constants.HTTP_STATUS_CODE)) {
             //check for status in httpStatusCode
             if (networkResponse[kony.sdk.constants.HTTP_STATUS_CODE] == kony.sdk.constants.HTTP_CODE_400) {
               deleteRefreshToken = true;
               kony.sdk.logsdk.error("got httpStatusCode as 400");
             } else if (networkResponse[kony.sdk.constants.HTTP_STATUS_CODE] == kony.sdk.constants.HTTP_CODE_401) {
               deleteRefreshToken = true;
               kony.sdk.logsdk.error("got httpStatusCode as 401");
             }
           } else if (networkResponse.hasOwnProperty(kony.sdk.constants.KEY_HTTP_RESPONSE) && networkResponse[kony.sdk.constants.KEY_HTTP_RESPONSE].hasOwnProperty(kony.sdk.constants.KEY_RESPONSE_CODE)) {
             //if we didnt get status in httpStatusCode, we might get status under httpresponse object in responsecode
             if (networkResponse[kony.sdk.constants.KEY_HTTP_RESPONSE][kony.sdk.constants.KEY_RESPONSE_CODE] == kony.sdk.constants.HTTP_CODE_400) {
               deleteRefreshToken = true;
               kony.sdk.logsdk.error("got httpresponse.responsecode as 400");
             } else if (networkResponse[kony.sdk.constants.KEY_HTTP_RESPONSE][kony.sdk.constants.KEY_RESPONSE_CODE] == kony.sdk.constants.HTTP_CODE_401) {
               deleteRefreshToken = true;
               kony.sdk.logsdk.error("got httpresponse.responsecode as 401");
             }
           }
         }
         return deleteRefreshToken;
       }

       function makeRefreshLoginCallToIdentity() {
         kony.sdk.logsdk.perf("Executing makeRefreshLoginCallToIdentity");
         networkProvider.post(urlObject[kony.sdk.constants.KEY_URL], bodyParams, headers, function(loginResponse) {
           kony.sdk.logsdk.perf("Executing finished makeRefreshLoginCallToIdentity");
           kony.sdk.logsdk.debug("refresh login success");
           genericPostLoginSuccessCallback(loginResponse, successCallback);
           kony.sdk.logsdk.perf("Executing finished refreshLogin");
         }, function(failureResponse) {
           kony.sdk.logsdk.perf("Executing finished makeRefreshLoginCallToIdentity");
           kony.sdk.logsdk.error("refresh login failed");
           if (doesStoredTokensNeedsToBeRemoved(failureResponse)) {
             kony.sdk.logsdk.debug("removing stored refresh tokens for provider -" + _providerName);
             refreshLoginTokenStoreUtilityObject.removeTokens(_providerName);
           }
           processLoginErrorResponse(failureResponse, konyRef, true, failureCallback);
           kony.sdk.logsdk.perf("Executing finished refreshLogin");
         }, null, networkOptions);
       }
     }
   };
   /**
   	utility method to get session data
   	@private
   */
   var getSessionData = function(sessionAttributesEndPointUrl, successCallback, failureCallback, options) {
     var svcid = null;
     if (options["invokedFrom"] == kony.sdk.constants.GET_USER_ATTRIBUTES) {
       svcid = kony.sdk.constants.GET_USER_ATTRIBUTES;
     } else if (options["invokedFrom"] == kony.sdk.constants.GET_SECURITY_ATTRIBUTES) {
       svcid = kony.sdk.constants.GET_SECURITY_ATTRIBUTES;
     } else {
       svcid = kony.sdk.constants.GET_USER_DATA;
     }
     var reportingData = kony.sdk.getEncodedReportingParamsForSvcid(svcid);
     if (konyRef.currentClaimToken === null) {
       kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getNullClaimsTokenErrObj());
     } else {
       var headers = kony.sdk.getDefaultHeaders();
       headers[kony.sdk.constants.KONY_AUTHORIZATION_HEADER] = konyRef.currentClaimToken;
       if (konyRef.reportingheaders_allowed) {
         if (reportingData != null && reportingData != undefined) {
           try {
             headers[kony.sdk.constants.REPORTING_HEADER] = reportingData;
           } catch (error) {
             kony.sdk.logsdk.error("### getSessionData::error while parsing metrics payload" + error);
           }
         }
       }
       populateHeaderWithFabricAppVersion(headers);
       networkProvider.get(sessionAttributesEndPointUrl, {}, headers, function(data) {
         data = kony.sdk.formatSuccessResponse(data);
         kony.sdk.verifyAndCallClosure(successCallback, data);
       }, function(err) {
         kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getAuthErrObj(err));
       });
     }
   };
   /**
    * Method to refresh the claims token.
    * @private
    */
   var _claimsRefresh = function(options, success, failure) {
     kony.sdk.logsdk.debug("### AuthService::_claimsRefresh fetching claims from server for provider " + _providerName);
     var refreshToken = null;
     var reportingData = kony.sdk.getEncodedReportingParamsForSvcid(kony.sdk.constants.GET_BACKEND_TOKEN);
     if (!kony.sdk.isNullOrUndefined(konyRef.currentRefreshToken)) {
       refreshToken = konyRef.currentRefreshToken;
     }
     var _url = _serviceUrl + "/claims";
     if (options && options.requestParams != null) {
       _url = _url + "?";
       for (var i in options.requestParams) {
         if (options.requestParams.hasOwnProperty(i) && typeof(i) !== 'function') {
           _url = _url + (i + "=" + options.requestParams[i] + "&");
         }
       }
       _url = stripTrailingCharacter(_url, "&");
     }
     var bodyParams = {};
     if (!kony.sdk.isNullOrUndefined(options) && kony.sdk.util.isJsonObject(options[kony.sdk.constants.BODY_PARAMS])) {
       bodyParams = options[kony.sdk.constants.BODY_PARAMS];
     }
     if (refreshToken) {
       kony.sdk.logsdk.info("### AuthService::_claimsRefresh making POST request to claims endpoint");
       var headers = kony.sdk.getDefaultHeaders(headers);
       headers[kony.sdk.constants.KONY_AUTHORIZATION_HEADER] = refreshToken;
       headers[kony.sdk.constants.HTTP_CONTENT_HEADER] = kony.sdk.constants.CONTENT_TYPE_FORM_URL_ENCODED;
       if (konyRef.reportingheaders_allowed) {
         if (reportingData != null && reportingData != undefined) {
           try {
             headers[kony.sdk.constants.REPORTING_HEADER] = reportingData;
           } catch (error) {
             kony.sdk.logsdk.error("### _claimsRefresh::error while parsing metrics payload" + error);
           }
         }
       }
       populateHeaderWithFabricAppVersion(headers);
       networkProvider.post(_url, bodyParams, headers, function(data) {
         data = kony.sdk.formatSuccessResponse(data);
         kony.sdk.logsdk.info("### AuthService::_claimsRefresh Fetching claims succcessfull");
         processMultipleProvidersResponse(data);
         kony.sdk.logsdk.info("### AuthService::_claimsRefresh saved locally. Calling success callback");
         kony.sdk.verifyAndCallClosure(success, data);
       }, function(xhr, status, err) {
         kony.sdk.logsdk.error("### AuthService::_claimsRefresh fetching claims failed. Calling failure callback");
         kony.sdk.verifyAndCallClosure(failure, kony.sdk.error.getAuthErrObj(err));
       });
     } else {
       kony.sdk.logsdk.info("### AuthService::_claimsRefresh no refreshtoken found. calling failure callback");
       kony.sdk.verifyAndCallClosure(failure, kony.sdk.error.getNullRefreshTokenErrObj());
     }
   };
   var profileRefresh = function(success, failure) {
     kony.sdk.logsdk.trace("Entering profileRefresh");
     kony.sdk.logsdk.debug("### AuthService::profileRefresh fetching profile from server for provider " + _providerName);
     var reportingData = kony.sdk.getEncodedReportingParamsForSvcid(kony.sdk.constants.GET_PROFILE);
     var refreshToken = null;
     if (!kony.sdk.isNullOrUndefined(konyRef.currentRefreshToken)) {
       refreshToken = konyRef.currentRefreshToken;
     }
     var _url = _serviceUrl + "/profile?provider=" + _providerName;
     if (refreshToken) {
       kony.sdk.logsdk.info("### AuthService::profileRefresh making POST request to profile endpoint");
       var headers = kony.sdk.getDefaultHeaders();
       headers[kony.sdk.constants.KONY_AUTHORIZATION_HEADER] = refreshToken;
       headers[kony.sdk.constants.HTTP_CONTENT_HEADER] = kony.sdk.constants.CONTENT_TYPE_FORM_URL_ENCODED;
       if (konyRef.reportingheaders_allowed) {
         if (reportingData != null && reportingData != undefined) {
           try {
             headers[kony.sdk.constants.REPORTING_HEADER] = reportingData;
           } catch (error) {
             kony.sdk.logsdk.error("### profileRefresh::error while parsing metrics payload" + error);
           }
         }
       }
       populateHeaderWithFabricAppVersion(headers);
       networkProvider.get(_url, null, headers, function(data) {
         data = kony.sdk.formatSuccessResponse(data);
         konyRef.tokens[_providerName].profile = data;
         kony.sdk.logsdk.info("### AuthService::profileRefresh Fetching profile succcessfull, Calling success callback");
         kony.sdk.verifyAndCallClosure(success, data);
       }, function(xhr, status, err) {
         kony.sdk.logsdk.error("### AuthService::profileRefresh fetching profile failed. Calling failure callback");
         kony.sdk.verifyAndCallClosure(failure, kony.sdk.error.getAuthErrObj(err));
       });
     } else {
       kony.sdk.logsdk.info("### AuthService::profileRefresh no refreshtoken found. calling failure callback");
       kony.sdk.verifyAndCallClosure(failure, kony.sdk.error.getNullRefreshTokenErrObj());
     }
   };
 }

 function konySdkLogger() {
   this.INDIRECTIONLEVEL = 1;
   this.trace = function(msg, params) {
     this.getInstance().trace(msg, params);
   };
   this.debug = function(msg, params) {
     this.getInstance().debug(msg, params);
   };
   this.info = function(msg, params) {
     this.getInstance().info(msg, params);
   };
   this.perf = function(msg, params) {
     this.getInstance().perf(msg, params);
   };
   this.warn = function(msg, params) {
     this.getInstance().warn(msg, params);
   };
   this.error = function(msg, params) {
     this.getInstance().error(msg, params);
   };
   this.fatal = function(msg, params) {
     this.getInstance().fatal(msg, params);
   };
   this.loggerEngineInit = function() {
     KonySDKLoggerObj = kony.logger.createNewLogger(kony.sdk.constants.LOGGER_NAME, null);
     KonySDKLoggerObj.setIndirectionLevel(KonySDKLoggerObj.getIndirectionLevel() + this.INDIRECTIONLEVEL);
   };
   this.getInstance = function() {
     if (typeof(KonySDKLoggerObj) === 'undefined') this.loggerEngineInit();
     return KonySDKLoggerObj;
   }
 }
 /**
  * Method to create the logic service instance with the provided service name.
  * @param {string} serviceName - Name of the service
  * @returns The url to connect to the logic service
  * @throws Exception if the serviceName or access is invalid.
  */
 kony.sdk.prototype.getLogicService = function(serviceName) {
   kony.sdk.logsdk.perf("Executing kony.sdk.prototype.getLogicService");
   if (!kony.sdk.isInitialized) {
     throw new Exception(kony.sdk.errorConstants.INIT_FAILURE, kony.sdk.constants.INIT_FAILURE_MESSAGE + " Logic service - " + serviceName);
   }
   if (this.logicsvc != null) {
     if (this.logicsvc[serviceName] != null) {
       kony.sdk.logsdk.perf("Executing Finished kony.sdk.prototype.getLogicService");
       kony.sdk.logsdk.debug("### getLogicService::found Logic service" + this.logicsvc[serviceName]);
       return new kony.sdk.LogicService(this, serviceName);
     }
   }
   throw new Exception(kony.sdk.errorConstants.LOGIC_SERVICE_FAILURE, "Invalid serviceName:" + serviceName);
 };
 kony.sdk.LogicService = function(konyRef, serviceName) {
   this.konyRef = konyRef;
   this.serviceName = serviceName;
   this.logicServiceUrl = null;
   this.getLogicServiceUrl = function() {
     if (this.logicServiceUrl == null) {
       this.logicServiceUrl = stripTrailingCharacter(konyRef.logicsvc[serviceName], "/");
     }
     return this.logicServiceUrl;
   };
   kony.sdk.logsdk.info(" ###LogicService Created & LogicService Url = " + this.getLogicServiceUrl());
   var networkProvider = new konyNetworkProvider();
   this.invokeOperation = function(serviceName, path, methodType, headers, data, successCallback, failureCallback, options) {
     function invokeOperationHandler() {
       _invokeOperation(serviceName, path, methodType, headers, data, true, successCallback, failureCallback, options);
     }
     kony.sdk.claimsRefresh(invokeOperationHandler, failureCallback);
   };

   function invokeOperationRetry(serviceName, path, methodType, headers, data, successCallback, failureCallback, options) {
     function invokeOperationRetryHandler() {
       _invokeOperation(serviceName, path, methodType, headers, data, false, successCallback, failureCallback, options);
     }
     kony.sdk.claimsAndProviderTokenRefresh(invokeOperationRetryHandler, failureCallback);
   }

   function retryServiceCall(errorResponse) {
     if (errorResponse[kony.sdk.constants.MF_CODE]) {
       // check for the mf code for which,
       // retry should be done.
     } else {
       if (errorResponse[kony.sdk.constants.HTTP_STATUS_CODE] && errorResponse[kony.sdk.constants.HTTP_STATUS_CODE] === 401) {
         return true;
       }
     }
   }

   function _invokeOperation(serviceName, path, methodType, headers, data, isRetryNeeded, successCallback, failureCallback, options) {
     var requestData = {};
     kony.sdk.logsdk.trace("Executing _invokeOperation servicePath: " + serviceName + ", methodType: " + methodType + ", path" + path + ", isRetryNeeded: " + isRetryNeeded);
     var reportingData = kony.sdk.getPayload(konyRef);
     var sessionId = kony.ds.read(kony.sdk.constants.KONYUUID);
     if (sessionId) {
       reportingData.rsid = sessionId[0];
     }
     if (!reportingData.rsid) {
       kony.sdk.logsdk.warn("rsid is either empty,null or undefined");
     }
     if (kony.sdk.metric) {
       if (kony.sdk.metric.reportEventBufferBackupArray.length === 0) {
         kony.sdk.metric.readFromDS();
       }
       kony.sdk.metric.pushEventsToBufferArray();
       requestData.events = kony.sdk.metric.reportEventBufferBackupArray;
     }
     for (var key in data) {
       requestData[key] = data[key];
     }
     reportingData.svcid = serviceName;
     requestData[kony.sdk.constants.REPORTING_PARAMS] = JSON.stringify(reportingData);
     var defaultHeaders = kony.sdk.getDefaultHeaders();
     defaultHeaders[kony.sdk.constants.HTTP_CONTENT_HEADER] = kony.sdk.constants.CONTENT_TYPE_FORM_URL_ENCODED;
     defaultHeaders[kony.sdk.constants.KONY_AUTHORIZATION_HEADER] = konyRef.currentClaimToken;
     if (typeof(svcObj) === 'object' && svcObj.version) {
       defaultHeaders[kony.sdk.constants.API_VERSION_HEADER] = svcObj.version;
     }
     // if the user has defined his own headers, use them
     if (headers) {
       for (var header in headers) {
         defaultHeaders[header] = headers[header];
       }
     }

     function networkSuccessCallback(response) {
       if (kony.sdk.metric) {
         kony.sdk.metric.clearBufferEvents();
       }
       kony.sdk.logsdk.perf("Executing Finished network operation for methodType : " + methodType);
       kony.sdk.logsdk.trace("Executing Finished _invokeOperation servicePath: " + serviceName + ", methodType: " + methodType + ", path" + path + ", isRetryNeeded: " + isRetryNeeded);
       kony.sdk.verifyAndCallClosure(successCallback, response);
     }

     function networkFailureCallback(xhr, status, err) {
       if (isRetryNeeded === true && retryServiceCall(xhr) === true) {
         invokeOperationRetry(serviceName, path, methodType, headers, data, successCallback, failureCallback, options);
         return;
       }
       kony.sdk.logsdk.perf("Executing Finished network operation for methodType : " + methodType);
       kony.sdk.logsdk.trace("Executing Finished _invokeOperation servicePath: " + serviceName + ", methodType: " + methodType + ", path" + path + ", isRetryNeeded: " + isRetryNeeded);
       kony.sdk.processLogicErrorResponse(xhr, true, failureCallback);
     }
     kony.sdk.logsdk.perf("Executing network operation for methodType : " + methodType);
     switch (methodType) {
       case "GET":
         networkProvider.get(konyRef.logicsvc[serviceName] + path, requestData, defaultHeaders, networkSuccessCallback, networkFailureCallback, null, options);
         break;
       case "PUT":
         networkProvider.put(konyRef.logicsvc[serviceName] + path, requestData, defaultHeaders, networkSuccessCallback, networkFailureCallback, null, options);
         break;
       case "DELETE":
         networkProvider.invokeDeleteRequest(konyRef.logicsvc[serviceName] + path, requestData, defaultHeaders, networkSuccessCallback, networkFailureCallback, null, options);
         break;
       default:
         networkProvider.post(konyRef.logicsvc[serviceName] + path, requestData, defaultHeaders, networkSuccessCallback, networkFailureCallback, null, options);
         break;
     }
   }
   kony.sdk.processLogicErrorResponse = function(err, isAsync, callBack) {
     if (kony.sdk.metric) {
       if (kony.sdk.metric.errorCodeMap[err.opstatus]) {
         kony.sdk.metric.saveInDS();
       }
     }
     if (err[kony.sdk.constants.MF_CODE]) {
       var konyRef = kony.sdk.getCurrentInstance();
       //clear the cache if the error code related to session/token expiry
       if (kony.sdk.isSessionOrTokenExpired(err[kony.sdk.constants.MF_CODE])) {
         kony.sdk.logsdk.warn("###LogicService::invokeOperationFailure  Session/Token expired. Authenticate and Try again");
         //kony.sdk.resetCacheKeys(konyRef);
       }
     }
     if (!isAsync) {
       return kony.sdk.error.getLogicErrObj(err);
     } else if (callBack) {
       kony.sdk.verifyAndCallClosure(callBack, kony.sdk.error.getLogicErrObj(err));
     }
   };
 };
 kony.sdk.prototype.registerObjectService = function(objectServiceType, objectServiceClass) {
   kony.sdk.logsdk.trace("Entering kony.sdk.prototype.registerObjectService");
   kony.sdk.registeredobjsvcs = kony.sdk.registeredobjsvcs || {};
   kony.sdk.registeredobjsvcs[objectServiceType] = objectServiceClass;
 };
 /**
  * Method to create the object service instance with the provided service name.
  * @param {string} serviceName - Name of the service
  * @param {map} options - Map of key values like {"access":"offline"/"online"/"registered Object Service Name"}
  * @returns {@link kony.sdk.OnlineObjectService / @link kony.sdk.OfflineObjectService} Object service instance
  * @throws Exception if the serviceName or access is invalid.
  */
 kony.sdk.prototype.getObjectService = function(serviceName, options) {
   kony.sdk.logsdk.perf("Executing kony.sdk.prototype.getObjectService");
   if (!kony.sdk.isInitialized) {
     kony.sdk.logsdk.perf("Executing finished kony.sdk.prototype.getObjectService with an exception");
     throw new Exception(kony.sdk.errorConstants.INIT_FAILURE, kony.sdk.constants.INIT_FAILURE_MESSAGE + " Object service - " + serviceName);
   }
   var access;
   if (!kony.sdk.isNullOrUndefined(options)) {
     access = options["access"];
   }
   if (this.objectsvc != null && this.objectsvc[serviceName] != null) {
     kony.sdk.logsdk.debug("### getObjectService::found Object service" + this.objectsvc[serviceName]);
     if (kony.sdk.util.isNullOrEmptyString(access) || access.toLowerCase() === "online") {
       kony.sdk.logsdk.perf("Executing Finished kony.sdk.prototype.getObjectService");
       return new kony.sdk.OnlineObjectService(this, serviceName, this.objectsvc[serviceName]);
     } else if (access.toLowerCase() === "offline") {
       kony.sdk.logsdk.perf("Executing Finished kony.sdk.prototype.getObjectService");
       //This returns SyncV1 object service
       return new kony.sdk.OfflineObjectService(this, serviceName);
     }
   } else if (this.offlineObjectsvc != null) {
     if (this.offlineObjectsvc[serviceName] != null) {
       if (kony.sdk.util.isNullOrEmptyString(access) || access.toLowerCase() === "online") {
         kony.sdk.logsdk.perf("Executing Finished kony.sdk.prototype.getObjectService");
         // This returns Online Object Service Instance
         return new kony.sdk.OnlineObjectService(this, serviceName, this.offlineObjectsvc[serviceName]);
       } else if (access.toLowerCase() === "offline") {
         kony.sdk.logsdk.perf("Executing Finished kony.sdk.prototype.getObjectService");
         //This returns Offline Enabled or SyncV2 object service
         return new kony.sdk.OfflineEnabledObjectService(this, serviceName);
       }
     }
   }
   kony.sdk.registeredobjsvcs = kony.sdk.registeredobjsvcs || {};
   kony.sdk.logsdk.perf("Executing Finished kony.sdk.prototype.getObjectService");
   //verifying if the servicetype available in registeredservices if available initialize and return
   if (kony.sdk.registeredobjsvcs[access] != null && kony.sdk.registeredobjsvcs[access] != undefined) {
     return new kony.sdk.registeredobjsvcs[access](this, serviceName);
   }
   throw new Exception(kony.sdk.errorConstants.OBJECT_FAILURE, "Invalid serviceName:" + serviceName + "or access type:" + access);
 };
 /**
  * Method which returns the online ObjectService object
  * @param konyRef
  * @param serviceName
  * @constructor
  */
 kony.sdk.OnlineObjectService = function(konyRef, serviceName, serviceInfo) {
   kony.sdk.logsdk.perf("Executing kony.sdk.OnlineObjectService");
   this.konyRef = konyRef;
   this.serviceName = serviceName;
   this.serviceInfo = serviceInfo;
   this.dataUrl = null;
   this.binaryUrl = null;
   this.fileStorageObjectServiceUrl = null;
   this.operationsUrl = null;
   this.metadataUrl = null;
   this.version = null;
   var currentObject = this;
   /**
    * This method is used to create a record on the object
    * @param {map} options - includes {"dataObject":(@link kony.sdk.dto.DataObject),"headers":<map of http headers>}
    * @param successCallback
    * @param failureCallback
    */
   this.create = function(options, successCallback, failureCallback) {
     kony.sdk.logsdk.trace("Entering kony.sdk.OnlineObjectService.create");
     if (options == null || options == undefined) {
       kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getClientErrObj(kony.sdk.errorcodes.null_or_undefined, "options" + kony.sdk.errormessages.null_or_undefined));
       return;
     }
     if (!(options["dataObject"] instanceof kony.sdk.dto.DataObject)) {
       kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getClientErrObj(kony.sdk.errorcodes.invalid_dataobject_instance, kony.sdk.errormessages.invalid_dataobject_instance));
       return;
     }
     if (!(options["queryParams"] == null || options["queryParams"] == undefined)) {
       if (!(options["queryParams"] instanceof Object)) {
         kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getClientErrObj(kony.sdk.errorcodes.invalid_queryparams_instance, kony.sdk.errormessages.invalid_queryparams_instance));
       }
     }
     var tmpDataUrl = this.getDataUrl();
     var objName = options["dataObject"].objectName;

     function createOperationHandler() {
       currentObject.getMetadataOfObject(objName, {}, function(result) {
         _create(options, tmpDataUrl, successCallback, failureCallback);
       }, function(error) {
         kony.sdk.logsdk.error("### OnlineObjectService::create Error:", error);
         kony.sdk.verifyAndCallClosure(failureCallback, error);
       });
     }
     if (kony.sdk.skipAnonymousCall) {
       createOperationHandler();
     } else {
       kony.sdk.claimsRefresh(createOperationHandler, failureCallback);
     }
   };
   /**
    * This method is used to fetch a record on the object
    * @param {map} options - includes {"dataObject":(@link kony.sdk.dto.DataObject),"headers":<map of http headers>}
    * @param successCallback
    * @param failureCallback
    */
   this.fetch = function(options, successCallback, failureCallback) {
     kony.sdk.logsdk.trace("Entering kony.sdk.OnlineObjectService.fetch");
     if (options == null || options == undefined) {
       kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getClientErrObj(kony.sdk.errorcodes.null_or_undefined, "options" + kony.sdk.errormessages.null_or_undefined));
       return;
     }
     if (!(options["dataObject"] instanceof kony.sdk.dto.DataObject)) {
       kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getClientErrObj(kony.sdk.errorcodes.invalid_dataobject_instance, kony.sdk.errormessages.invalid_dataobject_instance));
       return;
     }
     if (!(options["queryParams"] == null || options["queryParams"] == undefined)) {
       if (!(options["queryParams"] instanceof Object)) {
         kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getClientErrObj(kony.sdk.errorcodes.invalid_queryparams_instance, kony.sdk.errormessages.invalid_queryparams_instance));
       }
     }
     var tmpDataUrl = this.getDataUrl();
     var objName = options["dataObject"].objectName;

     function fetchOperationHandler() {
       currentObject.getMetadataOfObject(objName, {}, function(result) {
         _fetch(options, tmpDataUrl, successCallback, failureCallback);
       }, function(error) {
         kony.sdk.logsdk.error("### OnlineObjectService::fetch Error:", error);
         kony.sdk.verifyAndCallClosure(failureCallback, error);
       });
     }
     if (kony.sdk.skipAnonymousCall) {
       fetchOperationHandler();
     } else {
       kony.sdk.claimsRefresh(fetchOperationHandler, failureCallback);
     }
   };
   /**
    * This method is used to update a record on the object
    * @param {map} options - includes {"dataObject":(@link kony.sdk.dto.DataObject),"headers":<map of http headers>}
    * @param successCallback
    * @param failureCallback
    */
   this.update = function(options, successCallback, failureCallback) {
     kony.sdk.logsdk.trace("Entering kony.sdk.OnlineObjectService.update");
     if (options == null || options == undefined) {
       kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getClientErrObj(kony.sdk.errorcodes.null_or_undefined, "options" + kony.sdk.errormessages.null_or_undefined));
       return;
     }
     if (!(options["dataObject"] instanceof kony.sdk.dto.DataObject)) {
       kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getClientErrObj(kony.sdk.errorcodes.invalid_dataobject_instance, kony.sdk.errormessages.invalid_dataobject_instance));
       return;
     }
     if (!(options["queryParams"] == null || options["queryParams"] == undefined)) {
       if (!(options["queryParams"] instanceof Object)) {
         kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getClientErrObj(kony.sdk.errorcodes.invalid_queryparams_instance, kony.sdk.errormessages.invalid_queryparams_instance));
         return;
       }
     }
     var tmpDataUrl = this.getDataUrl();
     var objName = options["dataObject"].objectName;

     function updateOperationHandler() {
       currentObject.getMetadataOfObject(objName, {}, function(result) {
         _update(options, tmpDataUrl, successCallback, failureCallback);
       }, function(error) {
         kony.sdk.logsdk.error("### OnlineObjectService::update Error:", error);
         kony.sdk.verifyAndCallClosure(failureCallback, error);
       });
     }
     if (kony.sdk.skipAnonymousCall) {
       updateOperationHandler();
     } else {
       kony.sdk.claimsRefresh(updateOperationHandler, failureCallback);
     }
   };
   /**
    * This method is used to partial update a record on the object
    * @param {map} options - includes {"dataObject":(@link kony.sdk.dto.DataObject),"headers":<map of http headers>}
    * @param successCallback
    * @param failureCallback
    */
   this.partialUpdate = function(options, successCallback, failureCallback) {
     kony.sdk.logsdk.trace("Entering kony.sdk.OnlineObjectService.partialUpdate");
     if (options == null || options == undefined) {
       kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getClientErrObj(kony.sdk.errorcodes.null_or_undefined, "options" + kony.sdk.errormessages.null_or_undefined));
       return;
     }
     if (!(options["dataObject"] instanceof kony.sdk.dto.DataObject)) {
       kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getClientErrObj(kony.sdk.errorcodes.invalid_dataobject_instance, kony.sdk.errormessages.invalid_dataobject_instance));
       return;
     }
     if (!(options["queryParams"] == null || options["queryParams"] == undefined)) {
       if (!(options["queryParams"] instanceof Object)) {
         kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getClientErrObj(kony.sdk.errorcodes.invalid_queryparams_instance, kony.sdk.errormessages.invalid_queryparams_instance));
         return;
       }
     }
     var tmpDataUrl = this.getDataUrl();
     var objName = options["dataObject"].objectName;

     function partialUpdateOperationHandler() {
       currentObject.getMetadataOfObject(objName, {}, function(result) {
         _partialUpdate(options, tmpDataUrl, successCallback, failureCallback);
       }, function(error) {
         kony.sdk.logsdk.error("### OnlineObjectService::partialUpdate Error:", error);
         kony.sdk.verifyAndCallClosure(failureCallback, error);
       });
     }
     if (kony.sdk.skipAnonymousCall) {
       partialUpdateOperationHandler();
     } else {
       kony.sdk.claimsRefresh(partialUpdateOperationHandler, failureCallback);
     }
   };
   /**
    * This method is used to delete a record on the object
    * @param {map} options - includes {"dataObject":(@link kony.sdk.dto.DataObject),"headers":<map of http headers>}
    * @param successCallback
    * @param failureCallback
    */
   this.deleteRecord = function(options, successCallback, failureCallback) {
     kony.sdk.logsdk.trace("Entering kony.sdk.OnlineObjectService.deleteRecord");
     if (options == null || options == undefined) {
       kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getClientErrObj(kony.sdk.errorcodes.null_or_undefined, "options" + kony.sdk.errormessages.null_or_undefined));
       return;
     }
     if (!(options["dataObject"] instanceof kony.sdk.dto.DataObject)) {
       kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getClientErrObj(kony.sdk.errorcodes.invalid_dataobject_instance, kony.sdk.errormessages.invalid_dataobject_instance));
       return;
     }
     if (!(options["queryParams"] == null || options["queryParams"] == undefined)) {
       if (!(options["queryParams"] instanceof Object)) {
         kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getClientErrObj(kony.sdk.errorcodes.invalid_queryparams_instance, kony.sdk.errormessages.invalid_queryparams_instance));
         return;
       }
     }
     var tmpDataUrl = this.getDataUrl();
     var objName = options["dataObject"].objectName;

     function deleteOperationHandler() {
       currentObject.getMetadataOfObject(objName, {}, function(result) {
         _deleteRecord(options, tmpDataUrl, successCallback, failureCallback);
       }, function(error) {
         kony.sdk.logsdk.error("### OnlineObjectService::delete Error:", error);
         kony.sdk.verifyAndCallClosure(failureCallback, error);
       });
     }
     if (kony.sdk.skipAnonymousCall) {
       deleteOperationHandler();
     } else {
       kony.sdk.claimsRefresh(deleteOperationHandler, failureCallback);
     }
   };
   /**
    * This method is used to for performing custom operation
    * @param {string} verbName -  custom verb identifier
    * @param {map} options - includes {"dataObject":(@link kony.sdk.dto.DataObject),"headers":<map of http headers>}
    * @param successCallback
    * @param failureCallback
    */
   this.customVerb = function(verbName, options, successCallback, failureCallback) {
     kony.sdk.logsdk.trace("Entering kony.sdk.OnlineObjectService.customVerb");
     if (verbName == null || verbName == undefined) {
       kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getClientErrObj(kony.sdk.errorcodes.null_or_undefined, "verbName" + kony.sdk.errormessages.null_or_undefined));
       return;
     }
     if (options == null || options == undefined) {
       kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getClientErrObj(kony.sdk.errorcodes.null_or_undefined, "options" + kony.sdk.errormessages.null_or_undefined));
       return;
     }
     if (!(options["dataObject"] instanceof kony.sdk.dto.DataObject)) {
       kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getClientErrObj(kony.sdk.errorcodes.invalid_dataobject_instance, kony.sdk.errormessages.invalid_dataobject_instance));
       return;
     }
     if (!(options["queryParams"] == null || options["queryParams"] == undefined)) {
       if (!(options["queryParams"] instanceof Object)) {
         kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getClientErrObj(kony.sdk.errorcodes.invalid_queryparams_instance, kony.sdk.errormessages.invalid_queryparams_instance));
         return;
       }
     }
     var tmpDataUrl = this.getOperationsUrl();
     var objName = options["dataObject"].objectName;

     function customVerbHandler() {
       currentObject.getMetadataOfObject(objName, {}, function(result) {
         _customverb(verbName, options, tmpDataUrl, successCallback, failureCallback);
       }, function(error) {
         kony.sdk.logsdk.error("### OnlineObjectService::customverb Error:", error);
         kony.sdk.verifyAndCallClosure(failureCallback, error);
       });
     }
     if (kony.sdk.skipAnonymousCall) {
       customVerbHandler();
     } else {
       kony.sdk.claimsRefresh(customVerbHandler, failureCallback);
     }
   };
   /**
    * This method is used to retrive metadata of all objects
    * @param {map} options - includes {"getFromServer":boolean,"headers":<map of http headers>}
    * @param successCallback
    * @param failureCallback
    */
   this.getMetadataOfAllObjects = function(options, successCallback, failureCallback) {
     kony.sdk.logsdk.trace("Entering kony.sdk.OnlineObjectService.getMetadataOfAllObjects");
     _getMetadataForObjectsOrServiceOnlineUtil(konyRef, serviceName, null, options, successCallback, failureCallback);
     kony.sdk.logsdk.trace("Exiting kony.sdk.OnlineObjectService.getMetadataOfAllObjects");
   };
   /**
    * This method is used to retrive metadata of a specific object
    * @param objectName
    * @param {map} options - includes {"getFromServer":boolean,"headers":<map of http headers>}
    * @param successCallback
    * @param failureCallback
    */
   this.getMetadataOfObject = function(objectName, options, successCallback, failureCallback) {
     kony.sdk.logsdk.trace("Entering kony.sdk.OnlineObjectService.getMetadataOfObject");
     _getMetadataForObjectsOrServiceOnlineUtil(konyRef, serviceName, objectName, options, successCallback, failureCallback);
     kony.sdk.logsdk.trace("Exiting kony.sdk.OnlineObjectService.getMetadataOfObject");
   };
   this.getDataUrl = function() {
     if (kony.sdk.isNullOrUndefined(currentObject.dataUrl)) {
       currentObject.dataUrl = encodeURI(stripTrailingCharacter(currentObject.serviceInfo["url"] + "/objects/", "/"));
     }
     return currentObject.dataUrl;
   };
   this.getFileStorageObjectServiceUrl = function() {
     if (kony.sdk.isNullOrUndefined(currentObject.fileStorageObjectServiceUrl)) {
       currentObject.fileStorageObjectServiceUrl = encodeURI(stripTrailingCharacter(currentObject.serviceInfo["url"], "/"));
     }
     return currentObject.fileStorageObjectServiceUrl;
   };
   this.getBinaryUrl = function() {
     if (kony.sdk.isNullOrUndefined(currentObject.binaryUrl)) {
       currentObject.binaryUrl = encodeURI(stripTrailingCharacter(currentObject.serviceInfo["url"] + "/binary/", "/"));
     }
     return currentObject.binaryUrl;
   };
   this.getOperationsUrl = function() {
     if (kony.sdk.isNullOrUndefined(currentObject.operationsUrl)) {
       currentObject.operationsUrl = encodeURI(stripTrailingCharacter(currentObject.serviceInfo["url"] + "/operations/", "/"));
     }
     return currentObject.operationsUrl;
   };
   this.getMetadataUrl = function() {
     if (kony.sdk.isNullOrUndefined(currentObject.metadataUrl)) {
       currentObject.metadataUrl = encodeURI(stripTrailingCharacter(currentObject.serviceInfo["metadata_url"], "/"));
     }
     return currentObject.metadataUrl;
   };
   this.getVersion = function() {
     if (kony.sdk.isNullOrUndefined(currentObject.version)) {
       currentObject.version = currentObject.serviceInfo["version"];
     }
     return currentObject.version;
   };
   /*
    *  API for uploading binary data (either file or raw bytes) to backend
    */
   this.uploadBinaryData = function(options, onFileUploadStartedCallback, onChunkUploadCompletedCallback, onFileUploadCompletedCallback, onFileUploadFailureCallback) {
     var fileUploadStartedCallback = null;
     var chunkUploadCompletedCallback = null;
     var fileUploadCompletedCallback = null;
     var fileUploadFailureCallback = null;
     var uploadParams = null;
     /* validations for callbacks */
     // validation for onFileUploadStartedCallback
     if (kony.sdk.isNullOrUndefined(onFileUploadStartedCallback) || (typeof(onFileUploadStartedCallback) !== 'function')) {
       kony.sdk.logsdk.warn("### OnlineObjectService::uploadBinaryData onFileUploadStartedCallback is null or undefined or not a function");
     } else {
       fileUploadStartedCallback = onFileUploadStartedCallback;
     }
     // validation for onChunkUploadCompletedCallback
     if (kony.sdk.isNullOrUndefined(onChunkUploadCompletedCallback) || (typeof(onChunkUploadCompletedCallback) !== 'function')) {
       kony.sdk.logsdk.warn("### OnlineObjectService::uploadBinaryData onChunkUploadCompletedCallback is null or undefined or not a function");
     } else {
       chunkUploadCompletedCallback = onChunkUploadCompletedCallback;
     }
     // validation for onFileUploadCompletedCallback
     if (kony.sdk.isNullOrUndefined(onFileUploadCompletedCallback) || (typeof(onFileUploadCompletedCallback) !== 'function')) {
       kony.sdk.logsdk.warn("### OnlineObjectService::uploadBinaryData onFileUploadCompletedCallback is null or undefined or not a function");
     } else {
       fileUploadCompletedCallback = onFileUploadCompletedCallback;
     }
     // validation for onFileUploadFailureCallback
     if (kony.sdk.isNullOrUndefined(onFileUploadFailureCallback) || (typeof(onFileUploadFailureCallback) !== 'function')) {
       kony.sdk.logsdk.warn("### OnlineObjectService::uploadBinaryData onFileUploadFailureCallback is null or undefined or not a function");
     } else {
       fileUploadFailureCallback = onFileUploadFailureCallback;
     }
     // validation for options
     if (kony.sdk.isNullOrUndefined(options)) {
       kony.sdk.logsdk.error("### OnlineObjectService::uploadBinaryData options is null or undefined");
       kony.sdk.verifyAndCallClosure(fileUploadFailureCallback, kony.sdk.error.getClientErrObj(kony.sdk.errorcodes.null_or_undefined, "options " + kony.sdk.errormessages.null_or_undefined));
       return;
     }
     var dataObject = options["dataObject"];
     if (kony.sdk.isNullOrUndefined(dataObject)) {
       kony.sdk.verifyAndCallClosure(fileUploadFailureCallback, kony.sdk.error.getClientErrObj(kony.sdk.errorcodes.invalid_dataobject_instance, kony.sdk.errormessages.invalid_dataobject_instance));
       return;
     }
     if (!(dataObject instanceof kony.sdk.dto.DataObject)) {
       kony.sdk.verifyAndCallClosure(fileUploadFailureCallback, kony.sdk.error.getClientErrObj(kony.sdk.errorcodes.invalid_dataobject_instance, kony.sdk.errormessages.invalid_dataobject_instance));
       return;
     }
     var objName = dataObject.getObjectName();
     var mfEndpointUrl = this.getDataUrl() + "/" + objName;
     if (kony.sdk.isNullOrUndefined(dataObject.getRecord())) {
       kony.sdk.logsdk.error("### OnlineObjectService::uploadBinaryData Error: Please provide record to upload Binary content.");
       kony.sdk.verifyAndCallClosure(fileUploadFailureCallback, kony.sdk.error.getClientErrObj(kony.sdk.errorcodes.primarykey_unavailable, kony.sdk.errormessages.primarykey_unavailable));
       return;
     }
     uploadParams = dataObject.getRecord();
     var errorObj = kony.sdk.binary.validateUploadParams(uploadParams);
     if (errorObj) {
       kony.sdk.verifyAndCallClosure(fileUploadFailureCallback, errorObj);
       return;
     }
     // if rawbytes are provided, converting to base64 string as FFI can only receive base datatypes
     if (!kony.sdk.isNullOrUndefined(uploadParams[kony.sdk.constants.RAW_BYTES])) {
       var base64String = kony.convertToBase64(uploadParams[kony.sdk.constants.RAW_BYTES]);
       uploadParams[kony.sdk.constants.RAW_BYTES] = base64String;
     }

     function uploadBinaryDataOperationHandler() {
       currentObject.getMetadataOfObject(objName, {}, function(response) {
         _uploadBinaryData(mfEndpointUrl, uploadParams, fileUploadStartedCallback, chunkUploadCompletedCallback, fileUploadCompletedCallback, fileUploadFailureCallback);
       }, function(error) {
         kony.sdk.logsdk.error("### OnlineObjectService::uploadBinaryData Error:", error);
         kony.sdk.verifyAndCallClosure(fileUploadFailureCallback, error);
       });
     }
     if (kony.sdk.skipAnonymousCall) {
       uploadBinaryDataOperationHandler();
     } else {
       kony.sdk.claimsRefresh(uploadBinaryDataOperationHandler, fileUploadFailureCallback);
     }
   };
   /*
    * Helper method to perform file upload
    */
   function _uploadBinaryData(mfEndpointUrl, uploadParams, fileUploadStartedCallback, chunkUploadCompletedCallback, fileUploadCompletedCallback, fileUploadFailureCallback) {
     var uploadOptions = {};
     if (uploadParams) {
       //Extracting Mandatory Params from uploadParams before fetching template
       if (uploadParams[kony.sdk.constants.FILE_PATH]) {
         uploadOptions[kony.sdk.constants.FILE_PATH] = uploadParams[kony.sdk.constants.FILE_PATH];
         delete uploadParams[kony.sdk.constants.FILE_PATH];
       } else if (uploadParams[kony.sdk.constants.RAW_BYTES]) {
         uploadOptions[kony.sdk.constants.RAW_BYTES] = uploadParams[kony.sdk.constants.RAW_BYTES];
         delete uploadParams[kony.sdk.constants.RAW_BYTES];
       } else if (uploadParams[kony.sdk.constants.FILE_OBJECT]) {
         uploadOptions[kony.sdk.constants.FILE_OBJECT] = uploadParams[kony.sdk.constants.FILE_OBJECT];
         delete uploadParams[kony.sdk.constants.FILE_OBJECT]
       }
       uploadOptions["uploadParams"] = uploadParams;
     }
     var headers = kony.sdk.getDefaultHeaders();
     if (!kony.sdk.skipAnonymousCall) {
       headers[kony.sdk.constants.KONY_AUTHORIZATION_HEADER] = kony.sdk.getCurrentInstance().currentClaimToken;
     }
     uploadOptions["headers"] = headers;
     uploadOptions["URL"] = mfEndpointUrl;
     kony.sdk.binary.uploadBinaryData(uploadOptions, fileUploadStartedCallback, chunkUploadCompletedCallback, fileUploadCompletedCallback, fileUploadFailureCallback);
   }
   this.getBinaryData = function(options, arg1, arg2, arg3, arg4, arg5) {
     var externalSource = true;
     var fileDownloadStartedCallback = null;
     var chunkDownloadCompletedCallback = null;
     var fileDownloadCompletedCallback = null;
     var downloadFailureCallback = null;
     var binaryAttributeName = null;
     if (kony.sdk.isNullOrUndefined(arg5)) {
       if (kony.sdk.isNullOrUndefined(arg1)) {
         kony.sdk.logsdk.warn("### OnlineObjectService::getBinaryData fileDownloadStartedCallback is null or undefined");
       } else if (typeof(arg1) === 'function') {
         fileDownloadStartedCallback = arg1;
       } else {
         kony.sdk.logsdk.warn("### OnlineObjectService::getBinaryData invalid param provided for fileDownloadStartedCallback");
       }
       if (kony.sdk.isNullOrUndefined(arg2)) {
         kony.sdk.logsdk.warn("### OnlineObjectService::getBinaryData chunkDownloadCompletedCallback is null or undefined");
       } else if (typeof(arg2) === 'function') {
         chunkDownloadCompletedCallback = arg2;
       } else {
         kony.sdk.logsdk.warn("### OnlineObjectService::getBinaryData invalid param provided for chunkDownloadCompletedCallback");
       }
       if (kony.sdk.isNullOrUndefined(arg3)) {
         kony.sdk.logsdk.warn("### OnlineObjectService::getBinaryData fileDownloadCompletedCallback is null or undefined");
       } else if (typeof(arg3) === 'function') {
         fileDownloadCompletedCallback = arg3;
       } else {
         kony.sdk.logsdk.warn("### OnlineObjectService::getBinaryData invalid param provided for fileDownloadCompletedCallback");
       }
       if (kony.sdk.isNullOrUndefined(arg4)) {
         kony.sdk.logsdk.warn("### OnlineObjectService::getBinaryData downloadFailureCallback is null or undefined");
       } else if (typeof(arg4) === 'function') {
         downloadFailureCallback = arg4;
       } else {
         kony.sdk.logsdk.warn("### OnlineObjectService::getBinaryData invalid param provided for downloadFailureCallback");
       }
     } else {
       binaryAttributeName = arg1;
       externalSource = false;
       if (kony.sdk.isNullOrUndefined(arg2)) {
         kony.sdk.logsdk.warn("### OnlineObjectService::getBinaryData fileDownloadStartedCallback is null or undefined");
       } else if (typeof(arg2) === 'function') {
         fileDownloadStartedCallback = arg2;
       } else {
         kony.sdk.logsdk.warn("### OnlineObjectService::getBinaryData invalid param provided for fileDownloadStartedCallback");
       }
       if (kony.sdk.isNullOrUndefined(arg3)) {
         kony.sdk.logsdk.warn("### OnlineObjectService::getBinaryData chunkDownloadCompletedCallback is null or undefined");
       } else if (typeof(arg3) === 'function') {
         chunkDownloadCompletedCallback = arg3;
       } else {
         kony.sdk.logsdk.warn("### OnlineObjectService::getBinaryData invalid param provided for chunkDownloadCompletedCallback");
       }
       if (kony.sdk.isNullOrUndefined(arg4)) {
         kony.sdk.logsdk.warn("### OnlineObjectService::getBinaryData fileDownloadCompletedCallback is null or undefined");
       } else if (typeof(arg4) === 'function') {
         fileDownloadCompletedCallback = arg4;
       } else {
         kony.sdk.logsdk.warn("### OnlineObjectService::getBinaryData invalid param provided for fileDownloadCompletedCallback");
       }
       if (kony.sdk.isNullOrUndefined(arg5)) {
         kony.sdk.logsdk.warn("### OnlineObjectService::getBinaryData downloadFailureCallback is null or undefined");
       } else if (typeof(arg5) === 'function') {
         downloadFailureCallback = arg5;
       } else {
         kony.sdk.logsdk.warn("### OnlineObjectService::getBinaryData invalid param provided for downloadFailureCallback");
       }
     }
     if (kony.sdk.getSdkType() !== kony.sdk.constants.SDK_TYPE_IDE && kony.sdk.getAType() !== kony.sdk.constants.SDK_ATYPE_NATIVE) {
       kony.sdk.verifyAndCallClosure(downloadFailureCallback, kony.sdk.error.getClientErrObj(kony.sdk.errorcodes.invalid_api, kony.sdk.errormessages.invalid_api + "platform :" + kony.sdk.getSdkType().toString()));
       return;
     }
     if (kony.sdk.isNullOrUndefined(options)) {
       kony.sdk.verifyAndCallClosure(downloadFailureCallback, kony.sdk.error.getClientErrObj(kony.sdk.errorcodes.null_or_undefined, "options" + kony.sdk.errormessages.null_or_undefined));
       return;
     }
     var tmpDataUrl = null;
     if (externalSource) {
       tmpDataUrl = this.getDataUrl();
     } else {
       tmpDataUrl = this.getBinaryUrl();
     }
     var dataObject = options["dataObject"];
     if (!(dataObject instanceof kony.sdk.dto.DataObject)) {
       kony.sdk.verifyAndCallClosure(downloadFailureCallback, kony.sdk.error.getClientErrObj(kony.sdk.errorcodes.invalid_dataobject_instance, kony.sdk.errormessages.invalid_dataobject_instance));
       return;
     }
     if (!(kony.sdk.isNullOrUndefined(options["queryParams"]))) {
       if (!(options["queryParams"] instanceof Object)) {
         kony.sdk.verifyAndCallClosure(downloadFailureCallback, kony.sdk.error.getClientErrObj(kony.sdk.errorcodes.invalid_queryparams_instance, kony.sdk.errormessages.invalid_queryparams_instance));
         return;
       }
     }
     var objName = dataObject.getObjectName();
     var streamingFlag = false;
     if (!kony.sdk.isNullOrUndefined(options["streaming"]) && options["streaming"] === true) {
       streamingFlag = true;
     }
     if (!externalSource) {
       if (kony.sdk.isNullOrUndefined(binaryAttributeName) || typeof(binaryAttributeName) !== "string") {
         kony.sdk.logsdk.error("### OnlineObjectService::getBinaryData Error: Please provide column name to fetch binary content");
         kony.sdk.verifyAndCallClosure(downloadFailureCallback, kony.sdk.error.getClientErrObj("90000", "Please provide column name to fetch binary content"));
         return;
       } else {
         options["binaryAttrName"] = binaryAttributeName;
       }
     }
     if (kony.sdk.isNullOrUndefined(dataObject.getRecord())) {
       kony.sdk.logsdk.error("### OnlineObjectService::_getBinaryData Error: Please provide primary key details or fileParams to get Binary content.");
       kony.sdk.verifyAndCallClosure(downloadFailureCallback, kony.sdk.error.getClientErrObj(kony.sdk.errorcodes.primarykey_unavailable, kony.sdk.errormessages.primarykey_unavailable));
       return;
     }

     function getBinaryDataOperationHandler() {
       currentObject.getMetadataOfObject(objName, {}, function(response) {
         _getBinaryData(options, tmpDataUrl, externalSource, streamingFlag, fileDownloadStartedCallback, chunkDownloadCompletedCallback, fileDownloadCompletedCallback, downloadFailureCallback);
       }, function(error) {
         kony.sdk.logsdk.error("### OnlineObjectService::getBinaryData Error:", error);
         kony.sdk.verifyAndCallClosure(downloadFailureCallback, error);
       });
     }
     if (kony.sdk.skipAnonymousCall) {
       getBinaryDataOperationHandler();
     } else {
       kony.sdk.claimsRefresh(getBinaryDataOperationHandler, downloadFailureCallback);
     }
   };
   /**
    * Helps to get the binary content of the specified column on the Object
    * @param {map} options - includes {"dataObject":{@link kony.sdk.dto.DataObject}, "binaryAttrName":columnName}
    * @param successCallback
    * @param failureCallback
    */
   this.getBinaryContent = function(options, successCallback, failureCallback) {
     kony.sdk.logsdk.trace("Entering kony.sdk.OnlineObjectService.getBinaryContent");
     if (options == null || options == undefined) {
       kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getClientErrObj(kony.sdk.errorcodes.null_or_undefined, "options" + kony.sdk.errormessages.null_or_undefined));
       return;
     }
     var tmpDataUrl = this.getBinaryUrl();
     var dataObject = options["dataObject"];
     if (!(dataObject instanceof kony.sdk.dto.DataObject)) {
       kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getClientErrObj(kony.sdk.errorcodes.invalid_dataobject_instance, kony.sdk.errormessages.invalid_dataobject_instance));
       return;
     }
     if (!(options["queryParams"] == null || options["queryParams"] == undefined)) {
       if (!(options["queryParams"] instanceof Object)) {
         kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getClientErrObj(kony.sdk.errorcodes.invalid_queryparams_instance, kony.sdk.errormessages.invalid_queryparams_instance));
         return;
       }
     }
     var objName = dataObject.getObjectName();
     var binaryColName = options["binaryAttrName"];
     if (binaryColName == null || binaryColName == undefined) {
       kony.sdk.logsdk.error("### OnlineObjectService::getBinaryContent Error: Please provide column name to fetch binary content");
       kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getClientErrObj("90000", "Please provide column name to fetch binary content"));
       return;
     }

     function getBinaryContentOperationHandler() {
       currentObject.getMetadataOfObject(objName, {}, function(response) {
         _getBinaryContent(options, tmpDataUrl, successCallback, failureCallback);
       }, function(error) {
         kony.sdk.logsdk.error("### OnlineObjectService::getBinaryContent Error:", error);
         kony.sdk.verifyAndCallClosure(failureCallback, error);
       });
     }
     if (kony.sdk.skipAnonymousCall) {
       getBinaryContentOperationHandler();
     } else {
       kony.sdk.claimsRefresh(getBinaryContentOperationHandler, failureCallback);
     }
   };
   /**
    * Helps to create the binary content of the specified column on the Object
    * @param {map} options - includes {"dataObject": {@link kony.sdk.dto.DataObject}, "binaryAttrName":columnName}
    * @param successCallback
    * @param failureCallback
    */
   this.createBinaryContent = function(options, successCallback, failureCallback) {
     kony.sdk.logsdk.trace("Entering kony.sdk.OnlineObjectService.createBinaryContent");
     var tmpDataUrl = this.getBinaryUrl();
     if (options == null || options == undefined) {
       kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getClientErrObj(kony.sdk.errorcodes.null_or_undefined, "options" + kony.sdk.errormessages.null_or_undefined));
       return;
     }
     var dataObject = options["dataObject"];
     if (!(dataObject instanceof kony.sdk.dto.DataObject)) {
       kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getClientErrObj(kony.sdk.errorcodes.invalid_dataobject_instance, kony.sdk.errormessages.invalid_dataobject_instance));
       return;
     }
     if (!(options["queryParams"] == null || options["queryParams"] == undefined)) {
       if (!(options["queryParams"] instanceof Object)) {
         kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getClientErrObj(kony.sdk.errorcodes.invalid_queryparams_instance, kony.sdk.errormessages.invalid_queryparams_instance));
         return;
       }
     }
     var objName = dataObject.getObjectName();
     var binaryColName = options["binaryAttrName"];
     if (binaryColName == null || binaryColName == undefined) {
       kony.sdk.logsdk.error("### OnlineObjectService::createBinaryContent Error: Please provide column name to create binary content");
       kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getClientErrObj("900000", "Please provide column name to create binary content"));
       return;
     }

     function createBinaryContentOperationHandler() {
       currentObject.getMetadataOfObject(objName, {}, function(response) {
         _createBinaryContent(options, tmpDataUrl, successCallback, failureCallback);
       }, function(error) {
         kony.sdk.logsdk.error("### OnlineObjectService::createBinaryContent Error:", error);
         kony.sdk.verifyAndCallClosure(failureCallback, error);
       });
     }
     if (kony.sdk.skipAnonymousCall) {
       createBinaryContentOperationHandler();
     } else {
       kony.sdk.claimsRefresh(createBinaryContentOperationHandler, failureCallback);
     }
   };
   /**
    * Helps to update the binary content of the specified column on the Object
    * @param {map} options - includes {"dataObject": {@link kony.sdk.dto.DataObject}, "binaryAttrName":columnName}
    * @param successCallback
    * @param failureCallback
    */
   this.updateBinaryContent = function(options, successCallback, failureCallback) {
     kony.sdk.logsdk.trace("Entering kony.sdk.OnlineObjectService.updateBinaryContent");
     var tmpDataUrl = this.getBinaryUrl();
     if (options == null || options == undefined) {
       kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getClientErrObj(kony.sdk.errorcodes.null_or_undefined, "options" + kony.sdk.errormessages.null_or_undefined));
       return;
     }
     var dataObject = options["dataObject"];
     if (!(dataObject instanceof kony.sdk.dto.DataObject)) {
       kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getClientErrObj(kony.sdk.errorcodes.invalid_dataobject_instance, kony.sdk.errormessages.invalid_dataobject_instance));
       return;
     }
     if (!(options["queryParams"] == null || options["queryParams"] == undefined)) {
       if (!(options["queryParams"] instanceof Object)) {
         kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getClientErrObj(kony.sdk.errorcodes.invalid_queryparams_instance, kony.sdk.errormessages.invalid_queryparams_instance));
         return;
       }
     }
     var objName = dataObject.getObjectName();
     var binaryColName = options["binaryAttrName"];
     if (binaryColName == null || binaryColName == undefined) {
       kony.sdk.logsdk.error("### OnlineObjectService::updateBinaryContent Error: Please provide column name to create binary content");
       kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getClientErrObj("90000", "Please provide column name to create binary content"));
       return;
     }

     function updateBinaryContentOperationHandler() {
       currentObject.getMetadataOfObject(objName, {}, function(response) {
         _updateBinaryContent(options, tmpDataUrl, successCallback, failureCallback);
       }, function(error) {
         kony.sdk.logsdk.error("### OnlineObjectService::updateBinaryContent Error:", error);
         kony.sdk.verifyAndCallClosure(failureCallback, error);
       });
     }
     if (kony.sdk.skipAnonymousCall) {
       updateBinaryContentOperationHandler();
     } else {
       kony.sdk.claimsRefresh(updateBinaryContentOperationHandler, failureCallback);
     }
   };

   function _getBinaryContent(options, tmpDataUrl, successCallback, failureCallback) {
     var dataObject = options["dataObject"];
     var headers = options["headers"];
     var binaryColName = options["binaryAttrName"];
     var objName = dataObject.getObjectName();
     var queryParams = options["queryParams"];
     var url = tmpDataUrl + "/" + objName;
     var objMetadata = kony.sdk.ObjectServiceUtil.getCachedObjectMetadata(serviceName, objName);
     if (objMetadata.primaryKey != undefined && objMetadata.primaryKey != null) {
       var pkCount = objMetadata.primaryKey.length;
       if (pkCount == 0) {
         kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getClientErrObj(kony.sdk.errorcodes.primarykey_unavailable, kony.sdk.errormessages.primarykey_unavailable));
         return;
       }
       //reading primarykey and framing filter clause
       var pkey = objMetadata.primaryKey[0];
       if (dataObject.getRecord()[pkey] == undefined || dataObject.getRecord()[pkey] == null) {
         kony.sdk.logsdk.error("### OnlineObjectService::_getBinaryContent Error: Please provide primary key details to get Binary content.");
         kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getClientErrObj(kony.sdk.errorcodes.primarykey_unavailable, kony.sdk.errormessages.primarykey_unavailable));
         return;
       }
       url = url + "?" + pkey + "=" + dataObject.getRecord()[pkey];
       //passing binary column name to server
       if (binaryColName != null && binaryColName != undefined) {
         url = url + "&fieldName=" + binaryColName;
       }
       if (queryParams != undefined && queryParams != null) {
         url = url + "&" + kony.sdk.util.objectToQueryParams(queryParams);
       }
     } else {
       kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getClientErrObj(kony.sdk.errorcodes.primarykey_unavailable, kony.sdk.errormessages.primarykey_unavailable));
       return;
     }
     headers = kony.sdk.addDefaultHeaders(headers);
     var isKonyApiVersionAvailable = false;
     if (typeof(headers) !== 'undefined' && headers !== null) {
       //check for x-kony-api-version case insensitive
       for (var header in headers) {
         if (header !== null && header !== 'undefined') {
           if (header.toLowerCase() === kony.sdk.constants.API_VERSION_HEADER.toLowerCase()) isKonyApiVersionAvailable = true
         }
       }
       if (!isKonyApiVersionAvailable) {
         headers[kony.sdk.constants.API_VERSION_HEADER] = currentObject.getVersion();
       }
     }

     function invokeSuccessCallback(response) {
       kony.sdk.logsdk.debug("### OnlineObjectService::_getBinaryContent::invokeSuccessCallback Response:", response);
       kony.sdk.verifyAndCallClosure(successCallback, response["data"]);
     }

     function invokeFailureCallback(error) {
       kony.sdk.logsdk.error("### OnlineObjectService::_getBinaryContent::invokeFailureCallback Error:", error);
       kony.sdk.verifyAndCallClosure(failureCallback, error);
     }
     invokeObjectOperation(url, dataObject.getObjectName(), headers, null, kony.sdk.constants.HTTP_METHOD_GET, invokeSuccessCallback, invokeFailureCallback, kony.sdk.util.checkAndFetchNetworkProviderOptions(options));
   }

   function _getBinaryData(options, tmpDataUrl, externalSource, streamingFlag, fileDownloadStartedCallback, chunkDownloadCompletedCallback, fileDownloadCompletedCallback, downloadFailureCallback) {
     var dataObject = options["dataObject"];
     var headers = options["headers"];
     var binaryColName = options["binaryAttrName"];
     var objName = dataObject.getObjectName();
     var queryParams = options["queryParams"];
     var url = tmpDataUrl + "/" + objName;
     var objMetadata = kony.sdk.ObjectServiceUtil.getCachedObjectMetadata(serviceName, objName);
     if (!externalSource) {
       if (!kony.sdk.isNullOrUndefined(objMetadata.primaryKey)) {
         var pkCount = objMetadata.primaryKey.length;
         if (pkCount == 0) {
           kony.sdk.verifyAndCallClosure(downloadFailureCallback, kony.sdk.error.getClientErrObj(kony.sdk.errorcodes.primarykey_unavailable, kony.sdk.errormessages.primarykey_unavailable));
           return;
         }
         //reading primarykey and framing filter clause
         var pkey = objMetadata.primaryKey[0];
         if (kony.sdk.isNullOrUndefined(dataObject.getRecord()[pkey])) {
           kony.sdk.logsdk.error("### OnlineObjectService::_getBinaryData Error: Please provide primary key details to get Binary content.");
           kony.sdk.verifyAndCallClosure(downloadFailureCallback, kony.sdk.error.getClientErrObj(kony.sdk.errorcodes.primarykey_unavailable, kony.sdk.errormessages.primarykey_unavailable));
           return;
         }
         url = url + "?" + pkey + "=" + dataObject.getRecord()[pkey];
         //passing binary column name to server
         if (!kony.sdk.isNullOrUndefined(binaryColName)) {
           url = url + "&fieldName=" + binaryColName;
         }
         url = url + "&type=bytes";
         if (!kony.sdk.isNullOrUndefined(queryParams)) {
           url = url + "&" + kony.sdk.util.objectToQueryParams(queryParams);
         }
       } else {
         kony.sdk.verifyAndCallClosure(downloadFailureCallback, kony.sdk.error.getClientErrObj(kony.sdk.errorcodes.primarykey_unavailable, kony.sdk.errormessages.primarykey_unavailable));
         return;
       }
     }
     headers = kony.sdk.addDefaultHeaders(headers);
     var isKonyApiVersionAvailable = false;
     if (typeof(headers) !== 'undefined' && headers !== null) {
       //check for x-kony-api-version case insensitive
       for (var headerKey in headers) {
         if (!kony.sdk.isNullOrUndefined(headerKey)) {
           if (headerKey.toLowerCase() === kony.sdk.constants.API_VERSION_HEADER.toLowerCase()) {
             isKonyApiVersionAvailable = true;
             headers[kony.sdk.constants.API_VERSION_HEADER] = headers[headerKey];
           }
         }
       }
       if (!isKonyApiVersionAvailable) {
         headers[kony.sdk.constants.API_VERSION_HEADER] = currentObject.getVersion();
       }
       headers[kony.sdk.constants.HTTP_CONTENT_HEADER] = kony.sdk.constants.CONTENT_TYPE_JSON;
     }

     function invokeSuccessCallback(response) {
       kony.sdk.logsdk.debug("### OnlineObjectService::_getBinaryData::invokeSuccessCallback Response:", response);
       var downloadConfig = response["records"][0];
       downloadConfig.httpStatusCode = response.httpStatusCode;
       if (options && options["ChunkSize"]) {
         downloadConfig.ChunkSize = options["ChunkSize"];
       }
       var fileParams = dataObject.getRecord();
       if (kony.sdk.isNullOrUndefined(fileParams["fileId"])) {
         fileParams["fileId"] = new Date().getTime().toString();
       }
       kony.sdk.binary.getBinaryData(fileParams, streamingFlag, downloadConfig, fileDownloadStartedCallback, chunkDownloadCompletedCallback, fileDownloadCompletedCallback, downloadFailureCallback);
     }

     function invokeFailureCallback(error) {
       kony.sdk.logsdk.error("### OnlineObjectService::_getBinaryData::invokeFailureCallback Error:", error);
       kony.sdk.verifyAndCallClosure(downloadFailureCallback, error);
     }
     if (externalSource) {
       invokeObjectOperation(url, dataObject.getObjectName(), headers, null, kony.sdk.constants.HTTP_METHOD_GET, invokeSuccessCallback, invokeFailureCallback, kony.sdk.util.checkAndFetchNetworkProviderOptions(options));
     } else {
       var fileParams = dataObject.getRecord();
       if (kony.sdk.isNullOrUndefined(fileParams["fileId"])) {
         fileParams["fileId"] = dataObject.getRecord()[pkey];
       }
       if (!kony.sdk.skipAnonymousCall) {
         headers[kony.sdk.constants.KONY_AUTHORIZATION_HEADER] = kony.sdk.getCurrentInstance().currentClaimToken;
       }
       var downloadConfig = {};
       downloadConfig["endpointUrl"] = url;
       downloadConfig["headers"] = headers;
       //for bypasing template call we need to add method and httpstatus code 309
       downloadConfig.method = kony.sdk.constants.HTTP_METHOD_GET;
       downloadConfig.httpStatusCode = kony.sdk.binary.constants.VALID_HTTP_REDIRECT_CODE;
       if (options && options["ChunkSize"]) {
         downloadConfig.ChunkSize = options["ChunkSize"];
       }
       kony.sdk.binary.getBinaryData(fileParams, streamingFlag, downloadConfig, fileDownloadStartedCallback, chunkDownloadCompletedCallback, fileDownloadCompletedCallback, downloadFailureCallback);
     }
   }

   function _createBinaryContent(options, tmpDataUrl, successCallback, failureCallback) {
     var dataObject = options["dataObject"];
     var headers = options["headers"];
     var binaryColName = options["binaryAttrName"];
     var objName = dataObject.getObjectName();
     var queryParams = options["queryParams"];
     var url = tmpDataUrl + "/" + objName;
     var objMetadata = kony.sdk.ObjectServiceUtil.getCachedObjectMetadata(serviceName, objName);
     var jsonPayload = {};
     var pkey;
     if (objMetadata.primaryKey != undefined && objMetadata.primaryKey != null) {
       var pkCount = objMetadata.primaryKey.length;
       if (pkCount == 0) {
         kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getClientErrObj(kony.sdk.errorcodes.primarykey_unavailable, kony.sdk.errormessages.primarykey_unavailable));
         return;
       }
       //reading primarykey and framing filter clause
       pkey = objMetadata.primaryKey[0];
       if (dataObject.getRecord()[pkey] == undefined || dataObject.getRecord()[pkey] == null) {
         kony.sdk.logsdk.error("### OnlineObjectService::_createBinaryContent Error: Please provide primary key details to create Binary content.");
         kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getClientErrObj(kony.sdk.errorcodes.primarykey_unavailable, kony.sdk.errormessages.primarykey_unavailable));
         return;
       }
       jsonPayload[pkey] = dataObject.getRecord()[pkey];
       jsonPayload["data"] = dataObject.getRecord()[binaryColName];
       jsonPayload["fieldName"] = binaryColName;
     } else {
       kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getClientErrObj(kony.sdk.errorcodes.primarykey_unavailable, kony.sdk.errormessages.primarykey_unavailable));
       return;
     }
     headers = kony.sdk.addDefaultHeaders(headers);
     var isKonyApiVersionAvailable = false;
     if (typeof(headers) !== 'undefined' && headers !== null) {
       //check for x-kony-api-version case insensitive
       for (var header in headers) {
         if (header !== null && header !== 'undefined') {
           if (header.toLowerCase() === kony.sdk.constants.API_VERSION_HEADER.toLowerCase()) isKonyApiVersionAvailable = true
         }
       }
       if (!isKonyApiVersionAvailable) {
         headers[kony.sdk.constants.API_VERSION_HEADER] = currentObject.getVersion();
       }
     }
     var formData = new kony.sdk.getFormData(jsonPayload);
     if (!kony.sdk.isNullOrUndefined(queryParams)) {
       kony.sdk.updateFormData(formData, "queryparams", queryParams);
     }

     function invokeSuccessCallback(response) {
       kony.sdk.logsdk.debug("### OnlineObjectService::_createBinaryContent::invokeSuccessCallback Response:", response);
       kony.sdk.verifyAndCallClosure(successCallback, response[pkey]);
     }

     function invokeFailureCallback(error) {
       kony.sdk.logsdk.error("### OnlineObjectService::_createBinaryContent::invokeFailureCallback Error:", error);
       kony.sdk.verifyAndCallClosure(failureCallback, error);
     }
     invokeObjectOperation(url, dataObject.getObjectName(), headers, formData, null, invokeSuccessCallback, invokeFailureCallback, kony.sdk.util.checkAndFetchNetworkProviderOptions(options));
   }

   function _updateBinaryContent(options, tmpDataUrl, successCallback, failureCallback) {
     var dataObject = options["dataObject"];
     var headers = options["headers"];
     var binaryColName = options["binaryAttrName"];
     var objName = dataObject.getObjectName();
     var queryParams = options["queryParams"];
     var url = tmpDataUrl + "/" + objName;
     var objMetadata = kony.sdk.ObjectServiceUtil.getCachedObjectMetadata(serviceName, objName);
     var jsonPayload = {};
     var pkey;
     if (objMetadata.primaryKey != undefined && objMetadata.primaryKey != null) {
       var pkCount = objMetadata.primaryKey.length;
       if (pkCount == 0) {
         kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getClientErrObj(kony.sdk.errorcodes.primarykey_unavailable, kony.sdk.errormessages.primarykey_unavailable));
         return;
       }
       //reading primarykey and framing filter clause
       pkey = objMetadata.primaryKey[0];
       if (dataObject.getRecord()[pkey] == undefined || dataObject.getRecord()[pkey] == null) {
         kony.sdk.logsdk.error("### OnlineObjectService::_updateBinaryContent Error: Please provide primary key details to create Binary content.");
         kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getClientErrObj(kony.sdk.errorcodes.primarykey_unavailable, kony.sdk.errormessages.primarykey_unavailable));
         return;
       }
       jsonPayload[pkey] = dataObject.getRecord()[pkey];
       jsonPayload["data"] = dataObject.getRecord()[binaryColName];
       jsonPayload["fieldName"] = binaryColName;
     } else {
       kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getClientErrObj(kony.sdk.errorcodes.primarykey_unavailable, kony.sdk.errormessages.primarykey_unavailable));
       return;
     }
     headers = kony.sdk.addDefaultHeaders(headers);
     headers["X-HTTP-Method-Override"] = "PUT";
     var isKonyApiVersionAvailable = false;
     if (typeof(headers) !== 'undefined' && headers !== null) {
       //check for x-kony-api-version case insensitive
       for (var header in headers) {
         if (header !== null && header !== 'undefined') {
           if (header.toLowerCase() === kony.sdk.constants.API_VERSION_HEADER.toLowerCase()) isKonyApiVersionAvailable = true
         }
       }
       if (!isKonyApiVersionAvailable) {
         headers[kony.sdk.constants.API_VERSION_HEADER] = currentObject.getVersion();
       }
     }
     var formData = new kony.sdk.getFormData(jsonPayload);
     if (queryParams != undefined && queryParams != null) {
       kony.sdk.updateFormData(formData, "queryparams", queryParams);
     }

     function invokeSuccessCallback(response) {
       kony.sdk.logsdk.debug("### OnlineObjectService::_updateBinaryContent::invokeSuccessCallback Response:", response);
       kony.sdk.verifyAndCallClosure(successCallback, response[pkey]);
     }

     function invokeFailureCallback(error) {
       kony.sdk.logsdk.error("### OnlineObjectService::_updateBinaryContent::invokeFailureCallback Error:", error);
       kony.sdk.verifyAndCallClosure(failureCallback, error);
     }
     invokeObjectOperation(url, dataObject.getObjectName(), headers, formData, null, invokeSuccessCallback, invokeFailureCallback, kony.sdk.util.checkAndFetchNetworkProviderOptions(options));
   }

   function _create(options, tmpDataUrl, successCallback, failureCallback) {
     var dataObject = options["dataObject"];
     var headers = options["headers"];
     var url = tmpDataUrl + "/" + dataObject.objectName;
     var record = dataObject.getRecord();
     var queryParams = options["queryParams"];
     if (record == null || record == undefined) {
       kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getClientErrObj(kony.sdk.errorcodes.null_or_undefined, "record " + kony.sdk.errormessages.null_or_undefined));
       return;
     }
     headers = kony.sdk.addDefaultHeaders(headers);
     var isKonyApiVersionAvailable = false;
     if (typeof(headers) !== 'undefined' && headers !== null) {
       //check for x-kony-api-version case insensitive
       for (var header in headers) {
         if (header !== null && header !== 'undefined') {
           if (header.toLowerCase() === kony.sdk.constants.API_VERSION_HEADER.toLowerCase()) isKonyApiVersionAvailable = true
         }
       }
       if (!isKonyApiVersionAvailable) {
         headers[kony.sdk.constants.API_VERSION_HEADER] = currentObject.getVersion();
       }
     }
     var formData = new kony.sdk.getFormData(record);
     if (queryParams != undefined && queryParams != null) {
       kony.sdk.updateFormData(formData, "queryparams", queryParams);
     }

     function invokeSuccessCallback(response) {
       kony.sdk.logsdk.debug("### OnlineObjectService::_create::invokeSuccessCallback Response:", response);
       kony.sdk.verifyAndCallClosure(successCallback, response);
     }

     function invokeFailureCallback(error) {
       kony.sdk.logsdk.error("### OnlineObjectService::_create::invokeFailureCallback Error:", error);
       kony.sdk.verifyAndCallClosure(failureCallback, error)
     }
     invokeObjectOperation(url, dataObject.objectName, headers, formData, null, invokeSuccessCallback, invokeFailureCallback, kony.sdk.util.checkAndFetchNetworkProviderOptions(options));
   }

   function _fetch(options, tmpDataUrl, successCallback, serviceErrorCallback) {
     var dataObject = options["dataObject"];
     var odataqueryStr = dataObject.getOdataUrl();
     var headers = options["headers"];
     var queryParams = options["queryParams"];
     var url = tmpDataUrl + "/" + dataObject.objectName;
     if (odataqueryStr != undefined && odataqueryStr != null) {
       url = url + "?" + encodeURI(odataqueryStr);
       if (queryParams != undefined && queryParams != null) {
         url = url + "&" + kony.sdk.util.objectToQueryParams(queryParams);
       }
     } else if (queryParams != undefined && queryParams != null) {
       url = url + "?" + kony.sdk.util.objectToQueryParams(queryParams);
     }
     headers = kony.sdk.addDefaultHeaders(headers);
     var isKonyApiVersionAvailable = false;
     if (typeof(headers) !== 'undefined' && headers !== null) {
       //check for x-kony-api-version case insensitive
       for (var header in headers) {
         if (header !== null && header !== 'undefined') {
           if (header.toLowerCase() === kony.sdk.constants.API_VERSION_HEADER.toLowerCase()) isKonyApiVersionAvailable = true
         }
       }
       if (!isKonyApiVersionAvailable) {
         headers[kony.sdk.constants.API_VERSION_HEADER] = currentObject.getVersion();
       }
     }
     // If useCache is enabled and cacheID is present then network call will be skipped and cached response will be returned.
     if (options && options["useCache"] && options["cacheID"]) {
       var cacheResponse = new kony.sdk.ClientCache().get(options["cacheID"]);
       if (cacheResponse) {
         kony.sdk.logsdk.debug("### OnlineObjectService::_fetch:: key found in cache, invokeSuccessCallback Response:", cacheResponse);
         kony.sdk.verifyAndCallClosure(successCallback, cacheResponse);
         return;
       }
     }

     function invokeSuccessCallback(response) {
       kony.sdk.logsdk.debug("### OnlineObjectService::_fetch::invokeSuccessCallback Response:", response);
       // If useCache is enabled then the response is cached and returned.
       if (options && options["useCache"]) {
         cacheResponseForKey(options, url, {
           "objectName": dataObject.objectName
         }, response);
       }
       kony.sdk.verifyAndCallClosure(successCallback, response);
     }

     function invokeFailureCallback(error) {
       kony.sdk.logsdk.error("### OnlineObjectService::_fetch::invokeFailureCallback Error:", error);
       kony.sdk.verifyAndCallClosure(serviceErrorCallback, error);
     }
     invokeObjectOperation(url, dataObject.objectName, headers, null, kony.sdk.constants.HTTP_METHOD_GET, invokeSuccessCallback, invokeFailureCallback, kony.sdk.util.checkAndFetchNetworkProviderOptions(options));
   }

   function _update(options, tmpDataUrl, updateServiceCallback, serviceErrorCallback) {
     var dataObject = options["dataObject"];
     var headers = options["headers"];
     var url = tmpDataUrl + "/" + dataObject.objectName;
     var queryParams = options["queryParams"];
     headers = kony.sdk.addDefaultHeaders(headers);
     var isKonyApiVersionAvailable = false;
     if (typeof(headers) !== 'undefined' && headers !== null) {
       //check for x-kony-api-version case insensitive
       for (var header in headers) {
         if (header !== null && header !== 'undefined') {
           if (header.toLowerCase() === kony.sdk.constants.API_VERSION_HEADER.toLowerCase()) isKonyApiVersionAvailable = true
         }
       }
       if (!isKonyApiVersionAvailable) {
         headers[kony.sdk.constants.API_VERSION_HEADER] = currentObject.getVersion();
       }
     }
     headers["X-HTTP-Method-Override"] = "PUT";
     var formData = new kony.sdk.getFormData(dataObject.getRecord());
     if (queryParams != undefined && queryParams != null) {
       kony.sdk.updateFormData(formData, "queryparams", queryParams);
     }

     function invokeSuccessCallback(response) {
       kony.sdk.logsdk.debug("### OnlineObjectService::_update::invokeSuccessCallback Response:", response);
       kony.sdk.verifyAndCallClosure(updateServiceCallback, response);
     }

     function invokeFailureCallback(error) {
       kony.sdk.logsdk.error("### OnlineObjectService::_update::invokeFailureCallback Error:", error);
       kony.sdk.verifyAndCallClosure(serviceErrorCallback, error);
     }
     invokeObjectOperation(url, dataObject.objectName, headers, formData, null, invokeSuccessCallback, invokeFailureCallback, kony.sdk.util.checkAndFetchNetworkProviderOptions(options));
   }

   function _partialUpdate(options, tmpDataUrl, partialUpdateServiceCallback, serviceErrorCallback) {
     var dataObject = options["dataObject"];
     var headers = options["headers"];
     var url = tmpDataUrl + "/" + dataObject.objectName;
     var queryParams = options["queryParams"];
     headers = kony.sdk.addDefaultHeaders(headers);
     headers["X-HTTP-Method-Override"] = "PATCH";
     var isKonyApiVersionAvailable = false;
     if (typeof(headers) !== 'undefined' && headers !== null) {
       //check for x-kony-api-version case insensitive
       for (var header in headers) {
         if (header !== null && header !== 'undefined') {
           if (header.toLowerCase() === kony.sdk.constants.API_VERSION_HEADER.toLowerCase()) isKonyApiVersionAvailable = true
         }
       }
       if (!isKonyApiVersionAvailable) {
         headers[kony.sdk.constants.API_VERSION_HEADER] = currentObject.getVersion();
       }
     }
     var formData = new kony.sdk.getFormData(dataObject.getRecord());
     if (queryParams != undefined && queryParams != null) {
       kony.sdk.updateFormData(formData, "queryparams", queryParams);
     }

     function invokeSuccessCallback(response) {
       kony.sdk.logsdk.debug("### OnlineObjectService::_partialUpdate::invokeSuccessCallback Success Response:", response);
       kony.sdk.verifyAndCallClosure(partialUpdateServiceCallback, response);
     }

     function invokeFailureCallback(error) {
       kony.sdk.logsdk.error("### OnlineObjectService::_partialUpdate::invokeFailureCallback Error:", error);
       kony.sdk.verifyAndCallClosure(serviceErrorCallback, error);
     }
     invokeObjectOperation(url, dataObject.objectName, headers, formData, null, invokeSuccessCallback, invokeFailureCallback, kony.sdk.util.checkAndFetchNetworkProviderOptions(options));
   }

   function _deleteRecord(options, tmpDataUrl, deleteSuccessCallback, serviceErrorCallback) {
     var dataObject = options["dataObject"];
     var headers = options["headers"];
     var objMetadata = kony.sdk.ObjectServiceUtil.getCachedObjectMetadata(serviceName, dataObject.objectName);
     var url = tmpDataUrl + "/" + dataObject.objectName;
     var queryParams = options["queryParams"];
     var odataUrl = "";
     if (objMetadata.primaryKey != undefined && objMetadata.primaryKey != null) {
       var pkCount = objMetadata.primaryKey.length;
       for (var i = 0; i < pkCount; i++) {
         //reading primarykey and framing filter clause
         var pkey = objMetadata.primaryKey[i];
         if (dataObject.getRecord()[pkey] == undefined || dataObject.getRecord()[pkey] == null) {
           kony.sdk.logsdk.error("### OnlineObjectService::_delete Error: Please provide all primary keys to process the request");
           kony.sdk.verifyAndCallClosure(serviceErrorCallback, kony.sdk.error.getClientErrObj(kony.sdk.errorcodes.primarykey_unavailable, kony.sdk.errormessages.primarykey_unavailable));
           return;
         }
         if (i == 0) {
           odataUrl = "?$filter=" + pkey + " eq '" + dataObject.getRecord()[pkey] + "'";
         } else {
           //appending the condition incase of composite primary key
           odataUrl = odataUrl + " and " + pkey + " eq '" + dataObject.getRecord()[pkey] + "'";
         }
       }
     }
     url = url + encodeURI(odataUrl);
     if (queryParams != undefined && queryParams != null) {
       if (odataUrl && odataUrl.length != 0) {
         url = url + "&" + kony.sdk.util.objectToQueryParams(queryParams);
       } else {
         url = url + "?" + kony.sdk.util.objectToQueryParams(queryParams);
       }
     }
     headers = kony.sdk.addDefaultHeaders(headers);
     var isKonyApiVersionAvailable = false;
     if (typeof(headers) !== 'undefined' && headers !== null) {
       //check for x-kony-api-version case insensitive
       for (var header in headers) {
         if (header !== null && header !== 'undefined') {
           if (header.toLowerCase() === kony.sdk.constants.API_VERSION_HEADER.toLowerCase()) isKonyApiVersionAvailable = true
         }
       }
       if (!isKonyApiVersionAvailable) {
         headers[kony.sdk.constants.API_VERSION_HEADER] = currentObject.getVersion();
       }
     }
     headers["X-HTTP-Method-Override"] = "DELETE";

     function invokeSuccessCallback(response) {
       kony.sdk.logsdk.debug("### OnlineObjectService::_delete::invokeSuccessCallback Response:", response);
       kony.sdk.verifyAndCallClosure(deleteSuccessCallback, response);
     }

     function invokeFailureCallback(error) {
       kony.sdk.logsdk.error("### OnlineObjectService::_delete::invokeFailureCallback Error:", error);
       kony.sdk.verifyAndCallClosure(serviceErrorCallback, error);
     }
     invokeObjectOperation(url, dataObject.objectName, headers, null, kony.sdk.constants.HTTP_METHOD_GET, invokeSuccessCallback, invokeFailureCallback, kony.sdk.util.checkAndFetchNetworkProviderOptions(options));
   }

   function _customverb(verbName, options, tmpDataUrl, customVerbServiceCallback, serviceErrorCallback) {
     var dataObject = options["dataObject"];
     var headers = options["headers"];
     var url = tmpDataUrl + "/" + dataObject.objectName + "/" + verbName;
     var queryParams = options["queryParams"];
     headers = kony.sdk.addDefaultHeaders(headers);
     var isKonyApiVersionAvailable = false;
     if (typeof(headers) !== 'undefined' && headers !== null) {
       //check for x-kony-api-version case insensitive
       for (var header in headers) {
         if (header !== null && header !== 'undefined') {
           if (header.toLowerCase() === kony.sdk.constants.API_VERSION_HEADER.toLowerCase()) isKonyApiVersionAvailable = true
         }
       }
       if (!isKonyApiVersionAvailable) {
         headers[kony.sdk.constants.API_VERSION_HEADER] = currentObject.getVersion();
       }
     }
     var formData = new kony.sdk.getFormData(dataObject.getRecord());
     if (queryParams != undefined && queryParams != null) {
       kony.sdk.updateFormData(formData, "queryparams", queryParams);
     }

     function invokeSuccessCallback(response) {
       kony.sdk.logsdk.debug("### OnlineObjectService::_customverb::invokeSuccessCallback Success Response:", response);
       kony.sdk.verifyAndCallClosure(customVerbServiceCallback, response);
     }

     function invokeFailureCallback(error) {
       kony.sdk.logsdk.error("### OnlineObjectService::_customverb::invokeFailureCallback Error:", error);
       kony.sdk.verifyAndCallClosure(serviceErrorCallback, error);
     }
     invokeObjectOperation(url, dataObject.objectName, headers, formData, null, invokeSuccessCallback, invokeFailureCallback, kony.sdk.util.checkAndFetchNetworkProviderOptions(options));
   }
   this.getFileStorage = function() {
     // TODO : Fix this as there are issues with getMetadataOfAllObjects call - that was hanging	
     return kony.sdk.FileStorageClasses.import(this.getFileStorageObjectServiceUrl());
   };
 };

 function _getMetadataUrl(konyRef, serviceName) {
   var metadataUrl = null;
   if (konyRef.objectsvc[serviceName]) {
     metadataUrl = encodeURI(stripTrailingCharacter(konyRef.objectsvc[serviceName]["metadata_url"], "/"));
   } else if (konyRef.offlineObjectsvc[serviceName]) {
     metadataUrl = encodeURI(stripTrailingCharacter(konyRef.offlineObjectsvc[serviceName]["metadata_url"], "/"));
   }
   return metadataUrl;
 }

 function _getVersion(konyRef, serviceName) {
   var version = null;
   if (konyRef.objectsvc[serviceName]) {
     version = konyRef.objectsvc[serviceName]["version"];
   } else if (konyRef.offlineObjectsvc[serviceName]) {
     version = konyRef.offlineObjectsvc[serviceName]["version"];
   }
   return version;
 }
 /*This method is used to fetch metadata for Object/Objectservice.
  * It is fetched from cache first, if it not available in cache then fetches method data from metadata URL.
  */
 function _getMetadataForObjectsOrServiceOnlineUtil(konyRef, serviceName, objectName, options, successCallback, failureCallback) {
   var tmpMetadataUrl = _getMetadataUrl(konyRef, serviceName);;
   if (!(kony.sdk.isNullOrUndefined(options)) && !(options["queryParams"] == null || options["queryParams"] == undefined)) {
     if (!(options["queryParams"] instanceof Object)) {
       kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getClientErrObj(kony.sdk.errorcodes.invalid_queryparams_instance, kony.sdk.errormessages.invalid_queryparams_instance));
     }
   }

   function getMetadataOfObjectOperationHandler() {
     _getMetadataForObjectOrService(konyRef, serviceName, objectName, options, tmpMetadataUrl, successCallback, failureCallback);
   }
   if (kony.sdk.skipAnonymousCall) {
     getMetadataOfObjectOperationHandler();
   } else {
     kony.sdk.claimsRefresh(getMetadataOfObjectOperationHandler, failureCallback);
   }
 }

 function _getMetadataForObjectOrService(konyRef, serviceName, objectName, options, tmpMetadataUrl, successCallback, failureCallback) {
   //if the getFromServer flag is true then get metadata from server even though its available in cache
   var getFromServer = false;
   var headers = null;
   var queryParams = null;
   if (options != null && options != undefined) {
     getFromServer = options["getFromServer"];
     headers = options["headers"];
     queryParams = options["queryParams"];
   }
   var tmpObjOrSvcMetadata = null;
   if (objectName) {
     tmpObjOrSvcMetadata = kony.sdk.ObjectServiceUtil.getCachedObjectMetadata(serviceName, objectName);
   } else {
     tmpObjOrSvcMetadata = kony.sdk.ObjectServiceUtil.getCachedMetadata(serviceName);
   }
   if (getFromServer != true && tmpObjOrSvcMetadata != null && tmpObjOrSvcMetadata != undefined) {
     kony.sdk.logsdk.debug("### OnlineObjectService::_getMetadataOfObject from KonyStore:", tmpObjOrSvcMetadata);
     kony.sdk.verifyAndCallClosure(successCallback, tmpObjOrSvcMetadata);
   } else {
     headers = kony.sdk.addDefaultHeaders(headers);
     var isKonyApiVersionAvailable = false;
     if (typeof(headers) !== 'undefined' && headers !== null) {
       //check for x-kony-api-version case insensitive
       for (var header in headers) {
         if (header !== null && header !== 'undefined') {
           if (header.toLowerCase() === kony.sdk.constants.API_VERSION_HEADER.toLowerCase()) isKonyApiVersionAvailable = true
         }
       }
       if (!isKonyApiVersionAvailable) {
         headers[kony.sdk.constants.API_VERSION_HEADER] = _getVersion(konyRef, serviceName);
       }
     }
     var url = tmpMetadataUrl;
     var svcid = "metadata";
     if (objectName) {
       url = url + "/" + objectName;
       svcid = svcid + "_" + objectName;
     }
     if (queryParams != undefined && queryParams != null) {
       url = url + "?" + kony.sdk.util.objectToQueryParams(queryParams);
     }

     function invokeSuccessCallback(result) {
       kony.sdk.logsdk.debug("### OnlineObjectService::_getMetadataForObjectOrService::invokeSuccessCallback Response:", result);
       if (objectName) {
         var table = result["Metadata"]["table"];
         kony.sdk.ObjectServiceUtil.cacheObjectMetadata(serviceName, table);
         var tmpObjMetadata = kony.sdk.ObjectServiceUtil.getCachedObjectMetadata(serviceName, objectName);
         kony.sdk.verifyAndCallClosure(successCallback, tmpObjMetadata);
       } else {
         var tableArray = result["Metadata"]["tables"];
         kony.sdk.ObjectServiceUtil.cacheMetadata(serviceName, tableArray);
         var tmpMetadata = kony.sdk.ObjectServiceUtil.getCachedMetadata(serviceName);
         kony.sdk.verifyAndCallClosure(successCallback, tmpMetadata);
       }
     }

     function invokeFailureCallback(error) {
       kony.sdk.logsdk.error("### OnlineObjectService::_getMetadataForObjectOrService::invokeFailureCallback Error:", error);
       kony.sdk.verifyAndCallClosure(failureCallback, error);
     }
     invokeObjectOperation(url, svcid, headers, null, kony.sdk.constants.HTTP_METHOD_GET, invokeSuccessCallback, invokeFailureCallback, kony.sdk.util.checkAndFetchNetworkProviderOptions(options));
   }
 }

 function objectServiceRetry(url, svcid, headers, formData, httpMethod, successCallback, failureCallback, networkProviderOptions) {
   function invokeObjectOperationRetryHandler() {
     _invokeObjectOperation(url, svcid, headers, false, formData, httpMethod, successCallback, failureCallback, networkProviderOptions);
   }
   if (kony.sdk.skipAnonymousCall) {
     invokeObjectOperationRetryHandler();
   } else {
     kony.sdk.claimsAndProviderTokenRefresh(invokeObjectOperationRetryHandler, failureCallback);
   }
 }

 function retryServiceCall(errorResponse) {
   if (errorResponse[kony.sdk.constants.HTTP_STATUS_CODE] && errorResponse[kony.sdk.constants.HTTP_STATUS_CODE] === 401) {
     kony.sdk.logsdk.debug("### ObjectService::retryServiceCall received 401 from fabric, trying to refresh backend token");
     return true;
   }
 }

 function invokeObjectOperation(url, svcid, headers, formData, httpMethod, successCallback, failureCallback, networkProviderOptions) {
   _invokeObjectOperation(url, svcid, headers, true, formData, httpMethod, successCallback, failureCallback, networkProviderOptions);
 }
 //Method is used to send http request for ObjectService operations
 function _invokeObjectOperation(url, svcid, headers, isRetryNeeded, formData, httpMethod, successCallback, failureCallback, networkProviderOptions) {
   kony.sdk.logsdk.perf("Executing invokeObjectOperation");
   var networkProvider = new konyNetworkProvider();
   var reportingData = kony.sdk.getEncodedReportingParamsForSvcid(svcid);
   var defaultHeaders = kony.sdk.getDefaultHeaders();
   if (!httpMethod) {
     //default http method is post
     httpMethod = "POST";
   }
   if (!kony.sdk.skipAnonymousCall) {
     // Check to find if the service is public or not, in case of public service no token is required.
     defaultHeaders[kony.sdk.constants.KONY_AUTHORIZATION_HEADER] = konyRef.currentClaimToken;
   }
   defaultHeaders[kony.sdk.constants.HTTP_REQUEST_HEADER_ACCEPT] = kony.sdk.constants.CONTENT_TYPE_JSON;
   defaultHeaders[kony.sdk.constants.HTTP_CONTENT_HEADER] = kony.sdk.constants.CONTENT_TYPE_JSON;
   var deviceId = kony.sdk.getDeviceId();
   if (!kony.sdk.isNullOrUndefined(deviceId)) {
     defaultHeaders[kony.sdk.constants.DEVICEID_HEADER] = deviceId;
   }
   if (reportingData != null && reportingData != undefined) {
     try {
       defaultHeaders[kony.sdk.constants.REPORTING_HEADER] = reportingData;
     } catch (error) {
       kony.sdk.logsdk.error("### invokeObjectOperation::error while parsing metrics payload" + error);
     }
   }
   // if the user has defined his own headers, use them
   if (headers) {
     var tempHeader = "";
     for (var header in headers) {
       if (kony.sdk.constants.HTTP_REQUEST_HEADER_ACCEPT.toLowerCase() === header.toLowerCase()) {
         //Accept can be multiple
         //Reason being client can be programmed to accept more than one type of content from server.
         tempHeader = kony.sdk.constants.HTTP_REQUEST_HEADER_ACCEPT;
         if (defaultHeaders[tempHeader].toLowerCase() !== headers[header].toLowerCase()) {
           defaultHeaders[header] = defaultHeaders[tempHeader] + "," + headers[header];
         }
       } else if (kony.sdk.constants.KONY_AUTHORIZATION_HEADER.toLowerCase() === header.toLowerCase()) {
         tempHeader = kony.sdk.constants.KONY_AUTHORIZATION_HEADER;
         if (defaultHeaders[tempHeader] !== headers[header]) {
           defaultHeaders[tempHeader] = headers[header];
         }
       } else if ("content-type" === header.toLowerCase()) {
         tempHeader = kony.sdk.constants.HTTP_CONTENT_HEADER;
         //Content-type can and should be a single value.
         //Reason being client can only send a single kind of content at a single instance
         if (defaultHeaders[tempHeader].toLowerCase() !== headers[header].toLowerCase()) {
           defaultHeaders[tempHeader] = headers[header];
         }
       } else {
         if (defaultHeaders[header] !== headers[header]) {
           defaultHeaders[header] = headers[header];
         }
       }
     }
   }

   function networksuccess(res) {
     kony.sdk.logsdk.perf("Executing Finished invokeObjectOperation");
     kony.sdk.verifyAndCallClosure(successCallback, res);
   }

   function networkerror(xhr, status, err) {
     kony.sdk.logsdk.trace("Entering networkerror");
     if (xhr && !(status && err)) {
       err = xhr;
     }
     if (isRetryNeeded === true && retryServiceCall(err) === true) {
       objectServiceRetry(url, svcid, headers, formData, httpMethod, successCallback, failureCallback, networkProviderOptions);
       return;
     }
     if (err[kony.sdk.constants.MF_CODE]) {
       var konyRef = kony.sdk.getCurrentInstance();
       //clear the cache if the error code related to session/token expiry
       if (kony.sdk.isSessionOrTokenExpired(err[kony.sdk.constants.MF_CODE])) {
         kony.sdk.logsdk.warn("###ObjectService::invokeObjectOperationFailure  Session/Token expired. Authenticate and Try again");
         //kony.sdk.resetCacheKeys(konyRef);
       }
     }
     kony.sdk.logsdk.perf("Executing Finished invokeObjectOperation");
     kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getObjectServiceErrObj(err));
   }
   if (httpMethod === "GET") {
     networkProvider.get(url, null, defaultHeaders, networksuccess, networkerror, "formdata", networkProviderOptions);
   } else {
     networkProvider.post(url, formData, defaultHeaders, networksuccess, networkerror, "formdata", networkProviderOptions);
   }
 }
 kony.sdk.util = kony.sdk.util || {};
 kony.sdk.ObjectServiceUtil = kony.sdk.ObjectServiceUtil || {};
 kony.sdk.dto = kony.sdk.dto || {};
 kony.sdk.constants.DateTimeType = {
   TODAY: "TODAY",
   YESTERDAY: "YESTERDAY",
   TOMORROW: "TOMORROW",
   CURRENTWEEK: "CURRENTWEEK",
   LASTWEEK: "LASTWEEK",
   NEXTWEEK: "NEXTWEEK",
   CURRENTMONTH: "CURRENTMONTH",
   LASTMONTH: "LASTMONTH",
   NEXTMONTH: "NEXTMONTH"
 };
 kony.sdk.constants.Aggregation = {
   NONE: "",
   COUNT: "COUNT",
   SUM: "SUM",
   MAX: "MAX",
   MIN: "MIN",
   AVG: "AVG"
 };
 kony.sdk.constants.OrderType = {
   ASCENDING: "ASC",
   DESCENDING: "DESC"
 };
 kony.sdk.constants.MatchType = {
   EQUALS: {
     value: "=",
     name: "EQUALS"
   },
   GREATER: {
     value: ">",
     name: "GREATER"
   },
   GREATEREQUAL: {
     value: ">=",
     name: "GREATEREQUAL"
   },
   LESS: {
     value: "<",
     name: "LESS"
   },
   LESSEQUAL: {
     value: "<=",
     name: "LESSEQUAL"
   },
   STARTSWITH: {
     value: "LIKE",
     name: "STARTSWITH"
   },
   CONTAINS: {
     value: "LIKE",
     name: "CONTAINS"
   },
   LIKE: {
     value: "LIKE",
     name: "LIKE"
   },
   ENDSWITH: {
     value: "LIKE",
     name: "ENDSWITH"
   },
   NOTEQUAL: {
     value: "<>",
     name: "NOTEQUAL"
   },
   ISNULL: {
     value: "IS NULL",
     name: "ISNULL"
   },
   ISNOTNULL: {
     value: "IS NOT NULL",
     name: "ISNOTNULL"
   }
 };
 kony.sdk.constants.JoinType = {
   INNER: "INNER",
   LEFT: "LEFT",
   RIGHT: "RIGHT"
 };
 kony.sdk.constants.Operator = {
   AND: "AND",
   OR: "OR"
 };
 kony.sdk.constants.ObjectServiceConstants = {
   DATAOBJECT: "dataObject",
   QUERYPARAMS: "queryParams"
 };
 /**
  * This is a utility function used to check whether the two strings provided
  * would match with each other.
  * @param string1
  * @param string2
  * @return boolean
  */
 kony.sdk.util.matchIgnoreCase = function(string1, string2) {
   if (string1 === null || string2 === null || string1 === undefined || string2 === undefined) {
     return false;
   }
   return (string1.toUpperCase() === string2.toUpperCase());
 };
 kony.sdk.util.isNull = function(val) {
   if (val === null || val === undefined) return true;
   val = val + "";
   return (kony.sdk.util.matchIgnoreCase(val, "null"));
 };
 kony.sdk.util.isValidNumberType = function(val) {
   if (kony.sdk.util.matchIgnoreCase(typeof val, "number")) return true;
   else if (kony.sdk.util.matchIgnoreCase(typeof val, "string") && null != kony.sdk.util.toNumber(val)) return true;
   else return false;
 };
 kony.sdk.util.toNumber = function(arg) {
   if (arguments.length != 1) {
     throw new Error("Invalid argument to kony.sdk.util.toNumber");
   }
   if (typeof(arg) === "number") {
     return arg;
   } else if (typeof(arg) === "string") {
     var str = arg.replace(/^\s*/, '').replace(/\s*$/, '');
     if (str === '') {
       return null;
     } else {
       var num = str - 0;
       return (isNaN(num) ? null : num);
     }
   } else {
     return null;
   }
 };
 kony.sdk.util.validateCriteriaObject = function(criteria) {
   if (criteria !== null && criteria !== undefined) {
     return (criteria instanceof kony.sdk.dto.Criteria || criteria instanceof kony.sdk.dto.Match || criteria instanceof kony.sdk.dto.Between || criteria instanceof kony.sdk.dto.LogicGroup || criteria instanceof kony.sdk.dto.And || criteria instanceof kony.sdk.dto.Or || criteria instanceof kony.sdk.dto.Not || criteria instanceof kony.sdk.dto.Expression || criteria instanceof kony.sdk.dto.InCriteria || criteria instanceof kony.sdk.dto.Exists || criteria instanceof kony.sdk.dto.Join);
   } else {
     return false;
   }
 };
 kony.sdk.util.checkAndFetchNetworkProviderOptions = function(options, isPassThroughExpected) {
   var providerOptions = {};
   if (!kony.sdk.isNullOrUndefined(options)) {
     if (!kony.sdk.isNullOrUndefined(options["httpRequestOptions"]) && options["httpRequestOptions"] instanceof Object) {
       providerOptions["httpRequestOptions"] = options["httpRequestOptions"];
     }
     if (!kony.sdk.isNullOrUndefined(options["xmlHttpRequestOptions"]) && options["xmlHttpRequestOptions"] instanceof Object) {
       providerOptions["xmlHttpRequestOptions"] = options["xmlHttpRequestOptions"];
     }
     // [APPPLT-6138][MFSDK-4842] Handle passthrough option, if it is set by the user.
     // As Identity Service calls don't expect passthrough enabled, it will be explicitely set as False if it is called by any Identity service API
     // else it tries to add passthrough for other calls if set by the user.
     if (isPassThroughExpected !== false) {
       if (!kony.sdk.isNullOrUndefined(options[kony.sdk.constants.PASSTHROUGH])) {
         providerOptions[kony.sdk.constants.PASSTHROUGH] = options[kony.sdk.constants.PASSTHROUGH];
       }
     }
   }
   return providerOptions;
 };
 kony.sdk.ObjectServiceUtil.cacheMetadata = function(serviceName, objects) {
   if (objects !== undefined && objects !== null) {
     kony.sdk.dataStore.removeItem(serviceName);
     for (var i = 0; i < objects.length; i++) {
       var object = objects[i];
       //clearing the existing metadata of service and updating it with the latest metadata
       kony.sdk.ObjectServiceUtil.cacheObjectMetadata(serviceName, object);
     }
   }
 };
 kony.sdk.ObjectServiceUtil.cacheObjectMetadata = function(serviceName, object) {
   if (object !== undefined && object !== null) {
     //getting metadata of servicename
     var metadataOfAllObjs = kony.sdk.dataStore.getItem(serviceName);
     var jsonObject = JSON.parse('{}');
     //if metadata available get it
     if (metadataOfAllObjs !== null && metadataOfAllObjs !== undefined && metadataOfAllObjs !== "{}") {
       jsonObject = JSON.parse(metadataOfAllObjs);
     }
     //adding metadata of object to the existing metadata
     jsonObject[object.name] = object;
     var jsonStr = JSON.stringify(jsonObject);
     kony.sdk.dataStore.setItem(serviceName, jsonStr);
   }
 };
 kony.sdk.ObjectServiceUtil.getCachedMetadata = function(serviceName) {
   kony.sdk.logsdk.trace("Entering into kony.sdk.ObjectServiceUtil.getCachedMetadata");
   var appMetadata = kony.sdk.util.getPackagedMetadata();
   if (appMetadata != null && appMetadata != undefined) {
     if (serviceName != undefined && serviceName != null) return appMetadata[serviceName];
   } else {
     //reading metadata from the store
     var jsonObject = null;
     var metadataOfAllObjs = kony.sdk.dataStore.getItem(serviceName);
     if (metadataOfAllObjs !== null && metadataOfAllObjs !== undefined && metadataOfAllObjs !== "{}") {
       jsonObject = JSON.parse(metadataOfAllObjs);
     }
     return jsonObject;
   }
   return null;
 };
 kony.sdk.ObjectServiceUtil.getCachedObjectMetadata = function(serviceName, objectName) {
   kony.sdk.logsdk.trace("Entering into kony.sdk.ObjectServiceUtil.getCachedObjectMetadata");
   var objectMetadata;
   if (objectName !== undefined && objectName !== null) {
     var metadataOfAllObjs = kony.sdk.ObjectServiceUtil.getCachedMetadata(serviceName);
     var jsonObject = null;
     if (metadataOfAllObjs !== null && metadataOfAllObjs !== undefined && metadataOfAllObjs !== "{}") {
       jsonObject = metadataOfAllObjs;
       //getting the object's metadata from the stored metadata
       objectMetadata = jsonObject[objectName];
     }
   }
   return objectMetadata;
 };
 /**
  * An object used to perform CRUD operations on objects
  * @param objectName
  * @param record
  * @constructor
  */
 kony.sdk.dto.DataObject = function(objectName, record) {
   kony.sdk.logsdk.trace("Entering into kony.sdk.dto.DataObject");
   this.objectName = objectName;
   if (record != null && record != undefined) {
     this.record = record;
   } else {
     this.record = {};
   }
   this.odataUrl = null;
   this.selectQueryObject = null;
   this.offlineObjectsOptions = {};
   this.setOfflineObjectsOptions = function(offlineObjectsOptions) {
     this.offlineObjectsOptions = offlineObjectsOptions;
   };
   this.getOfflineObjectsOptions = function() {
     return this.offlineObjectsOptions;
   };
   /**
    * This function is used to add fields and their values to the dataobject
    * @param fieldName
    * @param value
    */
   this.addField = function(fieldName, value) {
     this.record[fieldName] = value;
   };
   /**
    * This function is used to set a map of records to the dataobject
    * @param fieldValuesMap
    */
   this.setRecord = function(fieldValuesMap) {
     this.record = fieldValuesMap;
   };
   /**
    * This function is used to get the map of records present in the DataObject
    * @returns {JSON} record
    */
   this.getRecord = function() {
     return this.record;
   };
   /**
    * This function is used to add a child Dataobject into the data object
    * @param  childDataObject {@link kony.sdk.dto.DataObject}
    */
   this.addChildDataObject = function(childDataObject) {
     if (this.record[childDataObject.objectName] == null || this.record[childDataObject.objectName] == undefined) {
       this.record[childDataObject.objectName] = [];
     }
     this.record[childDataObject.objectName].push(childDataObject.getRecord());
   };
   /**
    * This function is used to set the odata url to query
    * @param odataUrl
    */
   this.setOdataUrl = function(odataUrl) {
     this.odataUrl = odataUrl;
   };
   /**
    * This function is used to get the odata url to query
    * @returns {null}
    */
   this.getOdataUrl = function() {
     return this.odataUrl;
   };
   /**
    * This function is used to set a SelectQueryObject {@link kony.sdk.dto.SelectQuery}
    * @param selectQueryObject {@link kony.sdk.dto.SelectQuery}
    */
   this.setSelectQueryObject = function(selectQueryObject) {
     this.selectQueryObject = selectQueryObject;
   };
   /**
    * This function is used to get a SelectQueryObject {@link kony.sdk.dto.SelectQuery}
    * @returns selectQueryObject {@link kony.sdk.dto.SelectQuery}
    */
   this.getSelectQueryObject = function() {
     return this.selectQueryObject;
   };
   /**
    * This function is used to get the object name
    * @returns objectName {string}
    */
   this.getObjectName = function() {
     return this.objectName;
   };
 };
 /**
  * This object is used to define a record object used in Offline CRUD
  * @constructor
  */
 kony.sdk.dto.RecordObject = function() {
   kony.sdk.logsdk.trace("Entering into kony.sdk.dto.RecordObject");
   this.tableName = "";
   this.columnValues = {};
   this.childRecords = [];
 };
 kony.sdk.util.getSyncDbName = function() {
   return kony.sync.getDBName();
 };
 kony.sdk.util.getPrimarykeysFromMetadata = function(objMetadata) {
   var tmpSrcAttributes = null;
   if (objMetadata.primaryKey != null && objMetadata.primaryKey != undefined && objMetadata.primaryKey.length > 0) {
     tmpSrcAttributes = {};
     var pkLen = objMetadata.primaryKey.length;
     for (var indx = 0; indx < pkLen; indx++) {
       var pKey = objMetadata.primaryKey[indx];
       //adding primarykey column names in srcattributes which will be useful while deleting children
       tmpSrcAttributes[pKey] = pKey;
     }
   }
   return tmpSrcAttributes;
 };
 /**
  * This is a replaceAll utility function
  * @param string
  * @param toReplace
  * @param replaceWith
  * @return String temp
  */
 kony.sdk.util.replaceAll = function(string, toReplace, replaceWith) {
   kony.sdk.logsdk.trace("Entering into kony.sdk.util.replaceAll");
   var temp = string;
   var index = temp.indexOf(toReplace);
   while (index != -1) {
     temp = temp.replace(toReplace, replaceWith);
     index = temp.indexOf(toReplace);
   }
   return temp;
 };
 kony.sdk.util.validateDateTypeInput = function(dateType) {
   return (kony.sdk.util.matchIgnoreCase(dateType, kony.sdk.constants.DateTimeType.TODAY) || kony.sdk.util.matchIgnoreCase(dateType, kony.sdk.constants.DateTimeType.TOMORROW) || kony.sdk.util.matchIgnoreCase(dateType, kony.sdk.constants.DateTimeType.YESTERDAY) || kony.sdk.util.matchIgnoreCase(dateType, kony.sdk.constants.DateTimeType.CURRENTWEEK) || kony.sdk.util.matchIgnoreCase(dateType, kony.sdk.constants.DateTimeType.NEXTWEEK) || kony.sdk.util.matchIgnoreCase(dateType, kony.sdk.constants.DateTimeType.LASTWEEK) || kony.sdk.util.matchIgnoreCase(dateType, kony.sdk.constants.DateTimeType.CURRENTMONTH) || kony.sdk.util.matchIgnoreCase(dateType, kony.sdk.constants.DateTimeType.NEXTMONTH) || kony.sdk.util.matchIgnoreCase(dateType, kony.sdk.constants.DateTimeType.LASTMONTH));
 };
 kony.sdk.util.getDateRange = function(dateType) {
   kony.sdk.logsdk.trace("Entering into kony.sdk.util.getDateRange");
   var result = [];
   var currentDate = new Date();
   var formattedDate = new Date(currentDate.getFullYear(), currentDate.getMonth(), currentDate.getDate(), currentDate.getHours(), currentDate.getMinutes(), currentDate.getSeconds(), currentDate.getMilliseconds());
   var start;
   var end;
   if (kony.sdk.util.matchIgnoreCase(dateType, kony.sdk.constants.DateTimeType.TODAY)) {
     end = new Date(formattedDate.getFullYear(), formattedDate.getMonth(), formattedDate.getDate(), 23, 59, 59);
     start = new Date(formattedDate.getFullYear(), formattedDate.getMonth(), formattedDate.getDate(), 0, 0, 0);
   } else if (kony.sdk.util.matchIgnoreCase(dateType, kony.sdk.constants.DateTimeType.TOMORROW)) {
     formattedDate.setDate(formattedDate.getDate() + 1);
     end = new Date(formattedDate.getFullYear(), formattedDate.getMonth(), formattedDate.getDate(), 23, 59, 59);
     start = new Date(formattedDate.getFullYear(), formattedDate.getMonth(), formattedDate.getDate(), 0, 0, 0);
   } else if (kony.sdk.util.matchIgnoreCase(dateType, kony.sdk.constants.DateTimeType.YESTERDAY)) {
     formattedDate.setDate(formattedDate.getDate() - 1);
     end = new Date(formattedDate.getFullYear(), formattedDate.getMonth(), formattedDate.getDate(), 23, 59, 59);
     start = new Date(formattedDate.getFullYear(), formattedDate.getMonth(), formattedDate.getDate(), 0, 0, 0);
   } else if (kony.sdk.util.matchIgnoreCase(dateType, kony.sdk.constants.DateTimeType.CURRENTWEEK)) {
     var firstDayofWeek = formattedDate.getDate() - formattedDate.getDay();
     var lastDayofWeek = firstDayofWeek + 6;
     formattedDate.setDate(firstDayofWeek);
     start = new Date(formattedDate.getFullYear(), formattedDate.getMonth(), formattedDate.getDate(), 0, 0, 0);
     formattedDate.setDate(lastDayofWeek);
     end = new Date(formattedDate.getFullYear(), formattedDate.getMonth(), formattedDate.getDate(), 23, 59, 59);
   } else if (kony.sdk.util.matchIgnoreCase(dateType, kony.sdk.constants.DateTimeType.LASTWEEK)) {
     formattedDate.setDate(formattedDate.getDate() - 7);
     var firstDayofWeek = formattedDate.getDate() - formattedDate.getDay();
     var lastDayofWeek = firstDayofWeek + 6;
     formattedDate.setDate(firstDayofWeek);
     start = new Date(formattedDate.getFullYear(), formattedDate.getMonth(), formattedDate.getDate(), 0, 0, 0);
     formattedDate.setDate(lastDayofWeek);
     end = new Date(formattedDate.getFullYear(), formattedDate.getMonth(), formattedDate.getDate(), 23, 59, 59);
   } else if (kony.sdk.util.matchIgnoreCase(dateType, kony.sdk.constants.DateTimeType.NEXTWEEK)) {
     formattedDate.setDate(formattedDate.getDate() + 7);
     var firstDayofWeek = formattedDate.getDate() - formattedDate.getDay();
     var lastDayofWeek = firstDayofWeek + 6;
     formattedDate.setDate(firstDayofWeek);
     start = new Date(formattedDate.getFullYear(), formattedDate.getMonth(), formattedDate.getDate(), 0, 0, 0);
     formattedDate.setDate(lastDayofWeek);
     end = new Date(formattedDate.getFullYear(), formattedDate.getMonth(), formattedDate.getDate(), 23, 59, 59);
   } else if (kony.sdk.util.matchIgnoreCase(dateType, kony.sdk.constants.DateTimeType.CURRENTMONTH)) {
     start = new Date(formattedDate.getFullYear(), formattedDate.getMonth(), 1, 0, 0, 0);
     end = new Date(formattedDate.getFullYear(), formattedDate.getMonth() + 1, 0, 23, 59, 59);
   } else if (kony.sdk.util.matchIgnoreCase(dateType, kony.sdk.constants.DateTimeType.LASTMONTH)) {
     start = new Date(formattedDate.getFullYear(), formattedDate.getMonth() - 1, 1, 0, 0, 0, 0);
     end = new Date(formattedDate.getFullYear(), formattedDate.getMonth(), 0, 23, 59, 59, 999);
   } else if (kony.sdk.util.matchIgnoreCase(dateType, kony.sdk.constants.DateTimeType.NEXTMONTH)) {
     start = new Date(formattedDate.getFullYear(), formattedDate.getMonth() + 1, 1, 0, 0, 0, 0);
     end = new Date(formattedDate.getFullYear(), formattedDate.getMonth() + 2, 0, 23, 59, 59, 999);
   } else {
     start = 0;
     end = 0;
   }
   result.push(start);
   result.push(end);
   return result;
 };
 //Helps to prepare the primary condition to get binary data
 kony.sdk.util.getPkTableForBinary = function(objMetadata, columnValues, failureCallback) {
   kony.sdk.logsdk.trace("Entering into kony.sdk.util.getPkTableForBinary");
   var pkTable = {};
   var whereClause = [];
   if (!kony.sdk.isNullOrUndefined(objMetadata.primaryKey)) {
     for (var indx = 0; indx < objMetadata.primaryKey.length; indx++) {
       var pKey = objMetadata.primaryKey[indx];
       var pKeyValue = columnValues[pKey];
       if (kony.sdk.isNullOrUndefined(pKeyValue)) {
         kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getClientErrObj(kony.sdk.errorcodes.primarykey_unavailable, kony.sdk.errormessages.primarykey_unavailable));
         return;
       }
       pkTable[pKey] = pKeyValue;
     }
     return pkTable;
   } else {
     kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getClientErrObj(kony.sdk.errorcodes.primarykey_unavailable, kony.sdk.errormessages.primarykey_unavailable));
   }
 };
 //Helps to provide the Metadata of column in a Object
 kony.sdk.util.getMetadataOfColumn = function(objMetadata, colName) {
   kony.sdk.logsdk.trace("Entering into kony.sdk.util.getMetadataOfColumn");
   if (objMetadata != null && objMetadata != undefined) {
     var columns = objMetadata["columns"];
     if (columns != null && columns != undefined) {
       for (var indx in columns) {
         var colMeta = columns[indx];
         if (colMeta["name"] == colName) {
           return colMeta;
         }
       }
     }
   }
   return null;
 };
 //Helps in generating kony.sdk.dto.RecordObject from a given complex record
 kony.sdk.util.populateColumnValues = function(record, childRecords) {
   kony.sdk.logsdk.trace("Entering into kony.sdk.util.populateColumnValues");
   var columnValues = {};
   var recordsLength = Object.keys(record).length;
   for (var index = 0; index < recordsLength; index++) {
     var colName = Object.keys(record)[index];
     var colVal = record[colName];
     if (colVal instanceof Array) {
       for (var tempIndex = 0; tempIndex < colVal.length; tempIndex++) {
         var tempRecord = new kony.sdk.dto.RecordObject();
         tempRecord.tableName = colName;
         tempRecord.columnValues = kony.sdk.util.populateColumnValues(record[colName][tempIndex], tempRecord.childRecords);
         childRecords.push(tempRecord);
       }
     } else {
       columnValues[colName] = colVal;
     }
   }
   return columnValues;
 };
 //Helps in getting the relationship data of an entity from a given relationship list
 kony.sdk.util.getRelationOfEntity = function(relationshipList, entityName) {
   kony.sdk.logsdk.trace("Entering into kony.sdk.util.getRelationOfEntity");
   var i = 0;
   for (; i < relationshipList.length; i++) {
     //considering only OneToMany relationships as it will have parent and child hierarchy
     if (relationshipList[i] != null && relationshipList[i]["relationshipType"] == "OneToMany" && relationshipList[i].relatedEntity.localeCompare(entityName) == 0) {
       return relationshipList[i];
     }
   }
   return null;
 };
 //Helps in finding if a given column name is a primary key
 kony.sdk.util.isPrimaryKey = function(primaryKeyList, columnValue) {
   kony.sdk.logsdk.trace("Entering into kony.sdk.util.isPrimaryKey");
   for (var i = 0; i < primaryKeyList.length; i++) {
     if (primaryKeyList[i] == columnValue) return true;
   }
   return false;
 };
 kony.sdk.util.objectToQueryParams = function(valueObject) {
   kony.sdk.logsdk.trace("Entering into kony.sdk.util.objectToQueryParams ");
   var queryParams = "";
   if (!kony.sdk.isNullOrUndefined(valueObject) && valueObject instanceof Object && Object.keys(valueObject).length > 0) {
     var objCount = Object.keys(valueObject).length;
     for (var i = 0; i < objCount; i++) {
       var tempKey = Object.keys(valueObject)[i];
       if (queryParams.length === 0) queryParams = encodeURIComponent(tempKey) + "=" + encodeURIComponent(valueObject[tempKey]);
       else queryParams = queryParams + "&" + encodeURIComponent(tempKey) + "=" + encodeURIComponent(valueObject[tempKey]);
     }
   }
   return queryParams;
 };
 kony.sdk.util.getPackagedMetadata = function() {
   kony.sdk.logsdk.trace("Entering into   kony.sdk.util.getPackagedMetadata");
   if (kony.sdk.APP_META === undefined || kony.sdk.APP_META === null) {
     kony.sdk.APP_META = {};
   }
   return kony.sdk.APP_META["objectsvc_meta"];
 };
 /**
  User needs to call this API to prepackage the metadata of the app. The data needs to be passed as json object or a stringified version of json object
  */
 kony.sdk.util.setPackagedMetadata = function(metadataJson) {
   kony.sdk.logsdk.trace("Entering into   kony.sdk.util.setPackagedMetadata");
   try {
     if (typeof metadataJson == "object") {
       kony.sdk.APP_META = metadataJson;
     } else if (typeof metadataJson == "string") {
       var parsedMetadata = JSON.parse(metadataJson);
       kony.sdk.APP_META = parsedMetadata;
     }
   } catch (error) {
     kony.sdk.logsdk.error("### kony.sdk.setPackagedMetadata::error while validating the input packaged metadata", error);
   }
 };
 stripTrailingCharacter = function(str, character) {
   kony.sdk.logsdk.trace("Entering into stripTrailingCharacter");
   if (str.substr(str.length - 1) === character) {
     return str.substr(0, str.length - 1);
   }
   return str;
 };
 kony.sdk.setLogLevelFromServerResponse = function(responseHeaders) {
   kony.sdk.logsdk.trace("Entering into kony.sdk.setLogLevelFromServerResponse");
   var sdkRef = kony.sdk.getCurrentInstance();
   if (responseHeaders && responseHeaders[kony.logger.deviceLogLevelHeader]) {
     logLevel = responseHeaders[kony.logger.deviceLogLevelHeader].toUpperCase();
     if (!logLevel.localeCompare(kony.logger.logLevel.NONE.code) && kony.logger.currentLogLevel !== kony.logger.logLevel.NONE) kony.logger.currentLogLevel = kony.logger.logLevel.NONE;
     else if (!logLevel.localeCompare(kony.logger.logLevel.FATAL.code) && kony.logger.currentLogLevel !== kony.logger.logLevel.FATAL) kony.logger.currentLogLevel = kony.logger.logLevel.FATAL;
     else if (!logLevel.localeCompare(kony.logger.logLevel.ERROR.code) && kony.logger.currentLogLevel !== kony.logger.logLevel.ERROR) kony.logger.currentLogLevel = kony.logger.logLevel.ERROR;
     else if (!logLevel.localeCompare(kony.logger.logLevel.WARN.code) && kony.logger.currentLogLevel !== kony.logger.logLevel.WARN) kony.logger.currentLogLevel = kony.logger.logLevel.WARN;
     else if (!logLevel.localeCompare(kony.logger.logLevel.PERF.code) && kony.logger.currentLogLevel !== kony.logger.logLevel.PERF) kony.logger.currentLogLevel = kony.logger.logLevel.PERF;
     else if (!logLevel.localeCompare(kony.logger.logLevel.INFO.code) && kony.logger.currentLogLevel !== kony.logger.logLevel.INFO) kony.logger.currentLogLevel = kony.logger.logLevel.INFO;
     else if (!logLevel.localeCompare(kony.logger.logLevel.DEBUG.code) && kony.logger.currentLogLevel !== kony.logger.logLevel.DEBUG) kony.logger.currentLogLevel = kony.logger.logLevel.DEBUG;
     else if (!logLevel.localeCompare(kony.logger.logLevel.TRACE.code) && kony.logger.currentLogLevel !== kony.logger.logLevel.TRACE) kony.logger.currentLogLevel = kony.logger.logLevel.TRACE;
     else if (!logLevel.localeCompare(kony.logger.logLevel.ALL.code) && kony.logger.currentLogLevel !== kony.logger.logLevel.ALL) kony.logger.currentLogLevel = kony.logger.logLevel.ALL;
     else if (!logLevel.localeCompare('OFF')) {
       kony.logger.deactivatePersistors(kony.logger.networkPersistor);
       kony.logger.currentLogLevel = kony.logger.logLevel.NONE;
       sdkRef.removeGlobalRequestParam(kony.logger.deviceLogLevelHeader, sdkRef.globalRequestParamType.headers);
       return;
     } else {
       return;
     }
     sdkRef.setGlobalRequestParam(kony.logger.deviceLogLevelHeader, logLevel, sdkRef.globalRequestParamType.headers);
     kony.logger.activatePersistors(kony.logger.networkPersistor);
   }
 };
 kony.sdk.prototype.enableDebug = function() {
   kony.sdk.logsdk.trace("Entering into kony.sdk.prototype.enableDebug");
   kony.sdk.isDebugEnabled = true;
 };
 kony.sdk.prototype.disableDebug = function() {
   kony.sdk.logsdk.trace("Entering into kony.sdk.prototype.disableDebug");
   kony.sdk.isDebugEnabled = false;
 };

 function Exception(name, message) {
   kony.sdk.logsdk.error("Exception --> " + name + ": " + message);
   return {
     code: name,
     message: message
   };
 }
 kony.sdk.verifyAndCallClosure = function(closure, params) {
   if (typeof(closure) === 'function') {
     closure(params);
   } else {
     kony.sdk.logsdk.warn("invalid callback", JSON.stringify(closure));
   }
 };
 kony.sdk.overrideUserId = function(userId) {
   kony.sdk.logsdk.trace("Entering into kony.sdk.overrideUserId");
   if (kony.sdk.getSdkType() === kony.sdk.constants.SDK_TYPE_IDE && typeof(kony.setUserID) === 'function') {
     kony.setUserID(userId, true);
   } else {
     konyRef.setCurrentUserId(userId);
   }
 };
 kony.sdk.formatCurrentDate = function(inputDateString) {
   kony.sdk.logsdk.trace("Entering into kony.sdk.formatCurrentDate");
   var dateObj = new Date(inputDateString);
   var year = dateObj.getUTCFullYear();
   var month = kony.sdk.formatDateComponent(dateObj.getUTCMonth() + 1);
   var date = kony.sdk.formatDateComponent(dateObj.getUTCDate());
   var hours = kony.sdk.formatDateComponent(dateObj.getUTCHours());
   var minutes = kony.sdk.formatDateComponent(dateObj.getUTCMinutes());
   var seconds = kony.sdk.formatDateComponent(dateObj.getUTCSeconds());
   var dateSeparator = "-";
   var timeSeparator = ":";
   var dateString = year + dateSeparator + month + dateSeparator + date + " " + hours + timeSeparator + minutes + timeSeparator + seconds;
   return dateString;
 };
 kony.sdk.formatDateComponent = function(dateComponent) {
   kony.sdk.logsdk.trace("Entering into kony.sdk.formatDateComponent");
   if (dateComponent < 10) {
     dateComponent = "0" + dateComponent;
   }
   return dateComponent;
 };
 kony.sdk.isNullOrUndefined = function(val) {
   if (val === null || val === undefined) {
     return true;
   } else {
     return false;
   }
 };
 kony.sdk.constants.reportingType = {
   session: "session",
   custom: "custom"
 };
 kony.sdk.isEmptyObject = function(obj) {
   if (typeof(obj) === "boolean" || typeof(obj) === "number") {
     return false;
   } else if (typeof(obj) === "string") {
     return obj.trim().length === 0;
   }
   for (var prop in obj) {
     return false;
   }
   return true;
 };
 kony.sdk.util.isNullOrUndefinedOrEmptyObject = function(object) {
   return (kony.sdk.isNullOrUndefined(object) || kony.sdk.isEmptyObject(object));
 };
 kony.sdk.isArray = function(data) {
   if (data && Object.prototype.toString.call(data) === '[object Array]') {
     return true;
   }
   return false;
 };
 kony.sdk.getDefaultHeaders = function() {
   var headers = {};
   return kony.sdk.addDefaultHeaders(headers);
 };
 kony.sdk.addDefaultHeaders = function(headers) {
   if (kony.sdk.isNullOrUndefined(headers)) {
     headers = {};
   }
   // Add Request_ID_Header for TemnTracer
   if (!headers.hasOwnProperty(kony.sdk.constants.REQUEST_ID_HEADER)) {
     headers[kony.sdk.constants.REQUEST_ID_HEADER] = kony.license.generateUUID().toString();
   }
   return headers;
 };
 kony.sdk.formatSuccessResponse = function(data) {
   if (data && data.httpresponse) {
     delete data.httpresponse;
   }
   return data;
 };
 kony.sdk.isJson = function(str) {
   try {
     JSON.parse(str);
   } catch (e) {
     return false;
   }
   return true;
 };
 kony.sdk.util.getString = function(val) {
   if (!kony.sdk.isNullOrUndefined(val) && (val.toString()).toLocaleLowerCase() !== "null") {
     return val.toString();
   }
   return "";
 };
 //private method to identify whether session/token expired or not based on error code
 kony.sdk.isSessionOrTokenExpired = function(mfcode) {
   if (mfcode && (mfcode === "Auth-5" || mfcode === "Auth-6" || mfcode === "Gateway-31" || mfcode === "Gateway-33" || mfcode === "Gateway-35" || mfcode === "Gateway-36" || mfcode === "Auth-46" || mfcode === "Auth-55")) {
     return true;
   }
   return false;
 };
 //private method to clear cache
 kony.sdk.resetProviderKeys = function(konyRef, _providerName) {
   try {
     if (konyRef) {
       if (_providerName) {
         if (konyRef.tokens.hasOwnProperty(_providerName)) {
           konyRef.tokens[_providerName] = null;
         }
       }
     }
   } catch (e) {
     kony.sdk.logsdk.error("Error while clearing the cache..");
   }
 };
 //private method to clear cache
 kony.sdk.resetCurrentKeys = function(konyRef, _providerName) {
   try {
     if (konyRef) {
       konyRef.currentClaimToken = null;
       konyRef.currentBackEndToken = null;
       konyRef.claimTokenExpiry = null;
       konyRef.currentRefreshToken = null;
       //setting the anonymous provider as true to access the public protected urls without any issue
       konyRef.isAnonymousProvider = true;
       if (_providerName) {
         if (konyRef.tokens.hasOwnProperty(_providerName)) {
           konyRef.tokens[_providerName] = null;
         }
       }
     }
   } catch (e) {
     kony.sdk.logsdk.error("Error while clearing the cache..");
   }
 };
 kony.sdk.util.populateIndividualServiceLists = function(serviceConfig, objectToPopulate) {
   kony.sdk.logsdk.trace("Entering into kony.sdk.util.populateIndividualServiceLists");
   var svcMeta = serviceConfig["services_meta"];
   if (kony.sdk.isNullOrUndefined(objectToPopulate["objectsvc"])) {
     objectToPopulate["objectsvc"] = {};
   }
   if (kony.sdk.isNullOrUndefined(objectToPopulate["offlineObjectsvc"])) {
     objectToPopulate["offlineObjectsvc"] = {};
   }
   if (svcMeta) {
     for (var svc in svcMeta) {
       if (svcMeta.hasOwnProperty(svc)) {
         var svcObj = svcMeta[svc];
         if (svcObj && svcObj["type"] === "objectsvc") {
           if (!kony.sdk.isNullOrUndefined(svcObj["offline"])) {
             if (svcObj["offline"] === false) {
               objectToPopulate["objectsvc"][svc] = svcObj;
             } else if (svcObj["offline"] === true) {
               objectToPopulate["offlineObjectsvc"][svc] = svcObj;
             }
           } else {
             objectToPopulate["objectsvc"][svc] = svcObj;
             objectToPopulate["offlineObjectsvc"][svc] = svcObj;
           }
         } else if (svcObj && svcObj["type"] === "integsvc") {
           objectToPopulate["integsvc"][svc] = svcObj;
         }
       }
     }
   }
 };
 /**
  * Generates hash code for the URL by sha512 algorithm
  * @param url
  * @param requestParams
  * @return {*}
  */
 kony.sdk.util.generateHashcodeForURL = function(url, requestParams) {
   var concatenatedResult = "";
   var hashID = null;
   if (!kony.sdk.isNullOrUndefined(url)) concatenatedResult += url;
   if (!kony.sdk.isNullOrUndefined(requestParams)) {
     concatenatedResult += JSON.stringify(requestParams);
   }
   if (kony.sdk.getSdkType() === kony.sdk.constants.SDK_TYPE_IDE && !kony.sdk.util.isNullOrEmptyString(concatenatedResult)) {
     hashID = kony.crypto.createHash("sha512", concatenatedResult);
   }
   return hashID;
 };
 /**
  * Utility function to save the response in the cache.
  * @param options {object} save the response with key options["cacheID"]. If not provided then we will calculate hashcode by url and requestData.
  * @param url {string}
  * @param requestData {object}
  * @param response {object}
  */
 function cacheResponseForKey(options, url, requestData, response) {
   var hashCode = null;
   if (options["cacheID"]) hashCode = options["cacheID"];
   else hashCode = kony.sdk.util.generateHashcodeForURL(url, requestData);
   if (hashCode) {
     if (typeof(hashCode) !== "string") {
       hashCode = hashCode.toString();
     }
     var expiry = options["expiryTime"] ? options["expiryTime"] : kony.sdk.constants.DEFAULT_CACHE_EXPIRY_TIME;
     response["cacheID"] = hashCode;
     new kony.sdk.ClientCache().add(hashCode, response, expiry);
   }
 }
 kony.sdk.util.isNullOrEmptyString = function(val) {
   if (kony.sdk.isNullOrUndefined(val) || (typeof(val) === "string" && val.trim() === "")) {
     return true;
   }
   return false;
 };

 function doesMFSupportsAppversioning() {
   // In case of IDE platforms we will check the existence of appConfig.svcDoc.service_doc_etag for compatibility of app version with the MF.
   // In case of plain-js & phone gap initOptions should not be sent during init call.
   // In case of manual init initially appConfig.svcDoc.service_doc_etag will be undefined. so checking appConfig.isMFApp flag for manual init.
   // Note: With the latest codes changes as part of APPPLT-7480 in 9.3 version for plainjs kony.sdk.constants.SDK_TYPE_IDE will have 'js'.
   if (kony.sdk.getSdkType() === kony.sdk.constants.SDK_TYPE_IDE && !kony.sdk.isNullOrUndefined(appConfig)) {
     if ((!kony.sdk.isNullOrUndefined(appConfig.svcDoc) && !kony.sdk.isNullOrUndefined(appConfig.svcDoc.service_doc_etag)) || !appConfig.isMFApp) {
       return true;
     } else {
       return false;
     }
   } else if (kony.sdk.getSdkType() === kony.sdk.constants.SDK_TYPE_PHONEGAP) {
     return true;
   } else {
     return false;
   }
 }

 function populateHeaderWithFabricAppVersion(headers) {
   if (doesMFSupportsAppversioning() && !kony.sdk.isNullOrUndefined(headers) && !kony.sdk.isNullOrUndefined(kony.sdk.getFabricAppVersion())) {
     headers[kony.sdk.constants.APP_VERSION_HEADER] = kony.sdk.getFabricAppVersion();
   }
 }
 /*
  * Utility method to check whether options has browserWidget or not
  * @return true if it supports
  * */
 kony.sdk.util.hasBrowserWidget = function(options) {
   return options && options[kony.sdk.constants.BROWSER_WIDGET] && kony.sdk.util.type(options[kony.sdk.constants.BROWSER_WIDGET]) === "kony.ui.Browser";
 };
 /*
  * Utility method to check whether binary is supported
  * @return true if it supports
  * */
 kony.sdk.util.isBinarySupported = function() {
   return kony.sdk.getSdkType() === kony.sdk.constants.SDK_TYPE_IDE && kony.sdk.getAType() === kony.sdk.constants.SDK_ATYPE_NATIVE;
 };
 /**
  * Utility method to populate authorization headers for Login
  *
  * @params headers map for adding authorization headers
  * @params _providerName provider name for SSO
  * */
 kony.sdk.util.populateAuthorizationHeaderForLogin = function(headers, _providerName) {
   if (kony.sdk.sso.isSSOEnabled === true) {
     var ssotoken = kony.sdk.util.getSSOTokenForProvider(_providerName);
     if (!kony.sdk.util.isNullOrEmptyString(ssotoken)) {
       headers[kony.sdk.constants.AUTHORIZATION_HEADER] = ssotoken;
     } else {
       kony.sdk.logsdk.warn("SSO Token retrieved is empty.");
     }
   }
   if (!kony.sdk.isNullOrUndefined(konyRef.currentClaimToken) && !kony.sdk.isClaimsTokenExpired(konyRef.claimTokenExpiry)) {
     headers[kony.sdk.constants.KONY_AUTHORIZATION_HEADER] = konyRef.currentClaimToken;
   }
 };
 /**
  * Returns the SSO token for the provider.
  *
  *@param _providerName provider for which token is to be deleted
  * @return SSO token
  */
 kony.sdk.util.getSSOTokenForProvider = function(_providerName) {
   kony.sdk.logsdk.trace("Entered Method : getSSOTokenForProvider.");
   var tokenString = kony.sdk.util.getSSOToken();
   if (kony.sdk.util.isNullOrEmptyString(tokenString)) {
     kony.sdk.logsdk.warn("SSO token is either empty,null or undefined for provider:" + _providerName);
     return null;
   }
   var tokenJSON = JSON.parse(tokenString);
   return tokenJSON[_providerName.toLowerCase()];
 };
 /**
  * Add/Replace and Returns the stringified SSO JSON with
  * the new token and provider or
  * updates the existing one.
  *
  * @param ssoToken token to be added or updated
  * @param _providerName for which the token has to be added
  *
  * @return  Stringified SSO token JSON"{*}"
  */
 kony.sdk.util.addOrUpdateSSOTokenWithProvider = function(ssoToken, _providerName) {
   kony.sdk.logsdk.trace("Entered Method : addOrUpdateSSOTokenWithProvider.");
   var tokenJSON = {};
   var tokenString = kony.sdk.util.getSSOToken();
   if (!kony.sdk.util.isNullOrEmptyString(tokenString)) {
     tokenJSON = JSON.parse(tokenString);
   }
   tokenJSON[_providerName.toLowerCase()] = ssoToken;
   return JSON.stringify(tokenJSON);
 };
 /**
  * Deletes the SSO Token for the
  *
  * @parmas _providerName for which the token has to be deleted
  */
 kony.sdk.util.deleteSSOTokenForProvider = function(_providerName) {
   kony.sdk.logsdk.trace("Entered Method: deleteSSOTokenForProvider.");
   var tokenString = kony.sdk.util.getSSOToken();
   if (kony.sdk.util.isNullOrEmptyString(tokenString)) {
     kony.sdk.logsdk.warn("SSO token is either empty,null or undefined for provider:" + _providerName);
     return null;
   }
   var tokenJSON = JSON.parse(tokenString);
   delete tokenJSON[_providerName.toLowerCase()];
   kony.sdk.util.saveSSOToken(JSON.stringify(tokenJSON));
 };
 /*
  ** Utility method to clone any object
  *  @return cloned object
  */
 kony.sdk.cloneObject = function(obj) {
   var clonedObject;
   try {
     clonedObject = JSON.parse(JSON.stringify(obj));
   } catch (err) {
     kony.sdk.logsdk.error("cloning object failed, reverting back to copy");
     clonedObject = obj;
   }
   return clonedObject;
 };
 /**
  * Utility method to check if a given variable is JSON Object
  * @param obj
  * @returns {boolean}
  */
 kony.sdk.util.isJsonObject = function(obj) {
   if (obj === null || obj === undefined) {
     return false;
   }
   return obj.constructor === {}.constructor;
 };
 /**
  * Utility method to check whether the given variable is a valid string
  * @param str
  * @returns {boolean}
  */
 kony.sdk.util.isValidString = function(str) {
   if (str === null || str === undefined || str.constructor !== "".constructor) {
     return false;
   }
   return str.trim() !== ""
 };
 /**
  * Utility method to convert JSON object keys to lower case
  * @param obj {Object} - JSON object
  * @returns convertedJSON {Object} - JSON object keys in lower case and values assigned to respective keys.
  */
 kony.sdk.util.convertJsonKeysToLowerCase = function(obj) {
   var convertedJSON = {};
   if (!kony.sdk.util.isJsonObject(obj)) {
     return obj;
   }
   var keys = Object.keys(obj);
   for (var i = 0; i < keys.length; i++) {
     convertedJSON[keys[i].toLowerCase()] = obj[keys[i]];
   }
   return convertedJSON;
 };
 /**
  * Utility method to get JSON property case-insensitively
  * @param {Object} jsonObject
  * @param {String} key
  * @returns {*}
  */
 kony.sdk.util.getValueForKeyAndIgnoreCase = function(jsonObject, key) {
   var keysInJSON = Object.keys(jsonObject);
   var index = 0;
   for (var jsonKey in keysInJSON) {
     if (keysInJSON[jsonKey].toLocaleLowerCase() === key.toLocaleLowerCase()) {
       return Object.values(jsonObject)[index];
     } else {
       index++
     }
   }
   return null;
 };
 /**
  * Utility method to populate JSON Template
  * @param {String} template
  * @param {Object} templateParams : Input Params provided by the User
  * @return Object containing processed template and missing variables
  */
 kony.sdk.util.populateTemplate = function(template, templateParams) {
   if (kony.sdk.util.isNullOrEmptyString(template) || !kony.sdk.util.isJsonObject(templateParams)) {
     kony.sdk.logsdk.error(kony.sdk.errorConstants.populating_template_failed + " " + kony.sdk.errormessages.populating_template_failed);
     return null;
   }
   var DOLLAR_VARIABLE_PATTERN = /(\${)+(\w.*?)+(})/g;
   var templateVariables = [];
   var missingVariables = [];
   var resultSet = {};
   var populatedTemplate = kony.sdk.cloneObject(template);
   var inputTemplateVariables = populatedTemplate.match(DOLLAR_VARIABLE_PATTERN);
   //Match returns Array of all the matches.
   //Iterating over the array and extracting all template variables.
   for (var iteratorVariable in inputTemplateVariables) {
     var inputVariable = inputTemplateVariables[iteratorVariable].toString();
     var templateParameter = inputVariable.slice(2, (inputVariable.length) - 1);
     templateVariables.push(templateParameter);
   }
   //Populating the template with user inputs.
   for (var iterateVariable = 0; iterateVariable < templateVariables.length; iterateVariable++) {
     var inputParameter = templateVariables[iterateVariable];
     if (templateParams.hasOwnProperty(inputParameter)) {
       populatedTemplate = populatedTemplate.replace("${" + inputParameter + "}", templateParams[inputParameter]);
     } else {
       missingVariables.push(inputParameter);
     }
   }
   resultSet[kony.sdk.constants.PROCESSED_TEMPLATE] = populatedTemplate;
   resultSet[kony.sdk.constants.MISSING_VARIABLES] = missingVariables;
   return resultSet;
 };
 /**
  * Checks if the browser is IE11
  * @returns {boolean}
  */
 kony.sdk.util.checkForIE11 = function() {
   //Checking if this is being run in DesktopWeb
   if (typeof(XMLHttpRequest) !== 'undefined') {
     var ua = window.navigator.userAgent;
     var trident = ua.indexOf('Trident/');
     if (trident > 0) {
       // IE 11 => return version number
       var rv = ua.indexOf('rv:');
       return parseInt(ua.substring(rv + 3, ua.indexOf('.', rv)), 10) === 11;
     }
   }
   return false;
 };
 /**
  * Based on interactive or non-interactive session info from license, returning session type
  * @return {string}
  */
 kony.sdk.util.getSessionType = function() {
   var sessionType;
   if (kony.licensevar && kony.licensevar.isInteractive != undefined) {
     sessionType = kony.licensevar.isInteractive ? kony.sdk.constants.APP_SESSION_INTERACTIVE : kony.sdk.constants.APP_SESSION_NON_INTERACTIVE;
   } else {
     /**
      *In case of phonegap and plain js, we are sending interacting session.
      */
     kony.sdk.logsdk.trace("Updating interacting session in kony reporting params by default");
     sessionType = kony.sdk.constants.APP_SESSION_INTERACTIVE;
   }
   return sessionType;
 };
 /**
  * Utility method to get kony reporting params in encoded string
  * @return {string}
  */
 kony.sdk.getEncodedReportingParamsForSvcid = function(svcid) {
   var reportingData = kony.sdk.getPayload(konyRef);
   reportingData.rsid = kony.sdk.currentInstance.getSessionId();
   if (svcid) {
     reportingData.svcid = svcid;
   } else {
     kony.sdk.logsdk.warn("### kony.sdk.getEncodedReportingParamsForSvcid:: svcid is either null or undefined");
   }
   return encodeURI(JSON.stringify(reportingData));
 };
 /**
  * Utility method to know if PWA app's display mode is standalone or fullscreen
  * @returns {boolean}
  */
 kony.sdk.util.isPWAStandaloneOrFullscreen = function() {
   if (!kony.sdk.isNullOrUndefined(window) && window.matchMedia && ((window.matchMedia('(display-mode: standalone)').matches) || (window.matchMedia('(display-mode: fullscreen)').matches) || (window.navigator && window.navigator.standalone))) {
     return true;
   } else {
     return false;
   }
 }
 /**
  * Utility method to know if the device is a mobile device
  * @returns {boolean}
  */
 kony.sdk.util.isMobileDevice = function() {
   if (!kony.sdk.isNullOrUndefined(navigator) && (/mobile/gi).test(navigator.userAgent)) {
     return true;
   } else {
     return false;
   }
 }
 /**
  * Utility method to open a new browser window as popup in the center of device screen
  * @returns {Object} WindowProxyObject on success of window open and null on failure
  */
 kony.sdk.util.openPopupWindow = function(url, title) {
   var height = (screen.height * 75) / 100;
   var width = (screen.width * 40) / 100;
   var left = (screen.width / 2) - (width / 2);
   var top = (screen.height / 2) - (height / 2);
   return window.open(url, title, 'width=' + width + ', height=' + height + ', top=' + top + ', left=' + left);
 };
 /**
  * Utility method to prefix appId to a string
  * @param {String} str
  * @returns {String}
  */
 kony.sdk.util.prefixAppid = function(str) {
   return appConfig.appId + "_" + str;
 };
 /**
  * Utility method to clear any existing internal objects
  */
 kony.sdk.util.clearExistingWebsocketObject = function() {
   var options = {};
   options[kony.sdk.constants.SERVER_EVENTS_CLOSE_CONNECTION] = true;
   if (kony.sdk.websocket && kony.sdk.websocket.isWebSocketAvailable()) {
     kony.sdk.websocket.unSubscribeServerEvents("", function() {
       kony.sdk.logsdk.info("Existing websocket connection closed!");
     }, options);
   }
 };
 /**
  * Utility method to get key from value of an object
  */
 kony.sdk.util.getKeyByValue = function(obj, value) {
   for (var prop in obj) {
     if (obj.hasOwnProperty(prop)) {
       if (obj[prop] === value) return prop;
     }
   }
 };
 /***
  * Utility function to populate custom oAuth params in body params
  * @param {Object} bodyParams : body params to be populated
  * @param {Object} customOAuthParams : custom oAuth params to populate
  */
 kony.sdk.util.populateCustomOAuthParams = function(bodyParams, customOAuthParams) {
   if (kony.sdk.util.isNullOrUndefinedOrEmptyObject(customOAuthParams)) {
     return;
   }
   if (kony.sdk.isNullOrUndefined(bodyParams)) {
     bodyParams = {};
   }
   for (var customOAuthParamKey in customOAuthParams) {
     var customOAuthParamValue = customOAuthParams[customOAuthParamKey];
     if (typeof customOAuthParamValue === "boolean") {
       customOAuthParamValue = customOAuthParamValue.toString();
       bodyParams[customOAuthParamKey] = customOAuthParamValue;
     } else if (!kony.sdk.util.isNullOrEmptyString(customOAuthParamValue)) {
       bodyParams[customOAuthParamKey] = customOAuthParamValue;
     }
   }
 }
 kony.sdk.serviceDoc = function() {
   kony.sdk.logsdk.trace("Entering into kony.sdk.serviceDoc");
   var appId = "";
   var baseId = "";
   var services_meta = {};
   var name = "";
   var selflink = "";
   var login = null;
   var integsvc = {};
   var reportingsvc = {};
   var messagingsvc = {};
   var sync = {};
   var objectsvc = {};
   var logicsvc = {};
   this.toJSON = function() {
     servConfig = {};
     servConfig.appId = this.getAppId();
     servConfig.baseId = this.getBaseId();
     servConfig.name = this.getAppName();
     servConfig.selflink = this.getSelfLink();
     servConfig.services_meta = this.getServicesMeta();
     servConfig.login = this.getAuthServices();
     servConfig.integsvc = this.getIntegrationServices();
     servConfig.messagingsvc = this.getMessagingServices();
     servConfig.sync = this.getSyncServices();
     servConfig.reportingsvc = this.getReportingServices();
     servConfig.objectsvc = this.getObjectServices();
     servConfig.logicsvc = this.getLogicServices();
     kony.sdk.util.populateIndividualServiceLists(this, servConfig);
     return servConfig;
   }
   this.setAppId = function(appIdStr) {
     appId = appIdStr;
   };
   this.getAppId = function() {
     return appId;
   };
   this.setBaseId = function(baseIdStr) {
     baseId = baseIdStr;
   };
   this.getBaseId = function() {
     return baseId;
   };
   this.setAppName = function(appName) {
     name = appName;
   };
   this.getAppName = function() {
     return name;
   };
   this.setSelfLink = function(selfLinkStr) {
     selflink = selfLinkStr;
   };
   this.getSelfLink = function() {
     return selflink;
   };

   function setEndPoints(providerType, providerValues) {
     for (var provider in providerValues) {
       providerType[provider] = providerValues[provider];
     }
   }
   this.setAuthService = function(loginProvider) {
     if (login === null) {
       login = [];
     }
     login.push(loginProvider);
   };
   //what will this return? name?
   this.getAuthServiceByName = function(authServiceProvider) {
     if (login === null) {
       return null;
     }
     for (var i in login) {
       var provider = login[i];
       if (provider.prov == authServiceProvider) {
         return provider;
       }
     }
   };
   this.getAuthServices = function() {
     return login;
   };
   this.setIntegrationService = function(providerName, endPointUrl) {
     integsvc[providerName] = endPointUrl;
   };
   this.getIntegrationServiceByName = function(integrationServiceProviderName) {
     return integsvc[integrationServiceProviderName];
   };
   this.getIntegrationServices = function() {
     return integsvc;
   };
   this.setObjectService = function(providerName, endPointUrl) {
     objectsvc[providerName] = endPointUrl;
   };
   this.getObjectServiceByName = function(objectServiceProviderName) {
     return objectsvc[objectServiceProviderName];
   };
   this.getObjectServices = function() {
     return objectsvc;
   };
   this.getLogicServices = function() {
     return logicsvc;
   };
   this.getServicesMeta = function() {
     return services_meta;
   };
   this.setReportingService = function(reportingType, url) {
     if (reportingType == kony.sdk.constants.reportingType.session || reportingType == kony.sdk.constants.reportingType.custom) {
       reportingsvc[reportingType] = url;
     } else {
       throw new Exception(kony.sdk.errorConstants.INIT_FAILURE, "invalid reporting type " + reportingType);
     }
   }
   this.getReportingServiceByType = function(reportingServiceProviderType) {
     return reportingsvc[reportingServiceProviderType];
   };
   this.getReportingServices = function() {
     return reportingsvc;
   };
   this.setMessagingService = function(appId, url) {
     messagingsvc[appId] = url;
   };
   this.getMessagingServiceByName = function(messagingServiceProviderName) {
     return messagingsvc[messagingServiceProviderName];
   };
   this.getMessagingServices = function() {
     return messagingsvc;
   }
   this.setSyncService = function(syncServiceProvider) {
     sync = syncServiceProvider;
   };
   this.getSyncServices = function() {
     return sync;
   };
 };
 kony.logger = kony.logger || {};
 kony.logger = {
   // Logger constants
   networkPersistorUrlEndpoint: "deviceLogs",
   deviceLogLevelHeader: "X-KONY-DEVICE-LOG-LEVEL",
   filePersistor: 1,
   consolePersistor: 2,
   networkPersistor: 4,
   // Log Level Block which gives all the handle for setting and getting
   //ALL(0) < TRACE(1) < DEBUG(2) < INFO(4) < PEF(8) < WARN(16) < ERROR(32) < FATAL(64) < NONE(127)
   logLevel: {
     NONE: {
       value: 127,
       name: "none",
       code: "NONE"
     },
     FATAL: {
       value: 64,
       name: "fatal",
       code: "FATAL"
     },
     ERROR: {
       value: 32,
       name: "error",
       code: "ERROR"
     },
     WARN: {
       value: 16,
       name: "warn",
       code: "WARN"
     },
     PERF: {
       value: 8,
       name: "perf",
       code: "PERF"
     },
     INFO: {
       value: 4,
       name: "info",
       code: "INFO"
     },
     DEBUG: {
       value: 2,
       name: "debug",
       code: "DEBUG"
     },
     TRACE: {
       value: 1,
       name: "trace",
       code: "TRACE"
     },
     ALL: {
       value: 0,
       name: "all",
       code: "ALL"
     }
   },
   get currentLogLevel() {
     if (typeof(currentLevel) === 'undefined') currentLevel = kony.logger.logLevel.NONE;
     if (kony.logger.isNativeLoggerAvailable()) {
       var logLevelValue = KonyLogger.getLogLevel();
       for (var key in kony.logger.logLevel) {
         if (kony.logger.logLevel.hasOwnProperty(key)) {
           if (kony.logger.logLevel[key].value == logLevelValue) {
             currentLevel = kony.logger.logLevel[key];
             break;
           }
         }
       }
     }
     return currentLevel;
   },
   set currentLogLevel(level) {
     currentLevel = level;
     if (kony.logger.isNativeLoggerAvailable()) KonyLogger.setLogLevel(currentLevel.value);
   },
   isNativeLoggerAvailable: function() {
     if (typeof(KonyLogger) === 'undefined') return false;
     else return true;
   },
   flush: function() {
     if (kony.logger.isNativeLoggerAvailable()) KonyLogger.flush();
   },
   // Persister block for activating and deactivating
   activatePersistors: function(activatedList) {
     if (kony.logger.isNativeLoggerAvailable()) KonyLogger.activatePersistors(activatedList);
   },
   deactivatePersistors: function(deactivatedList) {
     if (kony.logger.isNativeLoggerAvailable()) KonyLogger.deactivatePersistors(deactivatedList);
   },
   subscribeLogListener: function(logListener) {
     if (kony.logger.isNativeLoggerAvailable()) {
       if (typeof(logListener) === 'function') {
         KonyLogger.subscribeLogListener(logListener);
       } else {
         kony.sdk.logsdk.warn("loglistener is not a type of function", JSON.stringify(logListener));
       }
     }
   },
   unsubscribeLogListener: function() {
     if (kony.logger.isNativeLoggerAvailable()) KonyLogger.unsubscribeLogListener();
   },
   //setting claims token after referesh
   setClaimsToken: function() {
     var token = kony.sdk.getCurrentInstance().currentClaimToken;
     if (kony.logger.isNativeLoggerAvailable()) KonyLogger.setClaimsToken(token);
   },
   setConfig: function(loggerConfig) {
     if (kony.logger.isNativeLoggerAvailable()) {
       KonyLogger.setConfig(loggerConfig.getLoggerConfig());
     }
   },
   setPersistorConfig: function(persistor) {
     if (kony.logger.isNativeLoggerAvailable()) {
       KonyLogger.setPersistorConfig(persistor.getPersistorConfig());
     }
   },
   //Setting, removing and resetting global params
   setGlobalRequestParam: function(paramName, paramValue, paramType) {
     if (kony.logger.isNativeLoggerAvailable()) {
       KonyLogger.setGlobalRequestParam(paramName, paramValue, paramType);
     }
   },
   removeGlobalRequestParam: function(paramName, paramType) {
     if (kony.logger.isNativeLoggerAvailable()) {
       KonyLogger.removeGlobalRequestParam(paramName, paramType);
     }
   },
   resetGlobalRequestParams: function() {
     if (kony.logger.isNativeLoggerAvailable()) {
       KonyLogger.resetGlobalRequestParams();
     }
   },
   createLoggerObject: function(loggerName, loggerConfig) {
     var loggerObj = {};
     loggerObj.config = parseConfig(loggerConfig);
     loggerObj.trace = function(msg, params) {
       logMessage(loggerObj, kony.logger.logLevel.TRACE, msg, params);
     };
     loggerObj.debug = function(msg, params) {
       logMessage(loggerObj, kony.logger.logLevel.DEBUG, msg, params);
     };
     loggerObj.info = function(msg, params) {
       logMessage(loggerObj, kony.logger.logLevel.INFO, msg, params);
     };
     loggerObj.perf = function(msg, params) {
       logMessage(loggerObj, kony.logger.logLevel.PERF, msg, params);
     };
     loggerObj.warn = function(msg, params) {
       logMessage(loggerObj, kony.logger.logLevel.WARN, msg, params);
     };
     loggerObj.error = function(msg, params) {
       logMessage(loggerObj, kony.logger.logLevel.ERROR, msg, params);
     };
     loggerObj.fatal = function(msg, params) {
       logMessage(loggerObj, kony.logger.logLevel.FATAL, msg, params);
     };
     var indirectionLevel = 0;
     loggerObj.setIndirectionLevel = function(_indirectionLevel) {
       indirectionLevel = _indirectionLevel;
     }
     loggerObj.getIndirectionLevel = function() {
       return indirectionLevel;
     }
     loggerObj.loggerName = loggerName;
     return loggerObj;
   },
   createLoggerConfig: function() {
     var formatC = {};
     var logFilterC = {};
     var accConfig = {};
     var overrideConfig = true;
     var persistorList = [];
     if (kony.sdk.isNullOrUndefined(kony.logger.currentLogLevel)) {
       logFilterC.logLevel = kony.logger.logLevel.NONE.value;
     } else {
       logFilterC.logLevel = kony.logger.currentLogLevel.value;
     }
     var config = {
       //formatterConfig
       //timeformat
       set timeFormat(val) {
         formatC.timeFormat = val;
       },
       //timeZone
       set timeZone(val) {
         formatC.timeZone = val;
       },
       //FilterConfig
       //logLevel
       set logLevel(val) {
         logFilterC.logLevel = val;
       },
       //accumulatorConfig
       //bytesLimit
       set bytesLimit(val) {
         accConfig.bytesLimit = val;
       },
       //statementsLimit
       set statementsLimit(val) {
         accConfig.statementsLimit = val;
       },
       //overrideConfig
       set overrideConfig(val) {
         overrideConfig = val;
       },
       //peristorList
       get persistorList() {
         return persistorList;
       },
       addPersistor: function(val) {
         persistorList.push(val.getPersistorConfig());
       },
       getLoggerConfig: function() {
         var loggerConfig = {};
         if (Object.keys(formatC).length > 0) loggerConfig.formatterConfig = formatC;
         if (Object.keys(logFilterC).length > 0) loggerConfig.logFilterConfig = logFilterC;
         if (Object.keys(accConfig).length > 0) loggerConfig.accumulatorConfig = accConfig;
         if (overrideConfig !== null) loggerConfig.overrideConfig = overrideConfig;
         loggerConfig.persistors = persistorList;
         return loggerConfig;
       }
     };
     return config;
   },
   createFilePersistor: function() {
     var prop = {};
     var persistorProperties = {
       //Persistor properites
       get persistorType() {
         return kony.logger.filePersistor;
       },
       //maxNumberOfLogFiles
       set maxNumberOfLogFiles(val) {
         prop.maxNumberOfLogFiles = val;
       },
       //maxFileSize
       set maxFileSize(val) {
         prop.maxFileSize = val;
       },
       getPersistorConfig: function() {
         var perConfig = {};
         perConfig.type = this.persistorType;
         if (Object.keys(prop).length > 0) perConfig.properties = prop;
         return perConfig;
       }
     };
     return persistorProperties;
   },
   createNetworkPersistor: function() {
     var prop = {};
     var persistorProperties = {
       //persistorType
       get persistorType() {
         return kony.logger.networkPersistor;
       },
       //URL
       set URL(val) {
         prop.URL = val;
       },
       getPersistorConfig: function() {
         var perConfig = {};
         perConfig.type = this.persistorType;
         if (Object.keys(prop).length > 0) perConfig.properties = prop;
         return perConfig;
       }
     };
     return persistorProperties;
   },
   appLoggerInitialisation: function() {
     var loggerObj = {};
     loggerObj = new kony.logger.createNewLogger(kony.sdk.constants.APP_LOGGER_NAME, null);
     return loggerObj;
   },
   isValidJSTable: function(inputTable) {
     if (kony.sdk.isNullOrUndefined(inputTable)) {
       return false;
     }
     if (typeof inputTable === "object" || typeof inputTable === "Object" || typeof inputTable === "Array" || typeof inputTable === "array") {
       return true;
     } else {
       return false;
     }
   },
   checkAndUpdateNetworkPersistorProperties: function() {
     if (kony.logger.isNativeLoggerAvailable()) {
       var sessionURL = kony.sdk.util.getSessionURLfromAppConfig();
       if (!kony.sdk.isNullOrUndefined(sessionURL)) {
         var index = sessionURL.lastIndexOf("/");
         if (index != -1) {
           var networkURL = sessionURL.substring(0, index + 1);
           var networkPersistor = kony.logger.createNetworkPersistor();
           networkPersistor.URL = networkURL + kony.logger.networkPersistorUrlEndpoint;
           kony.logger.setPersistorConfig(networkPersistor);
         }
       }
     }
   },
   configure: function() {
     if (kony.logger.isNativeLoggerAvailable()) {
       kony.logger.checkAndUpdateNetworkPersistorProperties();
       KonyLogger.configure();
     }
   }
 };
 kony.sdk.FileStorageClasses = (function() {
   var mapOfInstanceToURL = {};
   var LOG_PREFIX = "kony.FileStorageAdapter";
   "use strict";

   function createInstance(url) {
     kony.sdk.logsdk.trace(LOG_PREFIX + ": Creating instance of FileStorageClasses");
     var obj = {};
     obj.listFiles = function(filter, headers, successCallback, failureCallback, options) {
       kony.sdk.logsdk.trace("Invoking list files");
       kony.sdk.claimsRefresh(function() {
         //claims refresh success callback
         kony.sdk.logsdk.info("listFiles : Refresh claims token SUCCESS");
         var headers = kony.sdk.FileStorageClasses.addTokenToHeaders(headers, kony.sdk.getCurrentInstance().currentClaimToken);
         //Calling FileStorage listFiles API.
         kony.sdk.FileStorageClasses.listFiles(url, filter, headers, successCallback, failureCallback, options);
       }.bind(this), function(error) {
         //claims refresh failure callback
         kony.sdk.logsdk.error("listFiles : Refresh claims token FAILED");
         failureCallback(error);
       });
     };
     obj.upload = function(uploadInputType, uploadParams, successCallback, failureCallback, options) {
       kony.sdk.logsdk.trace("Invoking upload");
       kony.sdk.claimsRefresh(function() {
         //claims refresh success callback
         kony.sdk.logsdk.info("upload : Refresh claims token SUCCESS");
         var headers = uploadParams["headers"];
         headers = kony.sdk.FileStorageClasses.addTokenToHeaders(headers, kony.sdk.getCurrentInstance().currentClaimToken);
         uploadParams["headers"] = headers;
         //Calling FileStorage upload API.
         kony.sdk.FileStorageClasses.upload(url, uploadInputType, uploadParams, successCallback, failureCallback, options);
       }.bind(this), function(error) {
         //claims refresh failure callback
         kony.sdk.logsdk.error("upload : Refresh claims token FAILED");
         failureCallback(error);
       });
     };
     obj.download = function(downloadParams, successCallback, failureCallback, options) {
       kony.sdk.logsdk.trace("Invoking downloadFile");
       kony.sdk.claimsRefresh(function() {
         //claims refresh success callback
         kony.sdk.logsdk.info("downloadFile : Refresh claims token SUCCESS");
         var headers = downloadParams["headers"];
         headers = kony.sdk.FileStorageClasses.addTokenToHeaders(headers, kony.sdk.getCurrentInstance().currentClaimToken);
         downloadParams["headers"] = headers;
         kony.sdk.FileStorageClasses.download(url, downloadParams, successCallback, failureCallback, options);
       }.bind(this), function(error) { //claims refresh failure callback
         kony.sdk.logsdk.error("upload : Refresh claims token FAILED");
         failureCallback(error);
       });
     };
     obj.deleteById = function(fileId, deleteParams, headers, successCallback, failureCallback, options) {
       kony.sdk.logsdk.trace("Invoking deleteById");
       kony.sdk.claimsRefresh(function() {
         //claims refresh success callback
         kony.sdk.logsdk.info("deleteById : Refresh claims token SUCCESS");
         var headers = kony.sdk.FileStorageClasses.addTokenToHeaders(headers, kony.sdk.getCurrentInstance().currentClaimToken);
         kony.sdk.FileStorageClasses.deleteById(url, fileId, deleteParams, headers, successCallback, failureCallback, options);
       }.bind(this), function(error) {
         //claims refresh failure callback
         kony.sdk.logsdk.error("deleteById : Refresh claims token FAILED");
         failureCallback(error);
       });
     };
     obj.deleteByCriteria = function(deleteParams, headers, successCallback, failureCallback, options) {
       kony.sdk.logsdk.trace("Invoking deleteByCriteria");
       kony.sdk.claimsRefresh(function() {
         //claims refresh success callback
         kony.sdk.logsdk.info("deleteByCriteria : Refresh claims token SUCCESS");
         var headers = kony.sdk.FileStorageClasses.addTokenToHeaders(headers, kony.sdk.getCurrentInstance().currentClaimToken);
         kony.sdk.FileStorageClasses.deleteByCriteria(url, deleteParams, headers, successCallback, failureCallback, options);
       }.bind(this), function(error) {
         //claims refresh failure callback
         kony.sdk.logsdk.error("deleteByCriteria : Refresh claims token FAILED");
         failureCallback(error);
       });
     };
     obj.update = function(updateParams, successCallback, failureCallback, options) {
       kony.sdk.logsdk.trace("Invoking update");
       kony.sdk.claimsRefresh(function() {
         //claims refresh success callback
         kony.sdk.logsdk.info("update : Refresh claims token SUCCESS");
         var headers = updateParams["headers"];
         headers = kony.sdk.FileStorageClasses.addTokenToHeaders(headers, kony.sdk.getCurrentInstance().currentClaimToken);
         updateParams["headers"] = headers;
         kony.sdk.FileStorageClasses.update(url, updateParams, successCallback, failureCallback, options);
       }.bind(this), function(error) {
         //claims refresh failure callback
         kony.sdk.logsdk.error("deleteByCriteria : Refresh claims token FAILED");
         failureCallback(error);
       });
     };
     obj.abort = function(fileId, abortParams, headers, successCallback, failureCallback, options) {
       kony.sdk.logsdk.trace("Invoking abort");
       kony.sdk.claimsRefresh(function() {
         //claims refresh success callback
         kony.sdk.logsdk.info("abort : Refresh claims token SUCCESS");
         var headers = kony.sdk.FileStorageClasses.addTokenToHeaders(headers, kony.sdk.getCurrentInstance().currentClaimToken);
         kony.sdk.FileStorageClasses.abort(url, fileId, abortParams, headers, successCallback, failureCallback, options);
       }.bind(this), function(error) {
         //claims refresh failure callback
         kony.sdk.logsdk.error("abort : Refresh claims token FAILED");
         failureCallback(error);
       });
     };
     return obj;
   }
   return {
     import: function(url) {
       kony.sdk.logsdk.trace(LOG_PREFIX + ": Importing native FileStorageClasses");
       var instance = mapOfInstanceToURL[url];
       if (instance === undefined) {
         instance = createInstance(url);
         mapOfInstanceToURL[url] = instance;
       }
       return instance;
     }
   };
 })();
 // Add token to headers
 kony.sdk.FileStorageClasses.addTokenToHeaders = function(headers, token) {
   if (kony.sdk.isNullOrUndefined(headers)) {
     headers = {};
   }
   headers["X-Kony-Authorization"] = token;
   return headers;
 };
 kony.sdk.KNYObj = function(name, objectServiceName, namespace) {
   var LOG_PREFIX = "KNYObj";
   kony.sdk.logsdk.info(LOG_PREFIX + ": Creating KNYObj with name " + name);
   var sdkObjectSync = kony.sdk.KNYObj.createSDKObjectSync(name, objectServiceName, namespace);
   this.name = name;
   this.getSdkObjectSync = function() {
     return sdkObjectSync;
   }
   this.startSync = function(syncConfig, successCallback, failureCallback, progressCallback) {
     kony.sdk.logsdk.perf(LOG_PREFIX + ": Executing sync on " + this.name + " object");
     kony.sdk.logsdk.perf(LOG_PREFIX + ": Executing Refreshing claims token");
     kony.sdk.claimsRefresh(function() { //claims refresh success callback
       kony.sdk.logsdk.perf(LOG_PREFIX + ": Executing Finished Refresh claims token : status SUCCESS");
       var token = kony.sdk.getCurrentInstance().currentClaimToken;
       kony.sdk.OfflineObjects.setToken(token);
       kony.sdk.OfflineObjects.setReportingParams(kony.sdk.getReportingParamsForOfflineObjects());
       kony.sdk.KNYObj.startSync(this, syncConfig, successCallback, failureCallback, progressCallback)
     }.bind(this), function(error) { //claims refresh failure callback
       kony.sdk.logsdk.error(LOG_PREFIX + ": Executing Finished Refresh claims token : status FAILED");
       failureCallback(error);
     });
   };
   this.getPendingRecordsForUpload = function(options, successCallback, failureCallback) {
     kony.sdk.logsdk.perf(LOG_PREFIX + ": Executing Fetching PendingEditSyncRecords in " + this.name + " object");
     kony.sdk.KNYObj.getPendingRecordsForUpload(this, options, successCallback, failureCallback);
   };
   this.create = function(record, options, successCallback, failureCallback) {
     kony.sdk.logsdk.perf(LOG_PREFIX + ": Executing Create record in " + this.name + " object");
     kony.sdk.KNYObj.create(this, record, options, successCallback, failureCallback);
   };
   this.update = function(record, options, successCallback, failureCallback) {
     kony.sdk.logsdk.perf(LOG_PREFIX + ": Executing Update record in " + this.name + " object");
     kony.sdk.KNYObj.update(this, record, options, successCallback, failureCallback);
   };
   this.updateByPK = function(record, options, successCallback, failureCallback) {
     kony.sdk.logsdk.perf(LOG_PREFIX + ": Executing Update record by PK in " + this.name + " object");
     kony.sdk.KNYObj.updateByPK(this, record, options, successCallback, failureCallback);
   };
   this.delete = function(options, successCallback, failureCallback) {
     kony.sdk.logsdk.perf(LOG_PREFIX + ": Executing Delete record in " + this.name + " object");
     kony.sdk.KNYObj.delete(this, options, successCallback, failureCallback);
   };
   this.deleteByPK = function(options, successCallback, failureCallback) {
     kony.sdk.logsdk.perf(LOG_PREFIX + ": Executing Delete record by PK in " + this.name + " object");
     kony.sdk.KNYObj.deleteByPK(this, options, successCallback, failureCallback);
   };
   this.get = function(options, successCallback, failureCallback) {
     kony.sdk.logsdk.perf(LOG_PREFIX + ": Executing Get record from " + this.name + " object");
     kony.sdk.KNYObj.get(this, options, successCallback, failureCallback);
   };
   this.getBinary = function(options, fileDownloadStartedCallback, chunkDownloadCompletedCallback, streamDownloadCompletedCallback, fileDownloadCompletedCallback, downloadFailureCallback) {
     kony.sdk.logsdk.perf(LOG_PREFIX + ": Executing Get binary for " + this.name + " object");
     kony.sdk.KNYObj.getBinary(this, options, fileDownloadStartedCallback, chunkDownloadCompletedCallback, streamDownloadCompletedCallback, fileDownloadCompletedCallback, downloadFailureCallback);
   };
   this.getBinaryStatus = function(options, successCallback, failureCallback) {
     kony.sdk.logsdk.perf(LOG_PREFIX + ": Executing getBinaryStatus for " + this.name + " object");
     kony.sdk.KNYObj.getBinaryStatus(this, options, successCallback, failureCallback);
   };
   this.rollback = function(primaryKeyValueMap, successCallback, failureCallback) {
     kony.sdk.logsdk.perf(LOG_PREFIX + ": Executing Rollback for " + this.name + " object");
     kony.sdk.KNYObj.rollback(this, primaryKeyValueMap, successCallback, failureCallback);
   };
   this.markForUpload = function(options, successCallback, failureCallback) {
     kony.sdk.logsdk.perf(LOG_PREFIX + ": Executing MarkForUpload for " + this.name + " object");
     kony.sdk.KNYObj.markForUpload(this, options, successCallback, failureCallback);
   };
   this.getUploadDeferredRecordKeys = function(successCallback, failureCallback) {
     kony.sdk.logsdk.perf(LOG_PREFIX + ": Executing Get deferred record primary keys in " + this.name + " object");
     kony.sdk.KNYObj.getUploadDeferredRecordKeys(this, successCallback, failureCallback);
   };
   this.cancelSync = function(options, successCallback, failureCallback) {
     kony.sdk.logsdk.perf(LOG_PREFIX + ": Executing Cancel for " + this.name + " object");
     kony.sdk.KNYObj.cancelSync(this, options, successCallback, failureCallback);
   };
   this.clearOfflineData = function(options, successCallback, failureCallback) {
     kony.sdk.logsdk.perf(LOG_PREFIX + ": Executing clearOfflineData for " + this.name + " object");
     kony.sdk.KNYObj.clearOfflineData(this, options, successCallback, failureCallback);
   };
 };
 kony.sdk.KNYObjSvc = function(name) {
   var LOG_PREFIX = "KNYObjSvc";
   kony.sdk.logsdk.debug(LOG_PREFIX + ": Creating KNYObjSvc with name " + name);
   var sdkObjectServiceSync = kony.sdk.KNYObjSvc.createSDKObjectServiceSync(name);
   this.name = name;
   this.getSdkObjectServiceSync = function() {
     return sdkObjectServiceSync;
   }
   this.getSdkObjectByName = function(name) {
     kony.sdk.logsdk.perf(LOG_PREFIX + ": Executing Creating KNYObj with name " + name + " and objectServiceName " + this.name);
     var result = new kony.sdk.KNYObj(name, this.name);
     kony.sdk.logsdk.perf(LOG_PREFIX + ": Executing finished for creation of KNYObj with name " + name + " and objectServiceName " + this.name);
     return result;
   }
   this.startSync = function(syncConfig, successCallback, failureCallback, progressCallback) {
     kony.sdk.logsdk.perf(LOG_PREFIX + ": Executing Starting sync on " + this.name + " object service");
     kony.sdk.logsdk.perf(LOG_PREFIX + ": Executing Refreshing claims token");
     kony.sdk.claimsRefresh(function() { //claims refresh success callback
       kony.sdk.logsdk.perf(LOG_PREFIX + ": Executing Finished Refresh claims token : status SUCCESS");
       var token = kony.sdk.getCurrentInstance().currentClaimToken;
       kony.sdk.OfflineObjects.setToken(token);
       kony.sdk.OfflineObjects.setReportingParams(kony.sdk.getReportingParamsForOfflineObjects());
       kony.sdk.KNYObjSvc.startSync(this, syncConfig, successCallback, failureCallback, progressCallback)
     }.bind(this), function(error) { //claims refresh failure callback
       kony.sdk.logsdk.error(LOG_PREFIX + ": Executing Finished Refresh claims token : status FAILED");
       failureCallback(error);
     });
   };
   this.rollback = function(successCallback, failureCallback) {
     kony.sdk.logsdk.perf(LOG_PREFIX + ": Executing Rollback on " + this.name + " object service");
     kony.sdk.KNYObjSvc.rollback(this, successCallback, failureCallback)
   }
   this.cancelSync = function(options, successCallback, failureCallback) {
     kony.sdk.logsdk.perf(LOG_PREFIX + ": Executing Cancel for " + this.name + " object service");
     kony.sdk.KNYObjSvc.cancelSync(this, options, successCallback, failureCallback);
   }
   this.clearOfflineData = function(options, successCallback, failureCallback) {
     kony.sdk.logsdk.perf(LOG_PREFIX + ": Executing Clearing Offline Data for " + this.name + " object service.");
     kony.sdk.KNYObjSvc.clearOfflineData(this, options, successCallback, failureCallback);
   }
 };
 kony.sdk.OfflineObjects = function(objServiceList) {
   var LOG_PREFIX = "OfflineObjects";
   kony.sdk.logsdk.trace(LOG_PREFIX + ": Creating OfflineObjects");
   this.setup = function(options, successCallback, failureCallback) {
     kony.sdk.logsdk.perf(LOG_PREFIX + ": Executing OfflineObjects.setup()");
     kony.sdk.logsdk.perf(LOG_PREFIX + ": Executing Refreshing claims token");
     kony.sdk.claimsRefresh(function() { //claims refresh success callback
       kony.sdk.logsdk.perf(LOG_PREFIX + ": Executing Finished Refresh claims token : status SUCCESS");
       var token = kony.sdk.getCurrentInstance().currentClaimToken;
       //kony.sdk.logsdk.debug(LOG_PREFIX+": Token : "+token);
       kony.sdk.OfflineObjects.setToken(token);
       kony.sdk.OfflineObjects.setReportingParams(kony.sdk.getReportingParamsForOfflineObjects());
       kony.sdk.OfflineObjects.setup(objServiceList, options, successCallback, failureCallback);
     }, function() { //claims refresh failure callback
       kony.sdk.logsdk.error(LOG_PREFIX + ": Executing Finished Refresh claims token : status FAILED. Setup offline started.");
       kony.sdk.OfflineObjects.setup(objServiceList, options, successCallback, failureCallback);
     });
   };
   this.incrementalSetup = function(options, successCallback, failureCallback) {
     kony.sdk.logsdk.perf(LOG_PREFIX + ": Executing OfflineObjects incrementalSetup");
     if (!options) {
       options = {};
     }
     options.incrementalSetup = true;
     this.setup(options, successCallback, failureCallback);
   }
   this.drop = function(options, successCallback, failureCallback) {
     kony.sdk.logsdk.perf(LOG_PREFIX + ": Executing OfflineObjects.drop()");
     kony.sdk.OfflineObjects.drop(options, successCallback, failureCallback);
   }
   this.reset = function(options, successCallback, failureCallback) {
     kony.sdk.logsdk.perf(LOG_PREFIX + ": Executing OfflineObjects.reset");
     kony.sdk.logsdk.perf(LOG_PREFIX + ": Executing Refresh claims token");
     kony.sdk.claimsRefresh(function() { //claims refresh success callback
       kony.sdk.logsdk.perf(LOG_PREFIX + ": Executing Finished Refresh claims token : status SUCCESS");
       var token = kony.sdk.getCurrentInstance().currentClaimToken;
       //kony.sdk.logsdk.debug(LOG_PREFIX+": Token : "+token);
       kony.sdk.OfflineObjects.setToken(token);
       kony.sdk.OfflineObjects.setReportingParams(kony.sdk.getReportingParamsForOfflineObjects());
       kony.sdk.OfflineObjects.reset(objServiceList, options, successCallback, failureCallback);
     }, function(error) { //claims refresh failure callback
       kony.sdk.logsdk.error(LOG_PREFIX + ": Executing Finished Refresh claims token : status FAILED");
       failureCallback(error);
     });
   }
   this.rollback = function(successCallback, failureCallback) {
     kony.sdk.logsdk.perf(LOG_PREFIX + ": Executing OfflineObjects.rollback()");
     kony.sdk.OfflineObjects.rollback(successCallback, failureCallback);
   }
   this.executeSelectQuery = function(query, successCallback, failureCallback) {
     kony.sdk.logsdk.perf(LOG_PREFIX + ": Executing OfflineObjects.executeSelectQuery()");
     kony.sdk.OfflineObjects.executeSelectQuery(query, successCallback, failureCallback);
   }
   this.startSync = function(options, successCallback, failureCallback, progressCallback) {
     kony.sdk.logsdk.perf(LOG_PREFIX + ": Executing OfflineObjects.startSync");
     kony.sdk.logsdk.perf(LOG_PREFIX + ": Executing Refresh claims");
     kony.sdk.claimsRefresh(function() { //claims refresh success callback
       kony.sdk.logsdk.perf(LOG_PREFIX + ": Executing Finished Refresh claims token : status SUCCESS");
       var token = kony.sdk.getCurrentInstance().currentClaimToken;
       kony.sdk.OfflineObjects.setToken(token);
       kony.sdk.OfflineObjects.setReportingParams(kony.sdk.getReportingParamsForOfflineObjects());
       kony.sdk.OfflineObjects.startSync(options, successCallback, failureCallback, progressCallback);
     }, function(error) { //claims refresh failure callback
       kony.sdk.logsdk.error(LOG_PREFIX + "Executing Finished Application Sync : Refresh claims token : status FAILED");
       failureCallback(error);
     });
   }
 };
 kony.sdk.OfflineObjects.BinaryStatus = {
   "pending": 2,
   "completed": 4,
   "errored": 8
 }
 //
 //Binary FFI related functions
 //
 if (kony.sdk) {
   kony.sdk.binary = {};
 }
 kony.sdk.binary.constants = {
   ENDPOINT_URL: "endpointUrl",
   DOMAIN: "domain",
   RELATIVE_PATH: "relativepath",
   URL: "URL",
   HEADERS: "headers",
   METHOD: "method",
   UPLOAD_MODE: "uploadMode",
   BLOB: "blob",
   FILE_CONTENT: "${fileContent}",
   FILE: "file",
   HTTP_STATUS_CODE: "httpStatusCode",
   VALID_HTTP_REDIRECT_CODE: "309",
   UPLOAD_MODE_BINARY: "binary",
   UPLOAD_MODE_MULTIPART: "multipart",
   UPLOAD_PARAMS: "uploadParams",
   BLOB_ID: "BlobID",
   CONTEXT: "Context",
   SESSION_ID: "SessionID",
   BLOB_OBJECT: "BlobObject",
   ERROR: "Error",
   FILE_DETAILS: "FileDetails",
   HTTP_METHOD_PUT: "PUT",
   HTTP_METHOD_POST: "POST"
 };
 kony.sdk.binary.addMandatoryInternalOptions = function(options) {
   if (kony.sdk.isNullOrUndefined(options)) {
     options = {};
   }
   options[kony.sdk.binary.constants.DOMAIN] = konyRef.sessionReportingURL.split("/IST")[0];
   if (!kony.sdk.isNullOrUndefined(konyRef.currentClaimToken)) {
     options[kony.sdk.constants.KONY_AUTHORIZATION_HEADER] = konyRef.currentClaimToken;
   }
   return options;
 };
 kony.sdk.binary.validateUploadParams = function(uploadParams) {
   //Validating user input.
   if (!kony.sdk.util.isJsonObject(uploadParams)) {
     kony.sdk.logsdk.error("### kony.sdk.binary.validateUploadParams :: Error: Upload params should be supplied as valid JSON object");
     return kony.sdk.error.getClientErrObj(kony.sdk.errorcodes.invalid_params_instance, "Invalid datatype of uploadParams " + kony.sdk.util.type(uploadParams) + " " + kony.sdk.errormessages.invalid_params_instance)
   }
   // check for fileName
   if (!kony.sdk.util.isValidString(uploadParams[kony.sdk.constants.FILE_NAME])) {
     kony.sdk.logsdk.error("### kony.sdk.binary.validateUploadParams :: Error: fileName : expected string not found");
     return kony.sdk.error.getClientErrObj(kony.sdk.errorcodes.invalid_params_instance, "" + "Invalid datatype of fileName " + kony.sdk.util.type(uploadParams[kony.sdk.constants.FILE_NAME]) + " " + kony.sdk.errormessages.invalid_params_instance);
   }
   // Check if fileObject is provided by user
   if (kony.sdk.isNullOrUndefined(uploadParams[kony.sdk.constants.FILE_OBJECT])) {
     kony.sdk.logsdk.error("### kony.sdk.binary.validateUploadParams :: Error: fileObject is not provided - please provide");
     return kony.sdk.error.getClientErrObj(kony.sdk.errorcodes.invalid_params_instance, "fileObject is not provided " + kony.sdk.errormessages.invalid_params_instance);
   }
   // check if the fileObject provided by user is browser file object
   if (uploadParams[kony.sdk.constants.FILE_OBJECT].constructor !== File) {
     kony.sdk.logsdk.error("### kony.sdk.binary.validateUploadParams :: Error: fileObject : expected File Object and found " + kony.sdk.util.type(uploadParams[kony.sdk.constants.FILE_OBJECT]));
     return kony.sdk.error.getClientErrObj(kony.sdk.errorcodes.invalid_params_instance, "Invalid datatype of fileObject " + kony.sdk.util.type(uploadParams[kony.sdk.constants.FILE_OBJECT]) + " " + kony.sdk.errormessages.invalid_params_instance);
   }
   return null;
 };
 kony.sdk.binary.getRequestParamsFromTemplate = function(template, templateParams, options) {
   var requestParamsForBinaryCall = {};
   var parsedTemplateData = kony.sdk.util.populateTemplate(JSON.stringify(template), templateParams);
   var parsedTemplate = JSON.parse(parsedTemplateData[kony.sdk.constants.PROCESSED_TEMPLATE]);
   requestParamsForBinaryCall[kony.sdk.constants.PROCESSED_TEMPLATE] = parsedTemplateData[kony.sdk.constants.PROCESSED_TEMPLATE];
   // TODO: Validate missing variables
   requestParamsForBinaryCall[kony.sdk.constants.MISSING_VARIABLES] = parsedTemplateData[kony.sdk.constants.MISSING_VARIABLES];
   var additionalParams = kony.sdk.binary.addMandatoryInternalOptions(options);
   //Fetching headers from template
   var headers = {};
   if (parsedTemplate.hasOwnProperty(kony.sdk.binary.constants.HEADERS) && kony.sdk.util.isJsonObject(parsedTemplate[kony.sdk.binary.constants.HEADERS]) && Object.keys(parsedTemplate[kony.sdk.binary.constants.HEADERS] > 0)) {
     headers = parsedTemplate[kony.sdk.binary.constants.HEADERS];
   }
   //Parsing the Backend Url from template
   var url = "";
   if (parsedTemplate.hasOwnProperty(kony.sdk.binary.constants.ENDPOINT_URL)) {
     url = parsedTemplate[kony.sdk.binary.constants.ENDPOINT_URL];
   } else if (parsedTemplate.hasOwnProperty(kony.sdk.binary.constants.DOMAIN) && parsedTemplate.hasOwnProperty(kony.sdk.binary.constants.RELATIVE_PATH)) {
     var domain = "";
     if (parsedTemplate[kony.sdk.binary.constants.DOMAIN] === "#middlewaredomain") {
       headers[kony.sdk.constants.KONY_AUTHORIZATION_HEADER] = additionalParams[kony.sdk.constants.KONY_AUTHORIZATION_HEADER];
       domain = additionalParams[kony.sdk.binary.constants.DOMAIN];
     } else {
       domain = parsedTemplate[kony.sdk.binary.constants.DOMAIN];
     }
     url = domain + parsedTemplate[kony.sdk.binary.constants.RELATIVE_PATH];
   }
   requestParamsForBinaryCall[kony.sdk.binary.constants.URL] = url;
   requestParamsForBinaryCall[kony.sdk.binary.constants.METHOD] = parsedTemplate[kony.sdk.binary.constants.METHOD];
   requestParamsForBinaryCall[kony.sdk.binary.constants.HEADERS] = headers;
   return requestParamsForBinaryCall;
 };
 kony.sdk.binary.getBinaryData = function(inputParams, streaming, downloadConfig, fileDownloadStartedCallback, chunkDownloadCompletedCallback, fileDownloadCompletedCallback, fileDownloadFailureCallback, options) {
   if (kony.sdk.isNullOrUndefined(downloadConfig[kony.sdk.binary.constants.ENDPOINT_URL]) && kony.sdk.isNullOrUndefined(downloadConfig[kony.sdk.binary.constants.DOMAIN]) && kony.sdk.isNullOrUndefined(downloadConfig[kony.sdk.binary.constants.RELATIVE_PATH])) {
     kony.sdk.verifyAndCallClosure(fileDownloadFailureCallback, "endpointUrl or domain and relative path is required in order to download a file");
     return;
   }
   var fileId = new Date().getTime().toString();
   kony.sdk.verifyAndCallClosure(fileDownloadStartedCallback, {
     "BlobID": fileId,
     "Context": inputParams
   });
   var requestParams = kony.sdk.binary.getRequestParamsFromTemplate(downloadConfig, inputParams, options);
   var parsedTemplate = JSON.parse(requestParams[kony.sdk.constants.PROCESSED_TEMPLATE]);
   if (parsedTemplate[kony.sdk.binary.constants.HTTP_STATUS_CODE] == kony.sdk.binary.constants.VALID_HTTP_REDIRECT_CODE) {
     if (kony.sdk.isNullOrUndefined(options)) {
       options = {};
     }
     options[kony.sdk.constants.IGNORE_MESSAGE_INTEGRITY] = true;
     var networkProvider = new konyNetworkProvider();
     networkProvider.get(requestParams[kony.sdk.binary.constants.URL], null, requestParams[kony.sdk.binary.constants.HEADERS], function(blobObject) {
       var successObject = {};
       if (kony.sdk.isNullOrUndefined(inputParams["fileId"])) {
         successObject[kony.sdk.binary.constants.BLOB_ID] = fileId;
       } else {
         successObject[kony.sdk.binary.constants.BLOB_ID] = inputParams["fileId"];
       }
       successObject[kony.sdk.binary.constants.BLOB_OBJECT] = blobObject;
       successObject[kony.sdk.binary.constants.CONTEXT] = inputParams;
       kony.sdk.verifyAndCallClosure(fileDownloadCompletedCallback, successObject);
     }, function(networkError) {
       var errorObject = {};
       if (kony.sdk.isNullOrUndefined(inputParams["fileId"])) {
         errorObject[kony.sdk.binary.constants.BLOB_ID] = fileId;
       } else {
         errorObject[kony.sdk.binary.constants.BLOB_ID] = inputParams["fileId"];
       }
       errorObject[kony.sdk.binary.constants.CONTEXT] = inputParams;
       errorObject[kony.sdk.binary.constants.ERROR] = networkError;
       kony.sdk.verifyAndCallClosure(fileDownloadFailureCallback, errorObject);
     }, null, options);
   } else {
     //TODO: Handle http status which is not 309
     kony.sdk.verifyAndCallClosure(fileDownloadFailureCallback, "Unhandled httpStatusCode received: " + parsedTemplate[kony.sdk.binary.constants.HTTP_STATUS_CODE]);
   }
 };
 kony.sdk.binary.uploadBinaryData = function(uploadParams, fileUploadStartedCallback, chunkUploadCompletedCallback, fileUploadCompletedCallback, fileUploadFailureCallback, options) {
   function templateFetchSuccess(uploadConfig) {
     if (kony.sdk.isNullOrUndefined(uploadConfig[kony.sdk.binary.constants.ENDPOINT_URL]) && kony.sdk.isNullOrUndefined(uploadConfig[kony.sdk.binary.constants.DOMAIN]) && kony.sdk.isNullOrUndefined(uploadConfig[kony.sdk.binary.constants.RELATIVE_PATH])) {
       kony.sdk.verifyAndCallClosure(fileUploadFailureCallback, "endpointUrl or domain and relative path is required in order to upload a file");
       return;
     }
     var sessionId = new Date().getTime().toString();
     kony.sdk.verifyAndCallClosure(fileUploadStartedCallback, {
       "SessionID": sessionId,
       "Context": uploadParams[kony.sdk.binary.constants.UPLOAD_PARAMS]
     });
     var requestParams = kony.sdk.binary.getRequestParamsFromTemplate(uploadConfig, uploadParams[kony.sdk.binary.constants.UPLOAD_PARAMS], options);
     var parsedTemplate = JSON.parse(requestParams[kony.sdk.constants.PROCESSED_TEMPLATE]);
     if (parsedTemplate[kony.sdk.binary.constants.HTTP_STATUS_CODE] == kony.sdk.binary.constants.VALID_HTTP_REDIRECT_CODE) {
       var requestBody;
       var fileObject;
       var requestBodyTemplateVariable = kony.sdk.util.getValueForKeyAndIgnoreCase(parsedTemplate, "requestBody");
       if (parsedTemplate[kony.sdk.binary.constants.UPLOAD_MODE].toLowerCase() === kony.sdk.binary.constants.UPLOAD_MODE_BINARY) {
         if (requestBodyTemplateVariable === kony.sdk.binary.constants.FILE_CONTENT) {
           requestBody = uploadParams[kony.sdk.constants.FILE_OBJECT];
         } else if (kony.sdk.isValidString(requestBodyTemplateVariable) && requestBodyTemplateVariable.indexOf(kony.sdk.binary.constants.FILE_CONTENT) !== -1) {
           //TODO - handling substituting fileContent in the template variable
           kony.sdk.verifyAndCallClosure(fileUploadFailureCallback, "Received request body structure is not supported");
         } else {
           kony.sdk.verifyAndCallClosure(fileUploadFailureCallback, "Unhandled request body format received");
         }
       } else if (parsedTemplate[kony.sdk.binary.constants.UPLOAD_MODE].toLowerCase() === kony.sdk.binary.constants.UPLOAD_MODE_MULTIPART) {
         var formData = new kony.net.FormData({
           isMultiPart: true
         });
         for (var key in requestBodyTemplateVariable) {
           if (requestBodyTemplateVariable.hasOwnProperty(key) && kony.sdk.util.isJsonObject(requestBodyTemplateVariable)) {
             if (requestBodyTemplateVariable[key] === kony.sdk.binary.constants.FILE_CONTENT) {
               fileObject = uploadParams[kony.sdk.constants.FILE_OBJECT];
             } else if (kony.sdk.util.isJsonObject(requestBodyTemplateVariable[key])) {
               formData.append(key, JSON.stringify(requestBodyTemplateVariable[key]));
             } else {
               kony.sdk.verifyAndCallClosure(fileUploadFailureCallback, "Unhandled request body format received");
             }
           }
         }
         formData.append(kony.sdk.binary.constants.FILE, fileObject);
         requestBody = formData;
       }
       if (kony.sdk.isNullOrUndefined(options)) {
         options = {};
       }
       options[kony.sdk.constants.IGNORE_MESSAGE_INTEGRITY] = true;
       var networkProvider = new konyNetworkProvider();
       if (requestParams[kony.sdk.binary.constants.METHOD].toLocaleUpperCase() === kony.sdk.binary.constants.HTTP_METHOD_POST) {
         networkProvider.post(requestParams[kony.sdk.binary.constants.URL], requestBody, requestParams[kony.sdk.binary.constants.HEADERS], function(networkResponse) {
           var successObject = {};
           successObject[kony.sdk.binary.constants.SESSION_ID] = sessionId;
           successObject[kony.sdk.binary.constants.CONTEXT] = uploadParams[kony.sdk.binary.constants.UPLOAD_PARAMS];
           successObject[kony.sdk.binary.constants.FILE_DETAILS] = networkResponse;
           kony.sdk.verifyAndCallClosure(fileUploadCompletedCallback, successObject);
         }, function(networkError) {
           var errorObject = {};
           errorObject[kony.sdk.binary.constants.SESSION_ID] = sessionId;
           errorObject[kony.sdk.binary.constants.CONTEXT] = uploadParams[kony.sdk.binary.constants.UPLOAD_PARAMS];
           errorObject[kony.sdk.binary.constants.ERROR] = networkError;
           kony.sdk.verifyAndCallClosure(fileUploadFailureCallback, errorObject);
         }, parsedTemplate[kony.sdk.binary.constants.UPLOAD_MODE].toLowerCase(), options);
       }
     } else {
       //TODO: Handle http status which is not 309
       kony.sdk.verifyAndCallClosure(fileUploadFailureCallback, "Unhandled httpStatusCode received: " + parsedTemplate[kony.sdk.binary.constants.HTTP_STATUS_CODE]);
     }
   }
   //Invoking the template call
   var networkProvider = new konyNetworkProvider();
   networkProvider.post(uploadParams[kony.sdk.binary.constants.URL], uploadParams[kony.sdk.binary.constants.UPLOAD_PARAMS], uploadParams[kony.sdk.binary.constants.HEADERS], templateFetchSuccess, fileUploadFailureCallback, null, options);
 };
 if (typeof(kony.sdk.metric) === "undefined") {
   kony.sdk.metric = {};
 }
 kony.sdk.metric.eventFlowTag = "";
 kony.sdk.metric.eventConfig = {
   "confType": "BUFFER",
   "eventBufferAutoFlushCount": kony.sdk.metric.eventBufferAutoFlushValue,
   "eventBufferMaxCount": kony.sdk.metric.eventBufferMaxValue
 };
 kony.sdk.metric.eventBufferMaxValue = 1000;
 kony.sdk.metric.eventBufferAutoFlushValue = 15;
 kony.sdk.metric.characterLengthLimit = 256;
 kony.sdk.metric.reportEventBufferArray = [];
 kony.sdk.metric.reportEventBufferBackupArray = [];
 kony.sdk.metric.retrievedDS = false;
 kony.sdk.metric.eventBufferCount = 0;
 kony.sdk.metric.eventTypeMap = {
   "formentry": "FormEntry",
   "touch": "Touch",
   "servicecall": "ServiceCall",
   "gesture": "Gesture",
   "orientation": "Orientation",
   "custom": "Custom"
 };
 kony.sdk.metric.errorCodeMap = {
   "1000": true,
   "1011": true,
   "1012": true,
   "1014": true,
   "1015": true,
   "1016": true
 };
 kony.sdk.metric.setEventFlowTag = function(flowTag) {
   if (kony.sdk.isNullOrUndefined(flowTag)) {
     throw new Exception(kony.sdk.errorConstants.METRICS_FAILURE, "Invalid value for event flow tag");
   } else if (flowTag.length <= kony.sdk.metric.characterLengthLimit) {
     kony.sdk.metric.eventFlowTag = flowTag;
   } else {
     throw new Exception(kony.sdk.errorConstants.METRICS_FAILURE, "Length exceeded, Maximum length of event flow tag is " + kony.sdk.metric.characterLengthLimit + " characters");
   }
 };
 kony.sdk.metric.clearEventFlowTag = function() {
   kony.sdk.metric.eventFlowTag = "";
 };
 kony.sdk.metric.getEventFlowTag = function() {
   return kony.sdk.metric.eventFlowTag;
 };
 kony.sdk.metric.setEventConfig = function(confType, eventBufferAutoFlushCount, eventBufferMaxCount) {
   if (kony.sdk.isNullOrUndefined(confType)) {
     throw new Exception(kony.sdk.errorConstants.METRICS_FAILURE, "Config Type can not be null");
   } else {
     confType = confType.toUpperCase();
   }
   if (confType === "BUFFER") {
     kony.sdk.metric.eventConfig["confType"] = confType;
   } else {
     throw new Exception(kony.sdk.errorConstants.METRICS_FAILURE, "Invalid value for config type");
   }
   if (!kony.sdk.isNullOrUndefined(eventBufferMaxCount) && typeof(eventBufferMaxCount) === "number" && eventBufferMaxCount > 0) {
     kony.sdk.metric.eventConfig["eventBufferMaxCount"] = eventBufferMaxCount;
   } else {
     throw new Exception(kony.sdk.errorConstants.METRICS_FAILURE, "eventBufferMaxCount has to be a Number and greater than 0");
   }
   if (!kony.sdk.isNullOrUndefined(eventBufferAutoFlushCount) && typeof(eventBufferAutoFlushCount) === "number" && eventBufferAutoFlushCount > 0 && eventBufferAutoFlushCount <= eventBufferMaxCount) {
     kony.sdk.metric.eventConfig["eventBufferAutoFlushCount"] = eventBufferAutoFlushCount;
   } else if (eventBufferAutoFlushCount >= eventBufferMaxCount) {
     kony.sdk.metric.eventConfig["eventBufferMaxCount"] = 1000;
     throw new Exception(kony.sdk.errorConstants.METRICS_FAILURE, "eventBufferAutoFlushCount can not be greater than eventBufferMaxCount");
   } else {
     throw new Exception(kony.sdk.errorConstants.METRICS_FAILURE, "eventBufferAutoFlushCount has to be a Number and greater than 0");
   }
 };
 kony.sdk.metric.reportEvent = function(evttype, evtSubType, formID, widgetID, flowTag) {
   if (kony.sdk.metric.reportEventBufferBackupArray.length === 0) {
     kony.sdk.metric.readFromDS();
   }
   kony.sdk.metric.eventBufferCount = kony.sdk.metric.reportEventBufferBackupArray.length + kony.sdk.metric.reportEventBufferArray.length;
   if (kony.sdk.metric.eventBufferCount === kony.sdk.metric.eventConfig["eventBufferMaxCount"]) {
     throw new Exception(kony.sdk.errorConstants.DATA_STORE_EXCEPTION, "Reached maximum limit to store events");
     return;
   }
   var reportEventMap = {};
   reportEventMap.ts = kony.sdk.formatCurrentDate(new Date());
   evttype = evttype.toLowerCase();
   if (kony.sdk.isNullOrUndefined(kony.sdk.metric.eventTypeMap[evttype])) {
     throw new Exception(kony.sdk.errorConstants.METRICS_FAILURE, "Invalid value for event type");
     return;
   } else {
     reportEventMap["evttype"] = kony.sdk.metric.eventTypeMap[evttype];
   }
   if (kony.sdk.isNullOrUndefined(evtSubType)) {
     reportEventMap["evtSubType"] = "";
   } else if (evtSubType.length <= kony.sdk.metric.characterLengthLimit) {
     reportEventMap["evtSubType"] = evtSubType;
   } else {
     throw new Exception(kony.sdk.errorConstants.METRICS_FAILURE, "Length exceeded, Maximum length of event flow tag is " + kony.sdk.metric.characterLengthLimit + " characters");
     return;
   }
   if (kony.sdk.isNullOrUndefined(formID)) {
     reportEventMap["formID"] = kony.application.getCurrentForm().id;
   } else if (formID.length <= kony.sdk.metric.characterLengthLimit) {
     reportEventMap["formID"] = formID;
   } else {
     throw new Exception(kony.sdk.errorConstants.METRICS_FAILURE, "Length exceeded, Maximum length of event flow tag is " + kony.sdk.metric.characterLengthLimit + " characters");
     return;
   }
   if (kony.sdk.isNullOrUndefined(widgetID)) {
     reportEventMap["widgetID"] = "";
   } else if (widgetID.length <= kony.sdk.metric.characterLengthLimit) {
     reportEventMap["widgetID"] = widgetID;
   } else {
     throw new Exception(kony.sdk.errorConstants.METRICS_FAILURE, "Length exceeded, Maximum length of event flow tag is " + kony.sdk.metric.characterLengthLimit + " characters");
     return;
   }
   if (kony.sdk.isNullOrUndefined(flowTag)) {
     reportEventMap["flowTag"] = kony.sdk.metric.getEventFlowTag();
   } else if (flowTag.length <= kony.sdk.metric.characterLengthLimit) {
     reportEventMap["flowTag"] = flowTag;
   } else {
     throw new Exception(kony.sdk.errorConstants.METRICS_FAILURE, "Length exceeded, Maximum length of event flow tag is " + kony.sdk.metric.characterLengthLimit + " characters");
     return;
   }
   reportEventMap.SID = kony.ds.read(kony.sdk.constants.KONYUUID)[0];
   kony.sdk.metric.reportEventBufferArray.push(reportEventMap);
   if (kony.sdk.metric.reportEventBufferArray.length % kony.sdk.metric.eventConfig["eventBufferAutoFlushCount"] === 0) {
     kony.sdk.metric.flushEvents();
   }
 };
 kony.sdk.metric.flushEvents = function() {
   if (kony.sdk.metric.reportEventBufferBackupArray.length === 0) {
     kony.sdk.metric.readFromDS();
   }
   if (kony.sdk.metric.reportEventBufferBackupArray.length === 0 && kony.sdk.metric.reportEventBufferArray.length === 0) {
     kony.sdk.logsdk.warn("There are no events to flush");
     return;
   }
   var payload = kony.sdk.getPayload(kony.sdk.getCurrentInstance());
   var params = {};
   if (kony.sdk.metric.reportEventBufferArray.length !== 0) {
     kony.sdk.metric.pushEventsToBufferArray();
   }
   var headers = {};
   headers[kony.sdk.constants.HTTP_CONTENT_HEADER] = kony.sdk.constants.CONTENT_TYPE_FORM_URL_ENCODED;
   params.httpheaders = headers;
   payload.events = kony.sdk.metric.reportEventBufferBackupArray;
   payload.svcid = "SendEvents";
   payload.rsid = kony.sdk.metric.reportEventBufferBackupArray[0].SID;
   params[kony.sdk.constants.REPORTING_PARAMS] = JSON.stringify(payload);
   kony.net.invokeServiceAsync(kony.sdk.currentInstance.customReportingURL, params, flushCallback);

   function flushCallback(status, response) {
     if (status === 400) {
       if (response.opstatus == 0) {
         kony.sdk.metric.clearBufferEvents();
       } else if (kony.sdk.metric.errorCodeMap[response.opstatus]) {
         kony.sdk.metric.saveInDS();
       } else {
         kony.sdk.metric.clearBufferEvents();
       }
     } else if (status === 300) {
       kony.sdk.metric.saveInDS();
     }
   }
 };
 /*Stores event data in Data Store on failure of service Call*/
 kony.sdk.metric.saveInDS = function() {
   if (!kony.sdk.isNullOrUndefined(kony.sdk.metric.reportEventBufferBackupArray) && kony.sdk.metric.reportEventBufferBackupArray.length > 0) {
     var eventsToSave = [];
     eventsToSave.push(JSON.stringify(kony.sdk.metric.reportEventBufferBackupArray));
     kony.ds.save(eventsToSave, "konyMetricsBuffer");
     kony.sdk.metric.reportEventBufferBackupArray = [];
   }
 };
 /*Clearing events sent to server */
 kony.sdk.metric.clearBufferEvents = function() {
   kony.sdk.metric.reportEventBufferBackupArray = [];
   kony.ds.remove("konyMetricsBuffer");
 };
 /*Reading any pending events from Data Store */
 kony.sdk.metric.readFromDS = function() {
   var eventsFromDS = kony.ds.read("konyMetricsBuffer");
   if (eventsFromDS !== null) {
     var pushToArray = [];
     pushToArray.push(JSON.parse(eventsFromDS[0]));
     kony.sdk.metric.reportEventBufferBackupArray.push.apply(kony.sdk.metric.reportEventBufferBackupArray, pushToArray);
   }
 };
 /*Pushes events received from user to BufferBackupArray which will be flushed to server */
 kony.sdk.metric.pushEventsToBufferArray = function() {
   kony.sdk.metric.reportEventBufferBackupArray.push.apply(kony.sdk.metric.reportEventBufferBackupArray, kony.sdk.metric.reportEventBufferArray);
   kony.sdk.metric.reportEventBufferArray = [];
 };
 kony.sdk.metric.getEventsInBuffer = function() {
   var eventsFromDS = kony.ds.read("konyMetricsBuffer");
   var eventsToReturn = [];
   if (!kony.sdk.isNullOrUndefined(eventsFromDS)) {
     eventsToReturn.push(JSON.parse(eventsFromDS[0]));
   }
   if (kony.sdk.metric.reportEventBufferArray.length !== 0) {
     eventsToReturn.push.apply(eventsToReturn, kony.sdk.metric.reportEventBufferArray);
   }
   if (eventsToReturn.length !== 0) {
     return eventsToReturn;
   } else {
     return null;
   }
 };
 kony.logger = kony.logger || {};
 kony.logger.createNewLogger = function(loggerName, loggerConfig) {
   parseConfig = function(loggerConfig) {
     //private methods
     if (loggerConfig === null || typeof(loggerConfig) === 'undefined') {
       loggerConfig = {};
     } else {
       loggerConfig = loggerConfig.getLoggerConfig();
     }
     if (typeof(appConfig) != 'undefined') {
       appDetails = {
         appID: appConfig.appId,
         appVersion: appConfig.appVersion,
         sessionID: kony.license.getSessionId()
       };
       //appInfo
       loggerConfig.appInfo = appDetails;
       if (kony.sdk.isNullOrUndefined(loggerConfig.logFilterConfig)) {
         loggerConfig.logFilterConfig = {};
         loggerConfig.logFilterConfig.logLevel = kony.logger.currentLogLevel.value;
       }
     }
     return loggerConfig;
   };
   logMessage = function(loggerObj, logLevel, msg, params) {
     logMessageInFFI = function(NativeLoggerObject, logLevel, message) {
       switch (logLevel) {
         case kony.logger.logLevel.TRACE:
           NativeLoggerObject.logTrace(message);
           break;
         case kony.logger.logLevel.DEBUG:
           NativeLoggerObject.logDebug(message);
           break;
         case kony.logger.logLevel.INFO:
           NativeLoggerObject.logInfo(message);
           break;
         case kony.logger.logLevel.PERF:
           NativeLoggerObject.logPerf(message);
           break;
         case kony.logger.logLevel.WARN:
           NativeLoggerObject.logWarning(message);
           break;
         case kony.logger.logLevel.ERROR:
           NativeLoggerObject.logError(message);
           break;
         case kony.logger.logLevel.FATAL:
           NativeLoggerObject.logFatal(message);
           break;
         default:
           kony.print("Implementation not found for the specified log level " + logLevel);
           return;
       }
     };
     formatLineInfo = function(callerInformation) {
       /*
         sample callerInformation's value can look like -> "http://kh2321.kitspl.com:8443/apps/IDETestDriver8/1570111366904/desktopweb/appjs/app.js:40569:23" or "Module.js:40569:23"
         value associated with last colon is column number
         value associated with second last colon is line number
       */
       var lineInfo = "";
       var firstLastIndexOfColon = callerInformation.lastIndexOf(':');
       var secondLastIndexOfColon = callerInformation.lastIndexOf(':', firstLastIndexOfColon - 1);
       lineInfo = callerInformation.substring(secondLastIndexOfColon + 1, firstLastIndexOfColon);
       return lineInfo;
     };
     formatFileAndLineInfoMeta = function(callerInformation) {
       //callerInformation's value can look like -> "(http://kh2321.kitspl.com:8443/apps/IDETestDriver8/1570111366904/desktopweb/appjs/app.js:40569:23)" or "Module.js:40569:23"
       var formattedInfo = '';
       if (!kony.sdk.isNullOrUndefined(callerInformation)) {
         formattedInfo = callerInformation.replace('(', '');
         formattedInfo = formattedInfo.replace(')', '');
       }
       return formattedInfo;
     };
     formatFileInfo = function(fileInfo) {
       //sample fileInfo's value can look like -> "http://kh2321.kitspl.com:8443/apps/IDETestDriver8/1570111366904/desktopweb/appjs/app.js:40569:23" or "Module.js:40569:23"
       var firstLastIndexOfColon = fileInfo.lastIndexOf(':');
       var secondLastIndexOfColon = fileInfo.lastIndexOf(':', firstLastIndexOfColon - 1);
       fileInfo = fileInfo.substring(0, secondLastIndexOfColon);
       //fileInfo's value can look like "http://kh2321.kitspl.com:8443/apps/IDETestDriver8/1570111366904/desktopweb/appjs/app.js" or "Module.js"
       var indexOfSlashInProcessedFileInfo = fileInfo.lastIndexOf('/');
       fileInfo = indexOfSlashInProcessedFileInfo > 0 ? fileInfo.substring(indexOfSlashInProcessedFileInfo + 1, fileInfo.length) : fileInfo;
       return fileInfo;
     };
     formatMethodInformation = function(callerInformation) {
       //callerInformation's value can look like -> ["", "", "", "", "at", "logTest.testDeviceConsoleLogs", "(http://kh2321.kitspl.com:8443/apps/IDETestDriver8/1570111366904/desktopweb/appjs/app.js:40569:23)"]
       if (callerInformation.length > 1) return callerInformation[callerInformation.length - 2];
     };
     formatCallerInformation = function(callerInformation) {
       //JSCore syntax: <methodName>@<fileName>:<row>:<col>
       //V8 syntax: at <methodName> (<fileName>:<row>:<col>)
       //Chakra syntax: at (<methodURL> <fileURL>:<row>:<col>)
       if (!kony.sdk.isNullOrUndefined(callerInformation)) {
         formattedCallerInformation = callerInformation.split(seperator);
         return formattedCallerInformation;
       }
       return [];
     };
     getCallerInformationFromCallStack = function(callStack, indirectionLevel) {
       var processedOffset = offsetIndex + indirectionLevel;
       if (callStack.length >= processedOffset) return callStack[processedOffset];
       return null;
     };
     generateCallerInformation = function(indirectionLevel) {
       var errorObject = new Error();
       var callStack;
       /* In IE, Error object doesn't contain stack information, hence can't provide caller info right away
       we need to throw the error and catch it to get the stack*/
       if ('stack' in errorObject) {
         callStack = errorObject.stack.split('\n');
       } else {
         callStack = function() {
           try {
             throw new Error('');
           } catch (n) {
             return n.stack;
           }
         }();
         callStack = callStack != undefined ? callStack.split('\n') : [];
       }
       var callerInformation = getCallerInformationFromCallStack(callStack, indirectionLevel);
       // sample value of callerInformation can be -> "    at logTest.testDeviceConsoleLogs (http://kh2321.kitspl.com:8443/apps/IDETestDriver8/1570111366904/desktopweb/appjs/app.js:40569:23)"
       return formatCallerInformation(callerInformation);
     };
     parseMessage = function(loggerObj, logLevel, msg, params) {
       var logLevelVal = (kony.logger.isNativeLoggerAvailable()) ? KonyLogger.getLogLevel() : kony.logger.currentLogLevel.value;
       if (logLevel.value >= logLevelVal) {
         var metaData = {};
         params = (typeof(params) === "undefined") ? "" : params;
         //Stringify object
         if (kony.logger.isValidJSTable(params)) {
           params = JSON.stringify(params, null, " ");
         }
         metaData.message = msg + params;
         metaData.callerInformation = generateCallerInformation(loggerObj.getIndirectionLevel());
         metaData.methodName = formatMethodInformation(metaData.callerInformation);
         /*
             logs in browser can logged by browser by their style of implementation
             sample console logs in chrome & opera
             [Test][TRACE][9/24/2019 7:43:11 PM][app.js][logTest.testDeviceConsoleLogs][55000] : console message in level-trace
             sample console logs in ie & safari
             [TestLogger][TRACE][10/3/2019 4:43:45 PM][app.js][testDeviceConsoleLogs][36953] : console message in level-trace
             sample console logs in firefox
             [TestLogger][TRACE][10/3/2019 7:21:14 PM][app.js][logTest/this.testDeviceConsoleLogs][40569] : console message in level-trace
          */
         var fileAndLineInfoMeta = formatFileAndLineInfoMeta(metaData.callerInformation.pop());
         metaData.fileName = formatFileInfo(fileAndLineInfoMeta);
         metaData.lineNo = formatLineInfo(fileAndLineInfoMeta);
         if (kony.logger.isNativeLoggerAvailable()) {
           if (!loggerObj.NativeLoggerObject) {
             loggerObj.NativeLoggerObject = new KonyLogger.InitializeLogger(loggerObj.loggerName);
             KonyLogger.setConfig(loggerObj.config);
           }
           if (loggerObj.NativeLoggerObject) {
             logMessageInFFI(loggerObj.NativeLoggerObject, logLevel, metaData);
           } else {
             var date = new Date().toLocaleDateString();
             var time = new Date().toLocaleTimeString();
             var level = logLevel.code;
             var formattedMessage = "[" + loggerObj.loggerName + "][" + level + "][" + date + " " + time + "][" + metaData.fileName + "][" + metaData.methodName + "][" + metaData.lineNo + "] : " + metaData.message;
             kony.print(formattedMessage);
           }
         } else {
           var date = new Date().toLocaleDateString();
           var time = new Date().toLocaleTimeString();
           var level = logLevel.code;
           var formattedMessage = "[" + loggerObj.loggerName + "][" + level + "][" + date + " " + time + "][" + metaData.fileName + "][" + metaData.methodName + "][" + metaData.lineNo + "] : " + metaData.message;
           kony.print(formattedMessage);
         }
       }
     };
     parseMessage(loggerObj, logLevel, msg, params);
   };
   //Exposed object and it's methods
   var loggerObj = kony.logger.createLoggerObject(loggerName, loggerConfig);
   if (loggerObj.config !== null && loggerObj.config.overrideConfig === true) {
     for (var key in kony.logger.logLevel) {
       if (kony.logger.logLevel.hasOwnProperty(key)) {
         if (kony.logger.logLevel[key].value == loggerObj.config.logFilterConfig.logLevel) {
           kony.logger.currentLogLevel = kony.logger.logLevel[key];
           break;
         }
       }
     }
   }
   var seperator = " ";
   var offsetIndex = 5;
   var browser = kony.os.deviceInfo().category;
   if (kony.sdk.util.isValidString(browser)) {
     browser = browser.toLowerCase();
     switch (browser) {
       case 'ie':
         offsetIndex += 1;
         break;
       case 'safari':
       case 'firefox':
         seperator = '@';
         offsetIndex += -1;
         //the default value is already set to 0
     }
   }
   //Native object creation
   if (kony.logger.isNativeLoggerAvailable()) {
     loggerObj.NativeLoggerObject = new KonyLogger.InitializeLogger(loggerName);
     KonyLogger.setConfig(loggerObj.config);
   }
   return loggerObj;
 }
 kony.logger["appLogger"] = kony.logger.appLoggerInitialisation();
 /**
  * MFSDK
  * Created by KH2204.
  * Copyright  2018 Kony. All rights reserved.
  */
 /**
  * Method to create the integration service instance with the provided service name.
  * @param {string} serviceName - Name of the service
  * @returns {IntegrationService} Integration service instance
  */
 kony.sdk.prototype.getIntegrationService = function(serviceName) {
   if (!kony.sdk.isInitialized) {
     throw new Exception(kony.sdk.errorConstants.INIT_FAILURE, kony.sdk.constants.INIT_FAILURE_MESSAGE + "integration service :" + serviceName);
   }
   var konyRef = kony.sdk.getCurrentInstance();
   if (!kony.sdk.skipAnonymousCall && !this.currentClaimToken && !konyRef.isAnonymousProvider) {
     throw new Exception(kony.sdk.errorConstants.AUTH_FAILURE, "Valid claims token is not found, login using identity service before performing an operation on this integration service :" + serviceName);
   }
   if (this.integsvc != null) {
     if (this.integsvc[serviceName] != null) {
       kony.sdk.logsdk.debug("found integration service" + this.integsvc[serviceName]);
       return new IntegrationService(this, serviceName);
     }
   }
   throw new Exception(kony.sdk.errorConstants.INTEGRATION_FAILURE, "Integration service is not found or invalid :" + serviceName);
 };
 /**
  * Method should not be called by developer.
  * @class
  * @classdesc Integration service instance for invoking the integration services.
  */
 function IntegrationService(konyRef, serviceName) {
   var serviceUrl = "";
   var svcObj = konyRef.integsvc[serviceName];
   if (typeof(svcObj) === "object") {
     serviceUrl = svcObj["url"];
   } else {
     serviceUrl = svcObj;
   }
   var networkProvider = new konyNetworkProvider();
   if (kony.sdk.util.isNullOrEmptyString(serviceName) || kony.sdk.util.isNullOrEmptyString(serviceUrl)) {
     throw new Exception(kony.sdk.errorConstants.INIT_FAILURE, "Invalid serviceUrl and serviceName");
   }
   serviceUrl = stripTrailingCharacter(serviceUrl, "/");
   this.getUrl = function() {
     return serviceUrl;
   };
   /**
    * Integration service success callback method.
    * @callback integrationSuccessCallback
    * @param {json} response - Integration service response
    */
   /**
    * Integration service failure callback method.
    * @callback integrationFailureCallback
    * @param {json} error - Error information
    */
   /**
    * invoke the specified operation
    * @param {string} operationName - Name of the operation
    * @param {object} headers - Input headers for the operation
    * @param {object} data - Input data for the operation
    * @param {integrationSuccessCallback} successCallback  - Callback method on success
    * @param {integrationFailureCallback} failureCallback - Callback method on failure
    * @param {object} options - XMLHttpRequest options like withCredentials value.
    */
   this.invokeOperation = function(operationName, headers, data, successCallback, failureCallback, options) {
     function invokeOperationHandler() {
       _invokeOperation(operationName, headers, data, true, successCallback, failureCallback, options);
     }
     if (kony.sdk.skipAnonymousCall) {
       invokeOperationHandler();
     } else {
       kony.sdk.claimsRefresh(invokeOperationHandler, failureCallback);
     }
   };
   /**
    * Integration service API to upload binaries based on adapter template
    * @param {string} operationName - Name of the operation
    * @param {Object} uploadParams - InputContext or template variables
    * @param {callback} fileUploadStartedCallback - Callback which is invoked on start of file upload
    * @param {callback} chunkUploadCompletedCallback - Callback which is invoked on chunk upload
    * @param {callback} fileUploadCompletedCallback - Callback which is invoked on complete of file upload
    * @param {callback} fileUploadFailureCallback - Callback which is invoked in case of error during upload
    * @param {Object} options - Provision for user to send additional options
    */
   this.uploadBinaryData = function(operationName, uploadParams, fileUploadStartedCallback, chunkUploadCompletedCallback, fileUploadCompletedCallback, fileUploadFailureCallback, options) {
     //With V9-P2 release, mobile fabric server sends X-Kony-Integrity header for binary calls as well. So, to ignore
     //integrity check at network (konyNetHttpRequest) layer passing ignoreintegrity as true.
     if (kony.sdk.isNullOrUndefined(options)) {
       options = {};
       options[kony.sdk.constants.IGNORE_MESSAGE_INTEGRITY] = true;
     }
     var errorObj = kony.sdk.binary.validateUploadParams(uploadParams);
     if (errorObj) {
       kony.sdk.verifyAndCallClosure(fileUploadFailureCallback, errorObj);
       return;
     }
     // if rawbytes are provided, converting to base64 string as can only receive base datatypes
     if (!kony.sdk.isNullOrUndefined(uploadParams[kony.sdk.constants.RAW_BYTES])) {
       var base64String = kony.convertToBase64(uploadParams[kony.sdk.constants.RAW_BYTES]);
       uploadParams[kony.sdk.constants.RAW_BYTES] = base64String;
     }

     function uploadBinaryDataHandler() {
       var uploadOptions = {};
       uploadOptions["URL"] = serviceUrl + "/" + operationName;
       var headers = kony.sdk.getDefaultHeaders();;
       if (!kony.sdk.skipAnonymousCall) {
         headers[kony.sdk.constants.KONY_AUTHORIZATION_HEADER] = kony.sdk.getCurrentInstance().currentClaimToken;
       }
       uploadOptions["headers"] = headers;
       //Extracting Mandatory Params from uploadParams before fetching template
       if (uploadParams[kony.sdk.constants.FILE_PATH]) {
         uploadOptions[kony.sdk.constants.FILE_PATH] = uploadParams[kony.sdk.constants.FILE_PATH];
         delete uploadParams[kony.sdk.constants.FILE_PATH];
       } else if (uploadParams[kony.sdk.constants.RAW_BYTES]) {
         uploadOptions[kony.sdk.constants.RAW_BYTES] = uploadParams[kony.sdk.constants.RAW_BYTES];
         delete uploadParams[kony.sdk.constants.RAW_BYTES];
       } else if (uploadParams[kony.sdk.constants.FILE_OBJECT]) {
         uploadOptions[kony.sdk.constants.FILE_OBJECT] = uploadParams[kony.sdk.constants.FILE_OBJECT];
         delete uploadParams[kony.sdk.constants.FILE_OBJECT]
       }
       uploadOptions["uploadParams"] = uploadParams;
       kony.sdk.binary.uploadBinaryData(uploadOptions, fileUploadStartedCallback, chunkUploadCompletedCallback, fileUploadCompletedCallback, fileUploadFailureCallback, options);
     }
     if (kony.sdk.skipAnonymousCall) {
       uploadBinaryDataHandler();
     } else {
       kony.sdk.claimsRefresh(uploadBinaryDataHandler, fileUploadFailureCallback);
     }
   };
   /**
    * Integration service API to download binaries based on adapter template
    * @param {string} operationName - Name of the operation
    * @param {Object} fileparams - InputContext or template variables
    * @param {boolean} streaming - Boolean value to determine, whether chunks need to be saved to file or sent in callbacks
    * @param {Object} headers - Provision for custom headers
    * @param {callback} fileDownloadStartedCallback - Callback which is invoked on start of file download
    * @param {callback} chunkDownloadCompletedCallback - Callback which is invoked on stream/chunk download
    * @param {callback} fileDownloadCompletedCallback - Callback which is invoked on complete of file download
    * @param {callback} downloadFailureCallback - Callback which is invoked in case of error during download
    * @param {Object} options - Provision for user to send additional options
    */
   this.getBinaryData = function(operationName, fileparams, streaming, headers, fileDownloadStartedCallback, chunkDownloadCompletedCallback, fileDownloadCompletedCallback, downloadFailureCallback, options) {
     //With V9-P2 release, mobile fabric server sends X-Kony-Integrity header for binary calls as well. So, to ignore
     //integrity check at network (konyNetHttpRequest) layer passing ignoreintegrity as true.
     if (kony.sdk.isNullOrUndefined(options)) {
       options = {};
       options[kony.sdk.constants.IGNORE_MESSAGE_INTEGRITY] = true;
     }

     function getBinaryDataHandler() {
       _invokeOperation(operationName, headers, fileparams, true, function(downloadConfig) {
         if (kony.sdk.isNullOrUndefined(downloadConfig)) {
           downloadConfig = {};
         }
         if (options && options["ChunkSize"]) {
           downloadConfig.ChunkSize = options["ChunkSize"];
         }
         if (headers) {
           if (kony.sdk.isNullOrUndefined(downloadConfig.headers)) {
             downloadConfig.headers = {};
           }
           for (var header in headers) {
             if (headers.hasOwnProperty(header)) {
               downloadConfig.headers[header] = headers[header];
             }
           }
         }
         kony.sdk.binary.getBinaryData(fileparams, streaming, downloadConfig, fileDownloadStartedCallback, chunkDownloadCompletedCallback, fileDownloadCompletedCallback, downloadFailureCallback, options);
       }, downloadFailureCallback, options);
     }
     if (kony.sdk.skipAnonymousCall) {
       // Check to find if the service is public or not, in case of public service anonymous login is not required.
       getBinaryDataHandler();
     } else {
       kony.sdk.claimsRefresh(getBinaryDataHandler, downloadFailureCallback);
     }
   };

   function invokeOperationRetry(operationName, headers, data, successCallback, failureCallback, options) {
     function invokeOperationRetryHandler() {
       _invokeOperation(operationName, headers, data, false, successCallback, failureCallback, options);
     }
     if (kony.sdk.skipAnonymousCall) {
       invokeOperationRetryHandler();
     } else {
       kony.sdk.claimsAndProviderTokenRefresh(invokeOperationRetryHandler, failureCallback);
     }
   }

   function retryServiceCall(errorResponse) {
     if (errorResponse[kony.sdk.constants.MF_CODE]) {
       // check for the mfcode for which,
       // retry should be done.
     } else {
       if (errorResponse[kony.sdk.constants.HTTP_STATUS_CODE] && errorResponse[kony.sdk.constants.HTTP_STATUS_CODE] === 401) {
         kony.sdk.logsdk.debug("### IntegrationService::retryServiceCall received 401 from fabric, trying to refresh backend token");
         return true;
       }
     }
   }

   function _invokeOperation(operationName, headers, data, isRetryNeeded, successCallback, failureCallback, options) {
     kony.sdk.logsdk.perf("Executing _invokeOperation : " + operationName);
     var requestData = kony.sdk.getEncodedReportingParamsForSvcid(operationName);
     var dataToSend = {};
     for (var key in data) {
       if (data.hasOwnProperty(key)) {
         dataToSend[key] = data[key];
       }
     }
     var defaultHeaders = kony.sdk.getDefaultHeaders();;
     defaultHeaders[kony.sdk.constants.HTTP_CONTENT_HEADER] = kony.sdk.constants.CONTENT_TYPE_FORM_URL_ENCODED;
     defaultHeaders["X-Kony-ReportingParams"] = requestData;
     if (!kony.sdk.skipAnonymousCall) {
       // Check to find if the service is public or not, in case of public service no token is required.
       var token = konyRef.currentClaimToken;
       if (!token) {
         token = kony.sdk.getCurrentInstance().currentClaimToken;
       }
       defaultHeaders[kony.sdk.constants.KONY_AUTHORIZATION_HEADER] = token;
     }
     var deviceId = kony.sdk.getDeviceId();
     if (!kony.sdk.isNullOrUndefined(deviceId)) {
       defaultHeaders["X-Kony-DeviceId"] = deviceId;
     }
     if (typeof(svcObj) === 'object' && svcObj.version) {
       defaultHeaders["X-Kony-API-Version"] = svcObj.version;
     }
     // if the user has defined his own headers, use them
     if (!kony.sdk.isNullOrUndefined(headers)) {
       if ((Object.keys(headers)).length !== 0 && typeof(headers) === "object") {
         var defaultKeys = Object.keys(defaultHeaders);
         var lowerCaseHeaders = defaultKeys.map(function(x) {
           return x.toLowerCase()
         });
         for (var header in headers) {
           var headerConst = header;
           if (lowerCaseHeaders.indexOf(headerConst.toLowerCase()) !== -1) {
             for (var i = 0; i < defaultKeys.length; i++) {
               var tempKey = defaultKeys[i];
               if (tempKey.toLowerCase() === headerConst.toLowerCase()) {
                 defaultHeaders[tempKey] = headers[header];
               }
             }
           } else {
             defaultHeaders[header] = headers[header];
           }
         }
       }
     }
     // If useCache is enabled and cacheID is present then network call will be skipped and cached response will be returned.
     if (options && options["useCache"] && options["cacheID"]) {
       var cacheResponse = new kony.sdk.ClientCache().get(options["cacheID"]);
       if (cacheResponse) {
         kony.sdk.logsdk.debug("Key found in hash, returning cached response.");
         kony.sdk.verifyAndCallClosure(successCallback, cacheResponse);
         return;
       }
     }

     function networkSuccessCallback(res) {
       // If useCache is enabled then the response is cached and returned.
       if (options && options["useCache"]) {
         cacheResponseForKey(options, serviceUrl + "/" + operationName, requestData, res);
       }
       kony.sdk.logsdk.perf("Executing Finished network call for _invokeOperation : " + operationName);
       kony.sdk.logsdk.perf("Executing Finished _invokeOperation : " + operationName);
       kony.sdk.verifyAndCallClosure(successCallback, res);
     }

     function networkFailureCallback(xhr, status, err) {
       if (xhr && !(status && err)) {
         err = xhr;
       }
       if (isRetryNeeded === true && retryServiceCall(err) === true) {
         kony.sdk.logsdk.debug("errorCallback, retrying the operation: " + operationName);
         invokeOperationRetry(operationName, headers, data, successCallback, failureCallback);
         return;
       }
       kony.sdk.logsdk.perf("Executing Finished network call for _invokeOperation : " + operationName);
       kony.sdk.logsdk.perf("Executing Finished _invokeOperation : " + operationName);
       kony.sdk.processIntegrationErrorResponse(err, true, failureCallback);
     }
     kony.sdk.logsdk.perf("Executing network call for _invokeOperation : " + operationName);
     networkProvider.post(serviceUrl + "/" + operationName, dataToSend, defaultHeaders, networkSuccessCallback, networkFailureCallback, null, options);
   }
   kony.sdk.processIntegrationErrorResponse = function(err, isAsync, callBack) {
     if (err[kony.sdk.constants.MF_CODE]) {
       //clear the cache if the error code related to session/token expiry
       if (kony.sdk.isSessionOrTokenExpired(err[kony.sdk.constants.MF_CODE])) {
         kony.sdk.logsdk.info("###IntegrationService::invokeOperationFailure  Session/Token expired. Authenticate and Try again");
         //TODO: Start a conversation with Suhas and Krishna regarding the scenario wherein one auth session expired and other is still valid.
       }
     }
     if (!isAsync) {
       return kony.sdk.error.getIntegrationErrObj(err);
     } else if (callBack) {
       kony.sdk.verifyAndCallClosure(callBack, kony.sdk.error.getIntegrationErrObj(err));
     }
   };
   //This is an internal api to invoke an service synchronously
   this.invokeOperationSync = function(operationName, headers, data) {
     var res = null;
     res = kony.sdk.claimsRefreshSync();
     if (res && res.message && res.message === "success") {
       return _invokeOperationSync(operationName, headers, data);
     } else {
       return res;
     }
   };

   function _invokeOperationSync(operationName, headers, data) {
     var requestData = {};
     var konyRef = kony.sdk.getCurrentInstance();
     var reportingData = kony.sdk.getEncodedReportingParamsForSvcid(operationName);
     for (var key in data) {
       if (data.hasOwnProperty(key)) {
         requestData[key] = data[key];
       }
     }
     var token;
     for (var tempToken in konyRef.tokens) {
       if (konyRef.tokens.hasOwnProperty(tempToken) && typeof(tempToken) !== 'function') {
         token = konyRef.tokens[tempToken];
         break;
       }
     }
     requestData[kony.sdk.constants.REPORTING_PARAMS] = reportingData;
     var defaultHeaders = kony.sdk.getDefaultHeaders();
     defaultHeaders[kony.sdk.constants.HTTP_CONTENT_HEADER] = kony.sdk.constants.CONTENT_TYPE_FORM_URL_ENCODED;
     defaultHeaders[kony.sdk.constants.KONY_AUTHORIZATION_HEADER] = konyRef.currentClaimToken;
     if (typeof(svcObj) === 'object' && svcObj.version) {
       defaultHeaders["X-Kony-API-Version"] = svcObj.version;
     }
     // if the user has defined his own headers, use them
     if ((Object.keys(headers)).length !== 0) {
       var defaultKeys = [];
       defaultKeys = Object.keys(defaultHeaders);
       var defaultkeyLower = {};
       defaultkeyLower = defaultKeys.map(function(x) {
         return x.toLowerCase()
       });
       for (var header in headers) {
         var headerConst = header;
         if (defaultkeyLower.indexOf(headerConst.toLowerCase()) !== -1) {
           for (var i = 0; i < defaultKeys.length; i++) {
             var tempKey = defaultKeys[i];
             if (tempKey.toLowerCase() === headerConst.toLowerCase()) {
               defaultHeaders[tempKey] = headers[header];
             }
           }
         } else {
           defaultHeaders[header] = headers[header];
         }
       }
     }
     var res = null;
     res = networkProvider.postSync(serviceUrl + "/" + operationName, requestData, defaultHeaders);
     if (res.opstatus == 0) {
       return res;
     } else {
       return kony.sdk.processIntegrationErrorResponse(res, false);
     }
   }
 }
 kony.sdk.claimsRefreshSync = function() {
   var konyRef = kony.sdk.getCurrentInstance();
   var networkProvider = new konyNetworkProvider();
   var loginWithAnonymousProvider = function() {
     var identityObject = konyRef.getIdentityService("$anonymousProvider");
     var res = identityObject.anonymousLoginSync(null);
     if (res && JSON.stringify(res) == "{}") {
       return {
         "message": "success"
       };
     } else {
       return kony.sdk.error.getAuthErrObj(res);
     }
   };
   if (konyRef.currentClaimToken === null) {
     kony.sdk.logsdk.info("claims Token is Unavialable");
     if (konyRef.isAnonymousProvider) {
       return loginWithAnonymousProvider();
     } else {
       return kony.sdk.error.getNullClaimsTokenErrObj();
     }
   } else if (konyRef.claimTokenExpiry && new Date().getTime() > konyRef.claimTokenExpiry) {
     if (konyRef.isAnonymousProvider) {
       return loginWithAnonymousProvider();
     } else {
       kony.sdk.logsdk.info("claims token has expired. fetching new token..");
       var _serviceUrl = stripTrailingCharacter(konyRef.rec.url, "/");
       var _url = _serviceUrl + "/claims";
       kony.sdk.logsdk.debug("service url is " + _url);
       if (konyRef.currentRefreshToken === null) {
         return kony.sdk.error.getNullRefreshTokenErrObj();
       } else {
         var headers = kony.sdk.getDefaultHeaders();
         headers[kony.sdk.constants.AUTHORIZATION_HEADER] = konyRef.currentRefreshToken;
         headers[kony.sdk.constants.HTTP_CONTENT_HEADER] = kony.sdk.constants.CONTENT_TYPE_FORM_URL_ENCODED;
         var data = networkProvider.postSync(_url, {}, headers);
         if (data.opstatus == 0) {
           kony.sdk.logsdk.info("refresh success..acquiring new tokens");
           return kony.sdk.processClaimsSuccessResponse(data, konyRef, false);
         } else {
           kony.sdk.logsdk.info("failed to acquire refresh token");
           return kony.sdk.processClaimsErrorResponse(data, konyRef, false);
         }
       }
     }
   } else {
     return {
       "message": "success"
     };
   }
 };
 /**
  * Method to create the messaging service instance.
  * @returns {MessagingService} Messaging service instance
  */
 kony.sdk.prototype.getMessagingService = function() {
   if (!kony.sdk.isInitialized) {
     throw new Exception(kony.sdk.errorConstants.INIT_FAILURE, kony.sdk.constants.INIT_FAILURE_MESSAGE + " Messaging service.");
   }
   KNYMessagingService = kony.sdk.isNullOrUndefined(KNYMessagingService) ? new MessagingService(this) : KNYMessagingService;
   if ((this.messagingsvc.url !== KNYMessagingService.getUrl()) || (this.messagingsvc.appId !== KNYMessagingService.getKmsAppId())) {
     KNYMessagingService = new MessagingService(this);
   }
   return KNYMessagingService;
 };
 var KNYGeoBoundariesOptions = {};
 /**
  * Should not be called by the developer.
  * @class
  * @classdesc Messaging service instance for invoking the Messaging services.
  * @param konyRef - reference to kony object
  */
 function MessagingService(konyRef) {
   var homeUrl = konyRef.messagingsvc.url;
   var appId = konyRef.messagingsvc.appId;
   var networkProvider = new konyNetworkProvider();
   var dsKey_KSID = appId + "_KSID";
   var dsKey_authToken = appId + "_AUTHTOKEN";
   var currentObject = this;
   var geoBoundaryData;
   var KSID;
   var AUTHTOKEN;
   geoBoundariesOptions = {};
   this.setGeoBoundariesOptions = function(options) {
     KNYGeoBoundariesOptions = options;
   };
   this.getGeoBoundariesOptions = function() {
     return KNYGeoBoundariesOptions;
   };
   this.getUrl = function() {
     return homeUrl;
   };
   this.setKSID = function(ksid) {
     kony.sdk.dataStore.setItem(dsKey_KSID, ksid);
     KSID = ksid;
   };
   this.getKSID = function() {
     if (!KSID) {
       KSID = kony.sdk.dataStore.getItem(dsKey_KSID);
     }
     return KSID;
   };
   this.setAuthToken = function(authToken) {
     kony.sdk.dataStore.setItem(dsKey_authToken, authToken);
     AUTHTOKEN = authToken
   };
   this.getAuthToken = function(options) {
     if (options && options[kony.sdk.constants.AUTH_TOKEN]) {
       AUTHTOKEN = options[kony.sdk.constants.AUTH_TOKEN];
     } else {
       //retrieving from local store if user given token is null
       AUTHTOKEN = kony.sdk.dataStore.getItem(dsKey_authToken);
     }
     return AUTHTOKEN;
   };
   var setGeoBoundaryData = function(data) {
     kony.sdk.dataStore.setItem("geoBoundaryData", data);
     geoBoundaryData = data;
   };
   var getGeoBoundaryDataForBoundaryId = function(boundaryId) {
     if (!geoBoundaryData) {
       geoBoundaryData = kony.sdk.dataStore.getItem("geoBoundaryData")
     }
     return geoBoundaryData[boundaryId];
   };
   this.setKmsAppId = function(id) {
     appId = id;
   };
   this.getKmsAppId = function() {
     return appId;
   };
   KSID = currentObject.getKSID();
   AUTHTOKEN = currentObject.getAuthToken();
   var registerForMessagingService = function(osType, deviceId, pnsToken, email, authToken, successCallback, failureCallback) {
     var uri = homeUrl + "/subscribers";
     var subscribeParamsJson = {
       "sid": pnsToken,
       "appId": appId,
       "ufid": email,
       "osType": osType,
       "deviceId": deviceId
     };
     if (authToken != undefined && authToken != null) {
       subscribeParamsJson[kony.sdk.constants.AUTH_TOKEN] = authToken;
     }
     var jsonParam = {
       "subscriptionService": {
         "subscribe": subscribeParamsJson
       }
     };
     var headers = kony.sdk.getDefaultHeaders();
     headers[kony.sdk.constants.HTTP_CONTENT_HEADER] = kony.sdk.constants.CONTENT_TYPE_JSON_CHARSET_UTF8;
     var payload = jsonParam;
     var networkOptions = {};
     networkOptions["disableIntegrity"] = true;
     kony.sdk.logsdk.perf("Executing registerForMessagingService's network call");
     networkProvider.post(uri, payload, headers, function(data) {
       kony.sdk.logsdk.perf("Executing finished registerForMessagingService's network success");
       currentObject.setKSID(data.id);
       currentObject.setAuthToken(authToken);
       kony.sdk.verifyAndCallClosure(successCallback, data);
     }, function(data, status, error) {
       kony.sdk.logsdk.perf("Executing finished registerForMessagingService's network failure");
       kony.sdk.logsdk.error("ERROR: Failed to register device for KMS");
       var errorObj = {};
       errorObj.data = data;
       errorObj.status = status;
       errorObj.error = error;
       kony.sdk.verifyAndCallClosure(failureCallback, errorObj);
     }, kony.sdk.constants.CONTENT_TYPE_JSON, networkOptions);
   };
   var subscribeAudienceOrUpdate = function(firstName, lastName, emailId, mobileNumber, country, state, options, successCallback, failureCallback) {
     var uri = homeUrl + kony.sdk.constants.SUBSCRIBE_AUDIENCE;
     var subscribeAudienceJson = {
       "ksid": KSID,
       "firstName": firstName,
       "lastName": lastName,
       "email": emailId,
       "mobileNumber": mobileNumber,
       "country": country,
       "state": state
     };
     var currentdate = new Date();
     //toLocaleString gives current time in below format
     //6/25/2018, 12:38:21 PM
     var datetime = currentdate.toLocaleString('en-US', {
       timeZone: 'UTC'
     });
     //remove , in the current UTC time
     datetime = datetime.replace(",", "");
     subscribeAudienceJson[kony.sdk.constants.LAST_ACTIVE_DATE] = datetime;
     if (!kony.sdk.isNullOrUndefined(options)) {
       for (var key in options) {
         if (options.hasOwnProperty(key)) {
           if (key === kony.sdk.constants.AUTH_TOKEN) {
             subscribeAudienceJson[key] = currentObject.getAuthToken(options);
           } else {
             subscribeAudienceJson[key] = options[key];
           }
         }
       }
     }
     var headers = kony.sdk.getDefaultHeaders();
     headers[kony.sdk.constants.HTTP_CONTENT_HEADER] = kony.sdk.constants.CONTENT_TYPE_JSON_CHARSET_UTF8;
     var payload = subscribeAudienceJson;
     var networkOptions = {};
     networkOptions[kony.sdk.constants.DISABLE_INTEGRITY] = true;
     kony.sdk.logsdk.perf("Executing subscribeAudienceOrUpdate's network call");
     networkProvider.post(uri, payload, headers, function(data) {
       //override data store auth token with user given token
       kony.sdk.logsdk.perf("Executing finished subscribeAudienceOrUpdate's network success");
       overrideAuthToken(options);
       kony.sdk.verifyAndCallClosure(successCallback, data);
     }, function(data, status, error) {
       kony.sdk.logsdk.perf("Executing finished subscribeAudienceOrUpdate's network failure");
       kony.sdk.logsdk.error("ERROR: Failed to create or update audience", errorObj);
       var errorObj = {};
       errorObj.data = data;
       errorObj.status = status;
       errorObj.error = error;
       kony.sdk.verifyAndCallClosure(failureCallback, errorObj);
     }, kony.sdk.constants.CONTENT_TYPE_JSON, networkOptions);
   };
   /**
     * register to messaging service
     * @param {string} osType - Type of the operating system
     * @param {string} deviceId - Device Id
     * @param {string} pnsToken - Token value
     * @param {string} ufid - UFID can be email-id,mobile number or
	 						any dynamic attribute configured as reconciliation key in Engagement console
     * @param {function} successCallback - Callback method on success
     * @param {function} failureCallback - Callback method on failure
     * @param {dictionary} options - {authToken: <Auth Token>}
     */
   this.register = function(osType, deviceId, pnsToken, ufid, successCallback, failureCallback, options) {
     kony.sdk.logsdk.perf("Executing register");
     var authToken = null;
     if (kony.sdk.isNullOrUndefined(pnsToken)) {
       kony.sdk.logsdk.perf("Executing finished register finished with exception");
       throw new Exception(kony.sdk.errorConstants.MESSAGING_FAILURE, "Invalid pnsToken/sId, it cannot be null");
     }
     if (kony.sdk.isNullOrUndefined(osType)) {
       kony.sdk.logsdk.perf("Executing finished register finished with exception");
       throw new Exception(kony.sdk.errorConstants.MESSAGING_FAILURE, "Invalid osType, it cannot be null");
     }
     if (kony.sdk.isNullOrUndefined(deviceId)) {
       kony.sdk.logsdk.perf("Executing finished register finished with exception");
       throw new Exception(kony.sdk.errorConstants.MESSAGING_FAILURE, "Invalid deviceId, it cannot be null");
     }
     if (kony.sdk.isNullOrUndefined(ufid)) {
       kony.sdk.logsdk.perf("Executing finished register finished with exception");
       throw new Exception(kony.sdk.errorConstants.MESSAGING_FAILURE, "Invalid email, it cannot be null");
     }
     authToken = currentObject.getAuthToken(options);
     registerForMessagingService(osType, deviceId, pnsToken, ufid, authToken, function(data) {
       //override data store auth token with user given token
       kony.sdk.logsdk.perf("Executing finished register finished with success");
       overrideAuthToken(options);
       kony.sdk.verifyAndCallClosure(successCallback, data);
     }, function(errorObj) {
       kony.sdk.logsdk.perf("Executing finished register finished with failure");
       kony.sdk.logsdk.error("Register :: Register for messaging service failed with error", errorObj);
       kony.sdk.verifyAndCallClosure(failureCallback, errorObj);
     });
   };
   /**
    * register to messaging service
    * @param {string} osType - Type of the operating system
    * @param {string} deviceId - Device Id
    * @param {string} authToken - Authorization Token
    * @param {string} pnsToken - Token value
    * @param {string} email - email
    * @param {function} successCallback - Callback method on success
    * @param {function} failureCallback - Callback method on failure
    */
   /**
    * @deprecated This method is deprecated because authToken can be given as input through options param of
    * register method.
    */
   this.registerWithAuthToken = function(osType, deviceId, pnsToken, email, authToken, successCallback, failureCallback) {
     kony.sdk.logsdk.perf("Executing registerWithAuthToken");
     if (kony.sdk.isNullOrUndefined(pnsToken)) {
       kony.sdk.logsdk.perf("Executing finished registerWithAuthToken finished with exception");
       throw new Exception(kony.sdk.errorConstants.MESSAGING_FAILURE, "Invalid pnsToken/sId,it cannot be null");
     }
     if (kony.sdk.isNullOrUndefined(osType)) {
       kony.sdk.logsdk.perf("Executing finished registerWithAuthToken finished with exception");
       throw new Exception(kony.sdk.errorConstants.MESSAGING_FAILURE, "Invalid osType, it cannot be null");
     }
     if (kony.sdk.isNullOrUndefined(deviceId)) {
       kony.sdk.logsdk.perf("Executing finished registerWithAuthToken finished with exception");
       throw new Exception(kony.sdk.errorConstants.MESSAGING_FAILURE, "Invalid deviceId, it cannot be null");
     }
     if (kony.sdk.isNullOrUndefined(email)) {
       kony.sdk.logsdk.perf("Executing finished registerWithAuthToken finished with exception");
       throw new Exception(kony.sdk.errorConstants.MESSAGING_FAILURE, "Invalid email, it cannot be null");
     }
     if (kony.sdk.isNullOrUndefined(authToken)) {
       kony.sdk.logsdk.perf("Executing finished registerWithAuthToken finished with exception");
       throw new Exception(kony.sdk.errorConstants.MESSAGING_FAILURE, "Invalid authToken, it cannot be null");
     }
     registerForMessagingService(osType, deviceId, pnsToken, email, authToken, function(data) {
       kony.sdk.logsdk.perf("Executing finished registerWithAuthToken finished with success");
       kony.sdk.verifyAndCallClosure(successCallback, data)
     }, function(errorObj) {
       kony.sdk.logsdk.perf("Executing finished registerWithAuthToken finished with failure");
       kony.sdk.verifyAndCallClosure(failureCallback, errorObj);
     });
   };
   var unregisterFromMessagingService = function(authToken, successCallback, failureCallback) {
     var uri = homeUrl + "/subscribers";
     var unsubscribeObj = {
       "ksid": currentObject.getKSID()
     };
     if (authToken != undefined && authToken != null) {
       unsubscribeObj[kony.sdk.constants.AUTH_TOKEN] = authToken;
     }
     var inp = {
       "subscriptionService": {
         "unsubscribe": unsubscribeObj
       }
     };
     var headers = kony.sdk.getDefaultHeaders();
     headers[kony.sdk.constants.HTTP_CONTENT_HEADER] = kony.sdk.constants.CONTENT_TYPE_JSON_CHARSET_UTF8;
     var payload = inp;
     kony.sdk.logsdk.info("unsubscribe uri:" + uri);
     var networkOptions = {};
     networkOptions[kony.sdk.constants.DISABLE_INTEGRITY] = true;
     kony.sdk.logsdk.perf("Executing unregisterFromMessagingService's network call");
     networkProvider.post(uri, payload, headers, function(data) {
       kony.sdk.logsdk.perf("Executing finished unregisterFromMessagingService's network success");
       kony.sdk.dataStore.removeItem(dsKey_KSID);
       kony.sdk.dataStore.removeItem(dsKey_authToken);
       kony.sdk.verifyAndCallClosure(successCallback, data);
     }, function(data, status, error) {
       kony.sdk.logsdk.perf("Executing finished unregisterFromMessagingService's network failure");
       kony.sdk.logsdk.error("ERROR: Failed to unregister device for KMS");
       var errorObj = {};
       errorObj.data = data;
       errorObj.status = status;
       errorObj.error = error;
       kony.sdk.verifyAndCallClosure(failureCallback, errorObj);
     }, kony.sdk.constants.CONTENT_TYPE_JSON, networkOptions);
   };
   /**
    * unregister to messaging service
    * @param {dictionary} options - {authToken: <Auth Token>}
    * @param {function} successCallback - Callback method on success
    * @param {function} failureCallback - Callback method on failure
    */
   this.unregister = function(successCallback, failureCallback, options) {
     kony.sdk.logsdk.perf("Executing unregister");
     var tempKSID = currentObject.getKSID();
     var authToken = null;
     if (typeof(tempKSID) === 'undefined' || tempKSID === null) {
       kony.sdk.logsdk.perf("Executing finished unregister with exception");
       throw new Exception(kony.sdk.errorConstants.MESSAGING_FAILURE, "KSID not available, Register and try again.");
     }
     authToken = currentObject.getAuthToken(options);
     unregisterFromMessagingService(authToken, function(res) {
       kony.sdk.logsdk.perf("Executing finished unregister with success");
       successCallback(res);
     }, function(err) {
       kony.sdk.logsdk.perf("Executing finished unregister with failure");
       failureCallback(err);
     });
   };
   /**
    * unregister to messaging service
    * @param {string} authToken - Authorization Token
    * @param {function} successCallback - Callback method on success
    * @param {function} failureCallback - Callback method on failure
    */
   /**
    * @deprecated This method is deprecated because authToken can be given as input through options param of
    * unregister method.
    */
   this.unregisterWithAuthToken = function(authToken, successCallback, failureCallback) {
     kony.sdk.logsdk.perf("Executing unregisterWithAuthToken");
     var tempKSID = currentObject.getKSID();
     if (typeof(tempKSID) === 'undefined' || tempKSID === null) {
       kony.sdk.logsdk.perf("Executing finished unregisterWithAuthToken with execption");
       throw new Exception(kony.sdk.errorConstants.MESSAGING_FAILURE, "KSID not available, Register and try again.");
     }
     if (typeof(authToken) === 'undefined' || authToken === null) {
       kony.sdk.logsdk.perf("Executing finished unregisterWithAuthToken with execption");
       throw new Exception(kony.sdk.errorConstants.MESSAGING_FAILURE, "Invalid authToken.");
     }
     unregisterFromMessagingService(authToken, function(res) {
       kony.sdk.logsdk.perf("Executing finished unregisterWithAuthToken with success");
       successCallback(res);
     }, function(err) {
       kony.sdk.logsdk.perf("Executing finished unregisterWithAuthToken with failure");
       failureCallback(err);
     });
   };
   /**
    * Fetch all messages
    * @param {number} startIndex - starting index
    * @param {number} pageSize - page size
    * @param {function} successCallback - Callback method on success
    * @param {function} failureCallback - Callback method on failure
    * @param {dictionary} options - {authToken: <Auth Token>}
    */
   this.fetchAllMessages = function(startIndex, pageSize, successCallback, failureCallback, options) {
     kony.sdk.logsdk.perf("Executing fetchAllMessages");
     var tempKSID = currentObject.getKSID();
     if (typeof(tempKSID) === 'undefined' || tempKSID === null) {
       throw new Exception(kony.sdk.errorConstants.MESSAGING_FAILURE, "KSID not available, Register and try again.");
     }
     var uri = homeUrl + "/messages/fetch";
     var data = {
       "ksid": tempKSID,
       "startElement": startIndex,
       "elementsPerPage": pageSize
     };
     data[kony.sdk.constants.AUTH_TOKEN] = currentObject.getAuthToken(options);
     var headers = kony.sdk.getDefaultHeaders();
     headers[kony.sdk.constants.HTTP_CONTENT_HEADER] = kony.sdk.constants.CONTENT_TYPE_JSON_CHARSET_UTF8;
     var payload = data;
     var networkOptions = {};
     networkOptions[kony.sdk.constants.DISABLE_INTEGRITY] = true;
     kony.sdk.logsdk.perf("Executing fetchAllMessages's network call");
     networkProvider.post(uri, payload, headers, function(data) {
       kony.sdk.logsdk.perf("Executing finished fetchAllMessages's network call with success");
       overrideAuthToken(options);
       kony.sdk.verifyAndCallClosure(successCallback, data);
     }, function(errorObj) {
       kony.sdk.logsdk.perf("Executing finished fetchAllMessages's network call with failure");
       kony.sdk.logsdk.error("FetchAllMessages :: FetchAllMessages for messaging service failed with error", errorObj);
       kony.sdk.verifyAndCallClosure(failureCallback, errorObj);
     }, kony.sdk.constants.CONTENT_TYPE_JSON, networkOptions);
   };
   var updateGeoLocationForMessagingService = function(latitude, longitude, locationName, authToken, successCallback, failureCallback) {
     kony.sdk.logsdk.perf("Executing updateGeoLocationForMessagingService");
     var uri = homeUrl + "/location";
     var data = {
       "ksid": currentObject.getKSID(),
       "latitude": latitude,
       "longitude": longitude
     };
     if (typeof(locationName) === "string") {
       data["locname"] = locationName;
     }
     if (authToken != null && authToken != undefined) {
       data[kony.sdk.constants.AUTH_TOKEN] = authToken;
     }
     var headers = kony.sdk.getDefaultHeaders();
     headers[kony.sdk.constants.HTTP_CONTENT_HEADER] = kony.sdk.constants.CONTENT_TYPE_JSON_CHARSET_UTF8;
     var payload = data;
     var networkOptions = {};
     networkOptions[kony.sdk.constants.DISABLE_INTEGRITY] = true;
     kony.sdk.logsdk.perf("Executing updateGeoLocationForMessagingService's network call");
     networkProvider.post(uri, payload, headers, function(data) {
       //override data store auth token with user given token
       kony.sdk.logsdk.perf("Executing finished updateGeoLocationForMessagingService with network success");
       currentObject.setAuthToken(authToken);
       kony.sdk.verifyAndCallClosure(successCallback, data);
     }, function(errorObj) {
       kony.sdk.logsdk.perf("Executing finished updateGeoLocationForMessagingService with network failure");
       kony.sdk.logsdk.error("UpdateGeoLocation :: UpdateGeoLocation for messaging service failed with error", errorObj);
       kony.sdk.verifyAndCallClosure(failureCallback, errorObj);
     }, kony.sdk.constants.CONTENT_TYPE_JSON, networkOptions);
   };
   /**
    * Update the location
    * @param {string} latitude - Latitude value
    * @param {string} longitude - Longitude value
    * @param {string} locationName - Location name
    * @param {function} successCallback - Callback method on success
    * @param {function} failureCallback - Callback method on failure
    * @param {dictionary} options - {authToken: <Auth Token>}
    */
   this.updateGeoLocation = function(latitude, longitude, locationName, successCallback, failureCallback, options) {
     kony.sdk.logsdk.perf("Executing updateGeoLocation");
     var tempKSID = currentObject.getKSID();
     var authToken = null;
     if (typeof(tempKSID) === 'undefined' || tempKSID === null) {
       kony.sdk.logsdk.perf("Executing finished updateGeoLocation with execption");
       throw new Exception(kony.sdk.errorConstants.MESSAGING_FAILURE, "KSID not available, Register and try again.");
     }
     if (typeof(latitude) === 'undefined' || latitude === null) {
       kony.sdk.logsdk.perf("Executing finished updateGeoLocation with execption");
       throw new Exception(kony.sdk.errorConstants.MESSAGING_FAILURE, "Invalid latitude.");
     }
     if (typeof(longitude) === 'undefined' || longitude === null) {
       kony.sdk.logsdk.perf("Executing finished updateGeoLocation with execption");
       throw new Exception(kony.sdk.errorConstants.MESSAGING_FAILURE, "Invalid longitude.");
     }
     authToken = currentObject.getAuthToken(options);
     updateGeoLocationForMessagingService(latitude, longitude, locationName, authToken, function(res) {
       kony.sdk.logsdk.perf("Executing finished updateGeoLocation with success");
       successCallback(res);
     }, function(err) {
       kony.sdk.logsdk.perf("Executing finished updateGeoLocation with failure");
       failureCallback(err);
     });
   };
   /**
    * Update the location
    * @param {string} latitude - Latitude value
    * @param {string} longitude - Longitude value
    * @param {string} locationName - Location name
    * @param {string} authToken - Authorization Token
    * @param {function} successCallback - Callback method on success
    * @param {function} failureCallback - Callback method on failure
    */
   /**
    * @deprecated This method is deprecated because authToken can be given as a input through options param of
    * updateGeoLocation method
    */
   this.updateGeoLocationWithAuthToken = function(latitude, longitude, locationName, authToken, successCallback, failureCallback) {
     kony.sdk.logsdk.perf("Executing updateGeoLocationWithAuthToken");
     var tempKSID = currentObject.getKSID();
     if (typeof(tempKSID) === 'undefined' || tempKSID === null) {
       kony.sdk.logsdk.perf("Executing finshed updateGeoLocationWithAuthToken with exception");
       throw new Exception(kony.sdk.errorConstants.MESSAGING_FAILURE, "KSID not available, Register and try again.");
     }
     if (typeof(latitude) === 'undefined' || latitude === null) {
       kony.sdk.logsdk.perf("Executing finshed updateGeoLocationWithAuthToken with exception");
       throw new Exception(kony.sdk.errorConstants.MESSAGING_FAILURE, "Invalid latitude.");
     }
     if (typeof(longitude) === 'undefined' || longitude === null) {
       kony.sdk.logsdk.perf("Executing finshed updateGeoLocationWithAuthToken with exception");
       throw new Exception(kony.sdk.errorConstants.MESSAGING_FAILURE, "Invalid longitude.");
     }
     if (typeof(authToken) === 'undefined' || authToken === null) {
       kony.sdk.logsdk.perf("Executing finshed updateGeoLocationWithAuthToken with exception");
       throw new Exception(kony.sdk.errorConstants.MESSAGING_FAILURE, "Invalid authToken.");
     }
     updateGeoLocationForMessagingService(latitude, longitude, locationName, authToken, function(res) {
       kony.sdk.logsdk.perf("Executing finished updateGeoLocationWithAuthToken with success");
       successCallback(res);
     }, function(err) {
       kony.sdk.logsdk.perf("Executing finished updateGeoLocationWithAuthToken with failure");
       failureCallback(err);
     });
   };
   /**
    * Mark the message as read for a given message id
    * @param {string} fetchId - Message id
    * @param {function} successCallback - Callback method on success
    * @param {function} failureCallback - Callback method on failure
    * @param {dictionary} options - {authToken: <Auth Token>}
    */
   this.markMessageRead = function(fetchId, successCallback, failureCallback, options) {
     kony.sdk.logsdk.perf("Executing markMessageRead");
     if (typeof(fetchId) === 'undefined' || fetchId === null) {
       kony.sdk.logsdk.perf("Executing finshed markMessageRead with exception");
       throw new Exception(kony.sdk.errorConstants.MESSAGING_FAILURE, "Invalid FetchId, it cannot be null");
     }
     var headers = kony.sdk.getDefaultHeaders();
     headers["X-HTTP-Method-Override"] = "get";
     headers[kony.sdk.constants.HTTP_CONTENT_HEADER] = kony.sdk.constants.CONTENT_TYPE_JSON_CHARSET_UTF8;
     var uri = homeUrl + "/messages/open/" + fetchId;
     headers[kony.sdk.constants.DEVICE_AUTHTOKEN_HEADER] = currentObject.getAuthToken(options);
     var networkOptions = {};
     networkOptions[kony.sdk.constants.DISABLE_INTEGRITY] = true;
     kony.sdk.logsdk.perf("Executing markMessageRead's network call");
     networkProvider.get(uri, null, headers, function(data) {
       //override data store auth token with user given token
       kony.sdk.logsdk.perf("Executing finished markMessageRead with network success");
       overrideAuthToken(options);
       kony.sdk.verifyAndCallClosure(successCallback, data);
     }, function(errorObj) {
       kony.sdk.logsdk.perf("Executing finished markMessageRead with network failure");
       kony.sdk.logsdk.error("MarkMessageRead :: MarkMessageRead for messaging service failed with error", errorObj);
       kony.sdk.verifyAndCallClosure(failureCallback, errorObj);
     }, null, networkOptions);
   };
   /**
    * Fetches the message conetent for a given message id
    * @param {string} fetchId - Message id
    * @param {function} successCallback - Callback method on success
    * @param {function} failureCallback - Callback method on failure
    * @param {dictionary} options - {authToken: <Auth Token>}
    */
   this.fetchMessageContent = function(fetchId, successCallback, failureCallback, options) {
     kony.sdk.logsdk.perf("Executing fetchMessageContent");
     if (typeof(fetchId) === 'undefined' || fetchId === null) {
       throw new Exception(kony.sdk.errorConstants.MESSAGING_FAILURE, "Invalid FetchId, it cannot be null");
     }
     var uri = homeUrl + "/messages/content/" + fetchId;
     var headers = kony.sdk.getDefaultHeaders();
     headers[kony.sdk.constants.DEVICE_AUTHTOKEN_HEADER] = currentObject.getAuthToken(options);
     var networkOptions = {};
     networkOptions[kony.sdk.constants.DISABLE_INTEGRITY] = true;
     kony.sdk.logsdk.perf("Executing fetchMessageContent's network call");
     networkProvider.get(uri, null, headers, function(data) {
       //override data store auth token with user given token
       kony.sdk.logsdk.perf("Executing finished fetchMessageContent with network success");
       overrideAuthToken(options);
       kony.sdk.verifyAndCallClosure(successCallback, data);
     }, function(errorObj) {
       kony.sdk.logsdk.perf("Executing finished fetchMessageContent with network failure");
       kony.sdk.logsdk.error("FetchMessageContent :: FetchMessageContent for messaging service failed with error", errorObj);
       kony.sdk.verifyAndCallClosure(failureCallback, errorObj);
     }, null, networkOptions);
   };
   /**
    * subscribeAudience to create a audience for subscribed device
    * @param {string} firstName - audience firstName
    * @param {string} lastName - audience lastName
    * @param {string} emailId - audience emailId
    * @param {string} mobileNumber - audience mobileNumber
    * @param {string} country - country
    * @param {string} state - state
    * @param {Object] options - {authToken: <Auth Token>} and user defined attributes like PAN no,SSN.
    * @param {function} successCallback - Callback method on success
    * @param {function} failureCallback - Callback method on failure
    */
   this.subscribeAudience = function(firstName, lastName, emailId, mobileNumber, country, state, successCallback, failureCallback, options) {
     kony.sdk.logsdk.perf("Executing subscribeAudience");
     if (kony.sdk.isNullOrUndefined(KSID)) {
       kony.sdk.logsdk.perf("Executing finished subscribeAudience wih an exception");
       throw new Exception(kony.sdk.errorConstants.MESSAGING_FAILURE, "Register for messaging service before creating or updating");
     }
     if (kony.sdk.isNullOrUndefined(firstName)) {
       kony.sdk.logsdk.perf("Executing finished subscribeAudience wih an exception");
       throw new Exception(kony.sdk.errorConstants.MESSAGING_FAILURE, "Invalid first name, it cannot be null");
     }
     if (kony.sdk.isNullOrUndefined(lastName)) {
       kony.sdk.logsdk.perf("Executing finished subscribeAudience wih an exception");
       throw new Exception(kony.sdk.errorConstants.MESSAGING_FAILURE, "Invalid last name, it cannot be null");
     }
     if (kony.sdk.isNullOrUndefined(mobileNumber)) {
       kony.sdk.logsdk.perf("Executing finished subscribeAudience wih an exception");
       throw new Exception(kony.sdk.errorConstants.MESSAGING_FAILURE, "Invalid mobile number, it cannot be null");
     }
     if (kony.sdk.isNullOrUndefined(emailId)) {
       kony.sdk.logsdk.perf("Executing finished subscribeAudience wih an exception");
       throw new Exception(kony.sdk.errorConstants.MESSAGING_FAILURE, "Invalid email Id, it cannot be null");
     }
     if (kony.sdk.isNullOrUndefined(country)) {
       kony.sdk.logsdk.perf("Executing finished subscribeAudience wih an exception");
       throw new Exception(kony.sdk.errorConstants.MESSAGING_FAILURE, "Invalid country, it cannot be null");
     }
     subscribeAudienceOrUpdate(firstName, lastName, emailId, mobileNumber, country, state, options, function(res) {
       kony.sdk.logsdk.perf("Executing finished subscribeAudience with success");
       successCallback(res);
     }, function(err) {
       kony.sdk.logsdk.perf("Executing finished subscribeAudience with failure");
       failureCallback(err);
     });
   };
   /**
    * delete subscribed audience
    * @param {function} successCallback - Callback method on success
    * @param {function} failureCallback - Callback method on failure
    * @param {dictionary} options - {authToken: <Auth Token>}
    **/
   this.unSubscribeAudience = function(successCallback, failureCallback, options) {
     kony.sdk.logsdk.perf("Executing unSubscribeAudience");
     if (kony.sdk.isNullOrUndefined(KSID)) {
       kony.sdk.logsdk.perf("Executing finished unSubscribeAudience with an exception");
       throw new Exception(kony.sdk.errorConstants.MESSAGING_FAILURE, "Register for messaging service before unsubscribe audience");
     }
     var uri = homeUrl + kony.sdk.constants.SUBSCRIBE_AUDIENCE + "/" + KSID;
     var headers = kony.sdk.getDefaultHeaders();
     headers[kony.sdk.constants.HTTP_OVERRIDE_HEADER] = kony.sdk.constants.HTTP_METHOD_DELETE;
     headers[kony.sdk.constants.DEVICE_AUTHTOKEN_HEADER] = currentObject.getAuthToken(options);
     var networkOptions = {};
     networkOptions[kony.sdk.constants.DISABLE_INTEGRITY] = true;
     kony.sdk.logsdk.perf("Executing unSubscribeAudience's network call");
     networkProvider.post(uri, null, headers, function(data) {
       //override data store auth token with user given token
       kony.sdk.logsdk.perf("Executing finished unSubscribeAudience with network success");
       overrideAuthToken(options);
       kony.sdk.verifyAndCallClosure(successCallback, data);
     }, function(err) {
       kony.sdk.logsdk.perf("Executing finished unSubscribeAudience with network failure");
       kony.sdk.logsdk.error("MessagingService::unSubscribeAudience failed to unsubscribe audience", err);
       kony.sdk.verifyAndCallClosure(failureCallback, err);
     }, null, networkOptions);
   };
   /*
    * get subscribed audience details
    * @param {function} successCallback - Callback method on success
    * @param {function} failureCallback - Callback method on failure
    * @param {dictionary} options - {authToken: <Auth Token>}
    */
   this.getSubscribedAudienceDetails = function(successCallback, failureCallback, options) {
     kony.sdk.logsdk.perf("Executing getSubscribedAudienceDetails");
     if (kony.sdk.isNullOrUndefined(KSID)) {
       kony.sdk.logsdk.perf("Executing finished getSubscribedAudienceDetails with an exception");
       throw new Exception(kony.sdk.errorConstants.MESSAGING_FAILURE, "Register for messaging service before get subscribed audience details");
     }
     var uri = homeUrl + kony.sdk.constants.SUBSCRIBE_AUDIENCE + "/" + KSID;
     var headers = kony.sdk.getDefaultHeaders();
     headers[kony.sdk.constants.HTTP_OVERRIDE_HEADER] = kony.sdk.constants.HTTP_METHOD_GET;
     headers[kony.sdk.constants.DEVICE_AUTHTOKEN_HEADER] = currentObject.getAuthToken(options);
     var networkOptions = {};
     networkOptions[kony.sdk.constants.DISABLE_INTEGRITY] = true;
     kony.sdk.logsdk.perf("Executing getSubscribedAudienceDetails's network call");
     networkProvider.get(uri, null, headers, function(data) {
       //override data store auth token with user given token
       kony.sdk.logsdk.perf("Executing finished getSubscribedAudienceDetails with network success");
       overrideAuthToken(options);
       kony.sdk.verifyAndCallClosure(successCallback, data);
     }, function(err) {
       kony.sdk.logsdk.perf("Executing finished getSubscribedAudienceDetails with network failure");
       kony.sdk.logsdk.error("MessagingService::getSubscribedAudienceDetails failed to get audience details", err);
       kony.sdk.verifyAndCallClosure(failureCallback, err);
     }, null, networkOptions);
   }
   /*
    * get rich push content
    * @param pushId {string} - pushId for getting rich push content.Which we get after registering
    * for push notifications.
    * @param {function} successCallback - Callback method on success
    * @param {function} failureCallback - Callback method on failure
    * @param {dictionary} options - {authToken: <Auth Token>}
    */
   this.getRichPushContent = function(pushId, successCallback, failureCallback, options) {
     kony.sdk.logsdk.perf("Executing getRichPushContent");
     if (kony.sdk.isNullOrUndefined(KSID)) {
       throw new Exception(kony.sdk.errorConstants.MESSAGING_FAILURE, "Register for messaging service to get rich push content");
     }
     if (kony.sdk.isNullOrUndefined(pushId)) {
       throw new Exception(kony.sdk.errorConstants.MESSAGING_FAILURE, "Invalid PushId,it cannot be null");
     }
     var uri = homeUrl + kony.sdk.constants.RICH_PUSH_MESSAGE + pushId;
     var headers = kony.sdk.getDefaultHeaders();
     headers[kony.sdk.constants.HTTP_OVERRIDE_HEADER] = kony.sdk.constants.HTTP_METHOD_GET;
     headers[kony.sdk.constants.DEVICE_AUTHTOKEN_HEADER] = currentObject.getAuthToken(options);
     var networkOptions = {};
     networkOptions[kony.sdk.constants.DISABLE_INTEGRITY] = true;
     kony.sdk.logsdk.perf("Executing getRichPushContent's network call");
     networkProvider.get(uri, null, headers, function(data) {
       //override data store auth token with user given token
       kony.sdk.logsdk.perf("Executing finished getRichPushContent with network success");
       overrideAuthToken(options);
       kony.sdk.verifyAndCallClosure(successCallback, data);
     }, function(err) {
       kony.sdk.logsdk.perf("Executing finished getRichPushContent with network failure");
       kony.sdk.logsdk.error("MESSAGING SERVICE :: getRichPushContent failed to get rich content with error", err);
       kony.sdk.verifyAndCallClosure(failureCallback, err);
     }, null, networkOptions);
   };
   /*
    * Update the list of beacons
    * @param {string} uuId - Universally Unique Identifier to identify a beacon in a network
    * @param {string} major - major id to identity and distinguish a group
    * @param {string} minor - distinguishing individual beacons within a group of beacons assigned a major value.
    * @param {function} successCallback - Callback method called on success.
    * @param {function} failureCallback - Callback method called on failure.
    * @param {object} options - options which accepts optional parameters such as ufid,appid and {authToken: <Auth Token>}
    */
   this.updateListOfBeacons = function(uuId, major, minor, successCallback, failureCallback, options) {
     kony.sdk.logsdk.perf("Executing updateListOfBeacons");
     if (kony.sdk.isNullOrUndefined(KSID)) {
       kony.sdk.logsdk.perf("Executing finished updateListOfBeacons due to an exception");
       throw new Exception(kony.sdk.errorConstants.MESSAGING_FAILURE, "Register for messaging service before updating list of beacons");
     }
     if (kony.sdk.isNullOrUndefined(uuId)) {
       kony.sdk.logsdk.perf("Executing finished updateListOfBeacons due to an exception");
       throw new Exception(kony.sdk.errorConstants.MESSAGING_FAILURE, "Invalid UUID,it cannot be null");
     }
     if (kony.sdk.isNullOrUndefined(major)) {
       kony.sdk.logsdk.perf("Executing finished updateListOfBeacons due to an exception");
       throw new Exception(kony.sdk.errorConstants.MESSAGING_FAILURE, "Invalid major,it cannot be null");
     }
     if (kony.sdk.isNullOrUndefined(minor)) {
       kony.sdk.logsdk.perf("Executing finished updateListOfBeacons due to an exception");
       throw new Exception(kony.sdk.errorConstants.MESSAGING_FAILURE, "Invalid minor,it cannot be null");
     }
     var uri = homeUrl + kony.sdk.constants.BEACON_UPDATE;
     var payload = {};
     payload[kony.sdk.constants.KSID] = KSID;
     var beaconsList = {};
     //beacon object has beacon details like uuid,major and minor
     var beacon = {};
     beacon["uuid"] = uuId;
     beacon["major"] = major;
     beacon["minor"] = minor;
     beaconsList["beacon"] = beacon;
     payload["beacons"] = beaconsList;
     payload[kony.sdk.constants.AUTH_TOKEN] = currentObject.getAuthToken(options);
     //appid and ufid are optional
     if (options && options["ufid"]) {
       payload["ufid"] = options["ufid"];
     }
     if (options && options["appid"]) {
       payload["appid"] = options["appid"];
     }
     var data = payload;
     var headers = kony.sdk.getDefaultHeaders();
     headers[kony.sdk.constants.HTTP_CONTENT_HEADER] = kony.sdk.constants.CONTENT_TYPE_JSON_CHARSET_UTF8;
     var networkOptions = {};
     networkOptions[kony.sdk.constants.DISABLE_INTEGRITY] = true;
     kony.sdk.logsdk.perf("Executing updateListOfBeacons's network call");
     networkProvider.post(uri, data, headers, function(data) {
       //override data store auth token with user given token
       kony.sdk.logsdk.perf("Executing finished updateListOfBeacons with network success");
       overrideAuthToken(options);
       kony.sdk.verifyAndCallClosure(successCallback, data);
     }, function(err) {
       kony.sdk.logsdk.perf("Executing finished updateListOfBeacons with network failure");
       kony.sdk.logsdk.error("MESSAGING SERVICE :: updateListOfBeacons failed to update with error", err);
       kony.sdk.verifyAndCallClosure(failureCallback, err);
     }, kony.sdk.constants.CONTENT_TYPE_JSON, networkOptions);
   };
   /*
    * Utility method to override datastore authtoken with user given auth token.
    */
   var overrideAuthToken = function(options) {
     var authToken;
     if (options && options[kony.sdk.constants.AUTH_TOKEN]) {
       currentObject.setAuthToken(options[kony.sdk.constants.AUTH_TOKEN]);
     }
   };
 }
 /**
  * Method to create the Metrics service instance with the provided service name.
  * @returns {MetricsService} Metrics service instance
  */
 kony.sdk.prototype.getMetricsService = function() {
   if (!kony.sdk.isInitialized) {
     throw new Exception(kony.sdk.errorConstants.INIT_FAILURE, kony.sdk.constants.INIT_FAILURE_MESSAGE + " Metrics service.");
   }
   if (!kony.sdk.isLicenseUrlAvailable) {
     throw new Exception(kony.sdk.errorConstants.METRICS_FAILURE, "metrics is not enabled");
   }
   //var metricsServiceObject = null;
   if (this.metricsServiceObject) {
     return this.metricsServiceObject;
   }
   if (this.internalSdkObject) {
     //framework implementation
     this.metricsServiceObject = this.internalSdkObject.getMetricsService();
   } else {
     //sdk local implementation
     this.metricsServiceObject = new MetricsService(this);
   }
   return this.metricsServiceObject;
 };
 /**
  * Should not be called by the developer.
  * @class
  * @classdesc Metrics service instance for invoking the Metrics services.
  */
 function MetricsService(konyRef) {
   var url = konyRef.customReportingURL;
   if (typeof(url) === 'undefined') {
     throw new Exception(kony.sdk.errorConstants.METRICS_FAILURE, "reporting url is undefined");
   }
   var networkProvider = new konyNetworkProvider();
   /**
    * invoke the getUserId operation
    */
   this.getUserId = function() {
     return konyRef.getUserId();
   };
   //start of event api
   var eventFlowTag = "";
   var eventBufferMaxValue = 1000;
   var eventBufferAutoFlushValue = 15;
   var characterLengthLimit = 256;
   var eventConfig = {
     "confType": "BUFFER",
     "eventBufferAutoFlushCount": eventBufferAutoFlushValue,
     "eventBufferMaxCount": eventBufferMaxValue
   };
   var reportEventBufferArray = [];
   var reportEventBufferBackupArray = [];
   var retrievedDS = false;
   var eventBufferCount = 0;
   var eventTypeMap = {
     "formentry": "FormEntry",
     "formexit": "FormExit",
     "touch": "Touch",
     "servicerequest": "ServiceRequest",
     "serviceresponse": "ServiceResponse",
     "gesture": "Gesture",
     "orientation": "Orientation",
     "error": "Error",
     "exception": "Exception",
     "crash": "Crash",
     "custom": "Custom",
     "servicecall": "ServiceCall",
     "apptransition": "AppTransition",
     "appload": "AppLoad",
     "component": "Component"
   };
   var errorCodeMap = {
     "1000": true,
     "1011": true,
     "1012": true,
     "1014": true,
     "1015": true,
     "1016": true
   };
   /**
    * This method will take the a String to set a Flow Tag for the reported events.
    * @param {string} flowTag - sets flow tag for reporting the events.
    */
   this.setFlowTag = function(flowTag) {
     if (kony.sdk.isNullOrUndefined(flowTag)) {
       throw new Exception(kony.sdk.errorConstants.METRICS_FAILURE, "Invalid value for event flow tag");
     } else if (flowTag.length <= characterLengthLimit) {
       eventFlowTag = flowTag;
     } else {
       throw new Exception(kony.sdk.errorConstants.METRICS_FAILURE, "Length exceeded, Maximum length of event flow tag is " + characterLengthLimit + " characters");
     }
   };
   /**
    * This method will clear the flow tag set by the user previously.
    */
   this.clearFlowTag = function() {
     eventFlowTag = "";
   };
   /**
    * This method will return the a String to set a Flow Tag for the reported events.
    * @return {string} flowTag - flow tag set by the user for reporting the events.
    */
   this.getFlowTag = function() {
     return eventFlowTag;
   };
   /**
    * This method will take the required values to set the event Configuration values.
    * @param {string} confType - sets the Current Configuration Type
    * 					possible values BUFFER or INSTANT.
    * @param {number} eventBufferAutoFlushCount - event buffer count to auto flush the events
    * 								possible values any positive integer
    * 								Default value 15
    * @param {number} eventBufferMaxCount - Maximum event buffer count to store the events
    * 								possible values any positive integer
    * 								Default value 1000
    */
   this.setEventConfig = function(confType, eventBufferAutoFlushCount, eventBufferMaxCount) {
     if (kony.sdk.isNullOrUndefined(confType)) {
       throw new Exception(kony.sdk.errorConstants.METRICS_FAILURE, "Config Type can not be null");
     } else {
       confType = confType.toUpperCase();
     }
     if (confType === "BUFFER") {
       eventConfig["confType"] = confType;
     } else {
       throw new Exception(kony.sdk.errorConstants.METRICS_FAILURE, "Invalid value for config type");
     }
     if (!kony.sdk.isNullOrUndefined(eventBufferMaxCount) && typeof(eventBufferMaxCount) === "number" && eventBufferMaxCount > 0) {
       eventConfig["eventBufferMaxCount"] = eventBufferMaxCount;
     } else {
       throw new Exception(kony.sdk.errorConstants.METRICS_FAILURE, "eventBufferMaxCount has to be a Number and greater than 0");
     }
     if (!kony.sdk.isNullOrUndefined(eventBufferAutoFlushCount) && typeof(eventBufferAutoFlushCount) === "number" && eventBufferAutoFlushCount > 0 && eventBufferAutoFlushCount <= eventBufferMaxCount) {
       eventConfig["eventBufferAutoFlushCount"] = eventBufferAutoFlushCount;
     } else if (eventBufferAutoFlushCount >= eventBufferMaxCount) {
       eventConfig["eventBufferMaxCount"] = 1000;
       throw new Exception(kony.sdk.errorConstants.METRICS_FAILURE, "eventBufferAutoFlushCount can not be greater than eventBufferMaxCount");
     } else {
       throw new Exception(kony.sdk.errorConstants.METRICS_FAILURE, "eventBufferAutoFlushCount has to be a Number and greater than 0");
     }
   };
   /**
    * This method takes the event details from the developer and schedule it for sending to server as per Configuration values set by the developer.
    * @param {string} evttype - Event Type for the reported event.
    * @param {string} evtSubType - string literal for eventSubType(max 256 Chars)
    * @param {string} formID -   string literal for formID(max 256 Chars)
    * @param {string} widgetID - string literal for widgetID(max 256 Chars)
    * @param {string} flowTag - string literal to override flow tag (max 256 Chars)
    * @param {string} metaData - string to describe metaData
    * @throws Exception
    */
   this.sendEvent = function(evttype, evtSubType, formID, widgetID, flowTag, metaData) {
     if (reportEventBufferBackupArray.length === 0) {
       this.readFromDS();
     }
     eventBufferCount = reportEventBufferBackupArray.length + reportEventBufferArray.length;
     if (eventBufferCount === eventConfig["eventBufferMaxCount"]) {
       kony.sdk.logsdk.warn("Reached maximum limit of '" + eventBufferCount + "' events in buffer, No more events will be stored");
       return;
     }
     var reportEventMap = {};
     reportEventMap.ts = kony.sdk.formatCurrentDate(new Date());
     evttype = evttype.toLowerCase();
     if (kony.sdk.isNullOrUndefined(eventTypeMap[evttype])) {
       throw new Exception(kony.sdk.errorConstants.METRICS_FAILURE, "Invalid value for event type");
     } else {
       reportEventMap["evttype"] = eventTypeMap[evttype];
     }
     if (kony.sdk.isNullOrUndefined(evtSubType)) {
       reportEventMap["evtSubType"] = "";
     } else if (evtSubType.length <= characterLengthLimit) {
       reportEventMap["evtSubType"] = evtSubType;
     } else {
       throw new Exception(kony.sdk.errorConstants.METRICS_FAILURE, "Length exceeded, Maximum length of event evtSubType is " + characterLengthLimit + " characters");
     }
     if (kony.sdk.isNullOrUndefined(formID)) {
       reportEventMap["formID"] = kony.application.getCurrentForm().id;
     } else if (formID.length <= characterLengthLimit) {
       reportEventMap["formID"] = formID;
     } else {
       throw new Exception(kony.sdk.errorConstants.METRICS_FAILURE, "Length exceeded, Maximum length of event formID is " + characterLengthLimit + " characters");
     }
     if (kony.sdk.isNullOrUndefined(widgetID)) {
       reportEventMap["widgetID"] = "";
     } else if (widgetID.length <= characterLengthLimit) {
       reportEventMap["widgetID"] = widgetID;
     } else {
       throw new Exception(kony.sdk.errorConstants.METRICS_FAILURE, "Length exceeded, Maximum length of event widgetID is " + characterLengthLimit + " characters");
     }
     if (kony.sdk.isNullOrUndefined(flowTag)) {
       reportEventMap["flowTag"] = this.getFlowTag();
     } else if (flowTag.length <= characterLengthLimit) {
       reportEventMap["flowTag"] = flowTag;
     } else {
       throw new Exception(kony.sdk.errorConstants.METRICS_FAILURE, "Length exceeded, Maximum length of event flowTag is " + characterLengthLimit + " characters");
     }
     reportEventMap.SID = this.getSessionId();
     reportEventMap.metaData = metaData;
     //checking each event data is a proper json or not
     // 	throw new Exception(kony.sdk.errorConstants.METRICS_FAILURE, "Invalid json string passed for events data");
     // }
     reportEventBufferArray.push(reportEventMap);
     if (reportEventBufferArray.length % eventConfig["eventBufferAutoFlushCount"] === 0 || evttype == eventTypeMap.crash) {
       this.flushEvents();
     }
   };
   /**
    * This method will send the buffered events to the server at once.
    */
   this.flushEvents = function() {
     var url = kony.sdk.currentInstance.customReportingURL;
     var ref = this;
     if (reportEventBufferBackupArray.length === 0) {
       ref.readFromDS();
     }
     if (reportEventBufferBackupArray.length === 0 && reportEventBufferArray.length === 0) {
       kony.sdk.logsdk.warn("There are no events to flush");
       return;
     }
     var payload = kony.sdk.getPayload(kony.sdk.getCurrentInstance());
     var params = {};
     if (reportEventBufferArray.length !== 0) {
       ref.pushEventsToBufferArray();
     }
     var headers = kony.sdk.getDefaultHeaders();
     headers[kony.sdk.constants.HTTP_CONTENT_HEADER] = kony.sdk.constants.CONTENT_TYPE_FORM_URL_ENCODED_CHARSET_UTF8;
     payload.events = reportEventBufferBackupArray;
     payload.svcid = "SendEvents";
     payload.rsid = this.getSessionId();
     params[kony.sdk.constants.REPORTING_PARAMS] = JSON.stringify(payload);
     var options = {};
     options[kony.sdk.constants.IGNORE_MESSAGE_INTEGRITY] = true;
     networkProvider.post(url, params, headers, flushSuccessCallback, flushErrorCallback, null, options);

     function flushSuccessCallback(response) {
       if (response.opstatus == 0) {
         ref.clearBufferEvents();
       } else if (errorCodeMap[response.opstatus]) {
         ref.saveInDS();
       } else {
         ref.clearBufferEvents();
       }
     }

     function flushErrorCallback(response) {
       kony.sdk.logsdk.error("Unable to flush events");
       kony.sdk.logsdk.info("Application Events: " + JSON.stringify(reportEventBufferBackupArray));
       ref.saveInDS();
     }
   };
   /*Stores event data in Data Store on failure of service Call*/
   this.saveInDS = function() {
     var eventsToSave = [];
     eventsToSave.push(JSON.stringify(reportEventBufferBackupArray));
     kony.ds.save(eventsToSave, "konyMetricsBuffer");
     reportEventBufferBackupArray = [];
   };
   /*Clearing events sent to server */
   this.clearBufferEvents = function() {
     reportEventBufferBackupArray = [];
     kony.ds.remove("konyMetricsBuffer");
   };
   /*Reading any pending events from Data Store */
   this.readFromDS = function() {
     var eventsFromDS = kony.ds.read("konyMetricsBuffer");
     if (eventsFromDS !== null) {
       var pushToArray = [];
       pushToArray.push(JSON.parse(eventsFromDS[0]));
       reportEventBufferBackupArray.push.apply(reportEventBufferBackupArray, pushToArray);
     }
   };
   /*Pushes events received from user to BufferBackupArray which will be flushed to server */
   this.pushEventsToBufferArray = function() {
     reportEventBufferBackupArray.push.apply(reportEventBufferBackupArray, reportEventBufferArray);
     reportEventBufferArray = [];
   };
   /**
    * This method will return the a List of the buffered events.
    * @return {object} events - list of events stored in buffer.
    */
   this.getEventsInBuffer = function() {
     var eventsFromDS = kony.ds.read("konyMetricsBuffer");
     var eventsToReturn = [];
     if (!kony.sdk.isNullOrUndefined(eventsFromDS)) {
       eventsToReturn.push(JSON.parse(eventsFromDS[0]));
     }
     if (reportEventBufferArray.length !== 0) {
       eventsToReturn.push.apply(eventsToReturn, reportEventBufferArray);
     }
     if (eventsToReturn.length !== 0) {
       return eventsToReturn;
     } else {
       return null;
     }
   };
   /**
    * invoke the sendCustomMetrics operation
    * @param {string} reportingGroupID - reporting Group ID
    * @param {object} metrics - metrics being reported
    */
   this.sendCustomMetrics = function(reportingGroupID, metrics) {
     if (typeof(metrics) !== "object") {
       throw new Exception(kony.sdk.errorConstants.METRICS_FAILURE, "Invalid type for metrics data.");
     }
     var reportData = kony.sdk.dataStore.getItem("konyCustomReportData");
     if (!reportData) {
       reportData = [];
     } else {
       reportData = JSON.parse(reportData);
     }
     kony.sdk.dataStore.removeItem("konyCustomReportData");
     var currentData = {};
     currentData.ts = kony.sdk.formatCurrentDate(new Date().toString());
     currentData.fid = reportingGroupID;
     currentData.metrics = metrics;
     currentData.rsid = this.getSessionId();
     reportData.push(currentData);
     //nyRef.getDataStore().setItem("konyCustomReportData",JSON.stringify(reportData));
     var payload = kony.sdk.getPayload(konyRef);
     if (kony.sdk.metric) {
       if (kony.sdk.metric.reportEventBufferBackupArray.length === 0) {
         kony.sdk.metric.readFromDS();
       }
       kony.sdk.metric.pushEventsToBufferArray();
       payload.events = kony.sdk.metric.reportEventBufferBackupArray;
     }
     payload.reportData = reportData;
     payload.rsid = this.getSessionId();
     payload.svcid = "CaptureKonyCustomMetrics";
     var newData = {};
     newData[kony.sdk.constants.REPORTING_PARAMS] = JSON.stringify(payload);
     var options = {};
     options[kony.sdk.constants.IGNORE_MESSAGE_INTEGRITY] = true;
     var headers = kony.sdk.getDefaultHeaders();
     headers[kony.sdk.constants.HTTP_CONTENT_HEADER] = kony.sdk.constants.CONTENT_TYPE_FORM_URL_ENCODED_CHARSET_UTF8;
     networkProvider.post(url, newData, headers, function(res) {
       //successcallback
       //konyRef.getDataStore().removeItem("konyCustomReportData");
       if (kony.sdk.metric) {
         kony.sdk.metric.clearBufferEvents();
       }
       kony.sdk.logsdk.info("metric data successfully sent" + JSON.stringify(res));
     }, function(res) {
       var storeData = kony.sdk.dataStore.getItem("konyCustomReportData");
       if (!storeData) {
         storeData = reportData;
       } else {
         storeData = JSON.parse(storeData);
         reportData.forEach(function(e) {
           storeData.push(e);
         });
       }
       if (kony.sdk.metric) {
         if (kony.sdk.metric.errorCodeMap[res.opstatus]) {
           kony.sdk.metric.saveInDS();
         }
       }
       kony.sdk.dataStore.setItem("konyCustomReportData", JSON.stringify(storeData));
       kony.sdk.logsdk.error("Unable to send metric report" + JSON.stringify(res));
     }, null, options);
   };
   /**
    * This method takes the event details from the developer and schedule it for sending to server as per Configuration values set by the developer.
    * @param {string} errorCode - errorCode of the reported error. Can be empty if not applicable
    * @param {string} errorType -   errorType of the reported error. Can be empty if not applicable
    * @param {string} errorMessage - errorMessage of the reported error. Can be empty if not applicable
    * @param {json} errorDetails - errorDetails of the reported error as a json string that can have key-value pairs for the following
   				keys errfile, errmethod, errline, errstacktrace, formID, widgetID, flowTag.
    * @throws Exception
    */
   this.reportError = function(errorCode, errorType, errorMessage, errorDetails) {
     var metaData = {};
     metaData.errcode = errorCode ? errorCode : "";
     metaData.errmsg = errorMessage ? errorMessage : "";
     if (errorDetails && kony.sdk.isJson(errorDetails)) {
       errorDetails = JSON.parse(errorDetails);
       metaData.errfile = errorDetails.errfile ? errorDetails.errfile : "";
       metaData.errmethod = errorDetails.errmethod ? errorDetails.errmethod : "";
       metaData.errline = errorDetails.errline ? errorDetails.errline : "";
       metaData.errstacktrace = errorDetails.errstacktrace ? errorDetails.errstacktrace : "";
       metaData.errcustommsg = errorDetails.errcustommsg ? errorDetails.errcustommsg : "";
       var formID = errorDetails.formID ? errorDetails.formID : "";
       var widgetID = errorDetails.widgetID ? errorDetails.widgetID : "";
       var flowTag = errorDetails.flowTag ? errorDetails.flowTag : "";
       var evtSubType = errorType ? errorType : "";
       this.sendEvent("Error", evtSubType, formID, widgetID, flowTag, JSON.stringify(metaData));
     } else {
       throw new Exception(kony.sdk.errorConstants.METRICS_FAILURE, "Invalid json string passed for error details.");
     }
   };
   /**
    * This method takes the event details from the developer and schedule it for sending to server as per Configuration values set by the developer.
    * @param {string} exceptionCode - Code for the reported exception. Can be empty if not applicable
    * @param {string} exceptionType -   Type of the reported exception. Can be empty if not applicable
    * @param {string} exceptionMessage - Message of the reported exception. Can be empty if not applicable
    * @param {json}   exceptionDetails - Details of the reported exception as a JSON string that can have key-value pairs for the
   				following keys exceptioncode, exceptionfile, exceptionmethod, exceptionline,
   				exceptionstacktrace, formID, widgetID, flowTag.
    * @throws Exception
    */
   this.reportHandledException = function(exceptionCode, exceptionType, exceptionMessage, exceptionDetails) {
     var metaData = {};
     metaData.exceptioncode = exceptionCode ? exceptionCode : "";
     metaData.exceptionmsg = exceptionMessage ? exceptionMessage : "";
     if (exceptionDetails && kony.sdk.isJson(exceptionDetails)) {
       exceptionDetails = JSON.parse(exceptionDetails);
       metaData.exceptionfile = exceptionDetails.errfile ? exceptionDetails.errfile : "";
       metaData.exceptionmethod = exceptionDetails.errmethod ? exceptionDetails.errmethod : "";
       metaData.exceptionline = exceptionDetails.errline ? exceptionDetails.errline : "";
       metaData.exceptionstacktrace = exceptionDetails.errstacktrace ? exceptionDetails.errstacktrace : "";
       metaData.exceptioncustommsg = exceptionDetails.errcustommsg ? exceptionDetails.errcustommsg : "";
       var formID = exceptionDetails.formID ? exceptionDetails.formID : "";
       var widgetID = exceptionDetails.widgetID ? exceptionDetails.widgetID : "";
       var flowTag = exceptionDetails.flowTag ? exceptionDetails.flowTag : "";
       var evtSubType = exceptionType ? exceptionType : "";
       this.sendEvent("Exception", evtSubType, formID, widgetID, flowTag, JSON.stringify(metaData));
     } else {
       throw new Exception(kony.sdk.errorConstants.METRICS_FAILURE, "Invalid json string passed for exception details.");
     }
   };
   /**
    * sets the current sessionId
    * @param {string} sessionId
    */
   this.setSessionId = function(sessionId) {
     if (sessionId) {
       kony.sdk.currentInstance.setSessionId(sessionId);
     }
   };
   /**
    * get the current sessionID
    *
    */
   this.getSessionId = function() {
     return kony.sdk.currentInstance.getSessionId();
   };
   /**
    * stub method used for event tracking
    *
    */
   this.setEventTracking = function(eventTypes) {
     // Stub.  This is implemented in native->js binding
   }
 }
 kony.sdk.initiateSession = function() {};
 /**
  * Method which returns the offline enabled ObjectService object
  * @param konyRef
  * @param serviceName
  * @constructor
  */
 kony.sdk.OfflineEnabledObjectService = function(konyRef, serviceName) {
   this.serviceName = serviceName;
   this.konyRef = konyRef;
   /**
    * This method is used to fetch records on the object
    * @param {map} options - includes {"dataObject":(@link kony.sdk.dto.DataObject)}
    * @param successCallback
    * @param failureCallback
    */
   this.fetch = function(options, successCallback, failureCallback) {
     kony.sdk.logsdk.trace("Entering kony.sdk.OfflineEnabledObjectService.fetch");
     if (!areOptionsValid(options, failureCallback)) {
       return;
     }
     try {
       var dataObject = options[kony.sdk.constants.ObjectServiceConstants.DATAOBJECT];
       var objectName = dataObject.getObjectName();

       function fetchHandler(objMetadata) {
         var obj = new kony.sdk.KNYObj(objectName);
         var readOptions = dataObject.getOfflineObjectsOptions();
         /* If read options are not supplied, caller such as fetchDataForColumns model API would provide a select query object and some callers provide query params.
          *  We parse the select query or queryParams to suite offline objects read API.
          */
         if (!readOptions || Object.keys(readOptions).length == 0) {
           var selectQueryObject = dataObject.getSelectQueryObject();
           var queryParams = options[kony.sdk.constants.ObjectServiceConstants.QUERYPARAMS];
           if (selectQueryObject) {
             readOptions.projectionColumns = [];
             var columns = selectQueryObject.getColumns();
             for (var column in columns) {
               readOptions.projectionColumns.push(columns[column].getName());
             }
             var criteriaList = selectQueryObject.getCriterias();
             var primaryKeys = {};
             for (var criteria in criteriaList) {
               var colObj = criteriaList[criteria].getColumn();
               if (colObj) {
                 primaryKeys[colObj.getName()] = criteriaList[criteria].getValue();
               }
             }
             readOptions.primaryKeys = primaryKeys;
           } else if (queryParams) {
             var primaryKeys = {};
             if (objMetadata.primaryKey != null && objMetadata.primaryKey != undefined) {
               for (var indx = 0; indx < objMetadata.primaryKey.length; indx++) {
                 var pKey = objMetadata.primaryKey[indx];
                 var pKeyValue = queryParams[pKey];
                 if (pKeyValue == null || pKeyValue == undefined || pKeyValue == "") {
                   kony.sdk.logsdk.error("### OfflineEnabledObjectService:: fetch Error: Primarykey details missing so unable to fetch");
                   kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getClientErrObj(kony.sdk.errorcodes.primarykey_unavailable, kony.sdk.errormessages.primarykey_unavailable));
                   return;
                 }
                 primaryKeys[pKey] = pKeyValue;
               }
               readOptions.primaryKeys = primaryKeys;
             } else {
               kony.sdk.logsdk.error("### OfflineEnabledObjectService:: fetch Error: Primarykey details missing so unable to fetch");
               kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getClientErrObj(kony.sdk.errorcodes.primarykey_unavailable, kony.sdk.errormessages.primarykey_unavailable));
               return;
             }
           }
         }

         function fetchSuccessHandler(res) {
           var response = {};
           response.records = res;
           successCallback(response);
         }
         obj.get(readOptions, fetchSuccessHandler, failureCallback);
       }
       this.getMetadataOfObject(objectName, {}, fetchHandler, failureCallback);
     } catch (error) {
       kony.sdk.logsdk.error("Fetch on offline enabled object failed with error: " + error);
       kony.sdk.verifyAndCallClosure(failureCallback, error);
     }
   };
   /**
    * This method is used to create a record on the object
    * @param {map} options - includes {"dataObject":(@link kony.sdk.dto.DataObject)}
    * @param successCallback
    * @param failureCallback
    */
   this.create = function(options, successCallback, failureCallback) {
     kony.sdk.logsdk.trace("Entering kony.sdk.OfflineEnabledObjectService.create");
     if (!areOptionsValid(options, failureCallback)) {
       return;
     }
     try {
       var dataObject = options[kony.sdk.constants.ObjectServiceConstants.DATAOBJECT];
       var objectName = dataObject.getObjectName();
       var obj = new kony.sdk.KNYObj(objectName);
       var createOptions = dataObject.getOfflineObjectsOptions();
       var records = dataObject.getRecord();
       obj.create(records, createOptions, successCallback, failureCallback);
     } catch (error) {
       kony.sdk.logsdk.error("Create on offline enabled object failed with error: " + error);
       kony.sdk.verifyAndCallClosure(failureCallback, error);
     }
   };
   /**
    * This method is used to update a record on the object
    * @param {map} options - includes {"dataObject":(@link kony.sdk.dto.DataObject)}
    * @param successCallback
    * @param failureCallback
    */
   this.update = function(options, successCallback, failureCallback) {
     kony.sdk.logsdk.trace("Entering kony.sdk.OfflineEnabledObjectService.update");
     if (!areOptionsValid(options, failureCallback)) {
       return;
     }
     try {
       var dataObject = options[kony.sdk.constants.ObjectServiceConstants.DATAOBJECT];
       var objectName = dataObject.getObjectName();

       function updateHandler(objMetadata) {
         var obj = new kony.sdk.KNYObj(objectName);
         var updateOptions = dataObject.getOfflineObjectsOptions();
         var records = dataObject.getRecord();
         // If primary keys are not supplied through options, they are picked from the user supplied record.
         if (!updateOptions || Object.keys(updateOptions).length == 0 || !updateOptions['primaryKeys']) {
           if (records) {
             var primaryKeys = {};
             if (objMetadata.primaryKey != null && objMetadata.primaryKey != undefined) {
               for (var indx = 0; indx < objMetadata.primaryKey.length; indx++) {
                 var pKey = objMetadata.primaryKey[indx];
                 var pKeyValue = records[pKey];
                 if (pKeyValue == null || pKeyValue == undefined || pKeyValue == "") {
                   kony.sdk.logsdk.error("### OfflineEnabledObjectService:: Update Error: Primarykey details missing so unable to update");
                   kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getClientErrObj(kony.sdk.errorcodes.primarykey_unavailable, kony.sdk.errormessages.primarykey_unavailable));
                   return;
                 }
                 primaryKeys[pKey] = pKeyValue;
                 delete records[pKey];
               }
               updateOptions.primaryKeys = primaryKeys;
             } else {
               kony.sdk.logsdk.error("### OfflineEnabledObjectService:: Update Error: Primarykey details missing so unable to update");
               kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getClientErrObj(kony.sdk.errorcodes.primarykey_unavailable, kony.sdk.errormessages.primarykey_unavailable));
               return;
             }
           } else {
             kony.sdk.logsdk.error("Update Failed: primaryKeys key missing. Please use dataObject setOfflineObjectsOptions to set primaryKeys for update operation.");
             kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getClientErrObj(kony.sdk.errorcodes.primarykey_unavailable, kony.sdk.errormessages.primarykey_unavailable));
             return;
           }
         }
         obj.updateByPK(records, updateOptions, successCallback, failureCallback);
       }
       this.getMetadataOfObject(objectName, {}, updateHandler, failureCallback);
     } catch (error) {
       kony.sdk.logsdk.error("Update on offline enabled object failed with error: " + error);
       kony.sdk.verifyAndCallClosure(failureCallback, error);
     }
   };
   /**
    * This method is used to delete a record on the object
    * @param {map} options - includes {"dataObject":(@link kony.sdk.dto.DataObject)}
    * @param successCallback
    * @param failureCallback
    */
   this.deleteRecord = function(options, successCallback, failureCallback) {
     kony.sdk.logsdk.trace("Entering kony.sdk.OfflineEnabledObjectService.deleteRecord");
     if (!areOptionsValid(options, failureCallback)) {
       return;
     }
     try {
       var dataObject = options[kony.sdk.constants.ObjectServiceConstants.DATAOBJECT];
       var objectName = dataObject.getObjectName();

       function deleteHandler(objMetadata) {
         var obj = new kony.sdk.KNYObj(objectName);
         var deleteOptions = dataObject.getOfflineObjectsOptions();
         // If primary keys are not supplied through options, they are picked from the user supplied record
         if (!deleteOptions || Object.keys(deleteOptions).length == 0 || !deleteOptions['primaryKeys']) {
           var records = dataObject.getRecord();
           if (records) {
             var primaryKeys = {};
             if (objMetadata.primaryKey != null && objMetadata.primaryKey != undefined) {
               for (var indx = 0; indx < objMetadata.primaryKey.length; indx++) {
                 var pKey = objMetadata.primaryKey[indx];
                 var pKeyValue = records[pKey];
                 if (pKeyValue == null || pKeyValue == undefined || pKeyValue == "") {
                   kony.sdk.logsdk.error("### OfflineEnabledObjectService:: Delete Error: Primarykey details missing so unable to delete");
                   kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getClientErrObj(kony.sdk.errorcodes.primarykey_unavailable, kony.sdk.errormessages.primarykey_unavailable));
                   return;
                 }
                 primaryKeys[pKey] = pKeyValue;
               }
               deleteOptions.primaryKeys = primaryKeys;
             } else {
               kony.sdk.logsdk.error("### OfflineEnabledObjectService:: Delete Error: Primarykey details missing so unable to delete");
               kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getClientErrObj(kony.sdk.errorcodes.primarykey_unavailable, kony.sdk.errormessages.primarykey_unavailable));
               return;
             }
           } else {
             kony.sdk.logsdk.error("Delete Failed: primaryKeys key missing. Please use dataObject setOfflineObjectsOptions to set primaryKeys for delte operation.");
             kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getClientErrObj(kony.sdk.errorcodes.primarykey_unavailable, kony.sdk.errormessages.primarykey_unavailable));
             return;
           }
         }
         obj.deleteByPK(deleteOptions, successCallback, failureCallback);
       }
       this.getMetadataOfObject(objectName, {}, deleteHandler, failureCallback);
     } catch (error) {
       kony.sdk.logsdk.error("Delete on offline enabled object failed with error: " + error);
       kony.sdk.verifyAndCallClosure(failureCallback, error);
     }
   };
   /**
    * This method is used to retrieve metadata of all objects
    * @param options
    * @param successCallback
    * @param failureCallback
    */
   this.getMetadataOfAllObjects = function(options, successCallback, failureCallback) {
     kony.sdk.logsdk.trace("Entering kony.sdk.OfflineEnabledObjectService.getMetadataOfAllObjects");
     _getMetadataForObjectsOrServiceOnlineUtil(konyRef, serviceName, null, options, successCallback, failureCallback);
     kony.sdk.logsdk.trace("EXiting kony.sdk.OfflineEnabledObjectService.getMetadataOfAllObjects");
   };
   /**
    * This method is used to retrive metadata of a specific object
    * @param objectName
    * @param options
    * @param successCallback
    * @param failureCallback
    */
   this.getMetadataOfObject = function(objectName, options, successCallback, failureCallback) {
     kony.sdk.logsdk.trace("Entering kony.sdk.OfflineEnabledObjectService.getMetadataOfObject");
     _getMetadataForObjectsOrServiceOnlineUtil(konyRef, serviceName, objectName, options, successCallback, failureCallback);
     kony.sdk.logsdk.trace("Exiting kony.sdk.OfflineEnabledObjectService.getMetadataOfObject");
   };
   /**
    * This method is used to validate options
    * @param options
    * @param failureCallback
    */
   function areOptionsValid(options, failureCallback) {
     if (options == null || options == undefined) {
       kony.sdk.logsdk.error("### OfflineEnabledObjectService:: Options Validity check: options null or undefined");
       kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getClientErrObj(kony.sdk.errorcodes.null_or_undefined, "options" + kony.sdk.errormessages.null_or_undefined));
       return false;
     }
     if (!(options[kony.sdk.constants.ObjectServiceConstants.DATAOBJECT] instanceof kony.sdk.dto.DataObject)) {
       kony.sdk.logsdk.error("### OfflineEnabledObjectService:: Options Validity check: invalid data object");
       kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getClientErrObj(kony.sdk.errorcodes.invalid_dataobject_instance, kony.sdk.errormessages.invalid_dataobject_instance));
       return false;
     }
     var dataObject = options[kony.sdk.constants.ObjectServiceConstants.DATAOBJECT];
     var objectName = dataObject.getObjectName();
     if (objectName == null || objectName == undefined) {
       kony.sdk.logsdk.error("### OfflineEnabledObjectService:: Options Validity check: objectname null or undefined");
       kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getClientErrObj(kony.sdk.errorcodes.null_or_undefined, "objectName" + kony.sdk.errormessages.null_or_undefined));
       return false;
     }
     return true;
   };
 };
 /**
  * Method which returns the offline ObjectService object
  * @param konyRef
  * @param serviceName
  * @constructor
  */
 kony.sdk.OfflineObjectService = function(konyRef, serviceName) {
   kony.sdk.logsdk.trace("Entering kony.sdk.OfflineObjectService");
   this.konyRef = konyRef;
   this.serviceName = serviceName;
   /**
    * This method is used to create a record on the object
    * @param {map} options - includes {"dataObject":(@link kony.sdk.dto.DataObject)}
    * @param successCallback
    * @param failureCallback
    */
   this.create = function(options, successCallback, failureCallback) {
     kony.sdk.logsdk.trace("Entering kony.sdk.OfflineObjectService.create");
     if (options == null || options == undefined) {
       kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getClientErrObj(kony.sdk.errorcodes.null_or_undefined, "options" + kony.sdk.errormessages.null_or_undefined));
       return;
     }
     if (!(options["dataObject"] instanceof kony.sdk.dto.DataObject)) {
       kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getClientErrObj(kony.sdk.errorcodes.invalid_dataobject_instance, kony.sdk.errormessages.invalid_dataobject_instance));
       return;
     }
     var dataObject = options["dataObject"];

     function createHandler(objMetadata) {
       _invokeOfflineCreate(dataObject, successCallback, failureCallback, options);
     }
     this.getMetadataOfObject(dataObject.getObjectName(), {}, createHandler, failureCallback);
   };
   /**
    * This method is used to fetch records from the object
    * @param {map} options - includes {"dataObject":(@link kony.sdk.dto.DataObject)}
    * @param successCallback
    * @param failureCallback
    */
   this.fetch = function(options, successCallback, failureCallback) {
     throw "This method is not implemented.Instead use executeSelectQuery";
   };
   /**
    * This method is used to update a record in the object
    * @param {map} options - includes {"dataObject":(@link kony.sdk.dto.DataObject)}
    * @param successCallback
    * @param failureCallback
    */
   this.update = function(options, successCallback, failureCallback) {
     kony.sdk.logsdk.trace("Entering kony.sdk.OfflineObjectService.update");
     if (options == null || options == undefined) {
       kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getClientErrObj(kony.sdk.errorcodes.null_or_undefined, "options" + kony.sdk.errormessages.null_or_undefined));
       return;
     }
     if (!(options["dataObject"] instanceof kony.sdk.dto.DataObject)) {
       kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getClientErrObj(kony.sdk.errorcodes.invalid_dataobject_instance, kony.sdk.errormessages.invalid_dataobject_instance));
       return;
     }
     var dataObject = options["dataObject"];

     function updateHandler(objMetadata) {
       function updateSuccessCallback(response) {
         kony.sdk.verifyAndCallClosure(successCallback, response);
       }

       function updateFailureCallback(error) {
         if (error != null && error != undefined) {
           //if the errorcode is equivalent to transaction failed then giving some generic error message to the client.
           if (error["errorCode"] == 7010) {
             kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getClientErrObj(kony.sdk.errorcodes.transaction_failed, kony.sdk.errormessages.transaction_failed));
             return;
           }
         }
         kony.sdk.verifyAndCallClosure(failureCallback, error);
       }
       _invokeOfflineUpdate(dataObject, updateSuccessCallback, updateFailureCallback, options);
     }
     this.getMetadataOfObject(dataObject.getObjectName(), {}, updateHandler, failureCallback);
   };
   /**
    * This method is used to delete a record in the object
    * @param {map} options - includes {"dataObject":(@link kony.sdk.dto.DataObject)}
    * @param successCallback
    * @param failureCallback
    */
   this.deleteRecord = function(options, successCallback, failureCallback) {
     kony.sdk.logsdk.trace("Entering kony.sdk.OfflineObjectService.deleteRecord");
     if (options == null || options == undefined) {
       kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getClientErrObj(kony.sdk.errorcodes.null_or_undefined, "options" + kony.sdk.errormessages.null_or_undefined));
       return;
     }
     if (!(options["dataObject"] instanceof kony.sdk.dto.DataObject)) {
       kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getClientErrObj(kony.sdk.errorcodes.invalid_dataobject_instance, kony.sdk.errormessages.invalid_dataobject_instance));
       return;
     }
     var dataObject = options["dataObject"];

     function deleteHandler(objMetadata) {
       function deleteSuccessCallback(response) {
         //verifying delete response contains deleted records count as 0
         if (response != null && response != undefined) {
           if (response["rowsdeleted"] == 0) {
             kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getClientErrObj(kony.sdk.errorcodes.norecords_to_delete, kony.sdk.errormessages.norecords_to_delete));
             return;
           }
         }
         kony.sdk.verifyAndCallClosure(successCallback, response);
       }

       function deleteFailureCallback(error) {
         kony.sdk.verifyAndCallClosure(failureCallback, error);
       }
       _invokeOfflineDelete(dataObject, deleteSuccessCallback, deleteFailureCallback, options);
     }
     this.getMetadataOfObject(dataObject.getObjectName(), {}, deleteHandler, failureCallback);
   };
   /**
    * This method is used to retrieve metadata of all objects
    * @param options
    * @param successCallback
    * @param failureCallback
    */
   this.getMetadataOfAllObjects = function(options, successCallback, failureCallback) {
     kony.sdk.logsdk.trace("Entering kony.sdk.OfflineObjectService.getMetadataOfAllObjects");
     _getMetadataForObjectsOrServiceOnlineUtil(konyRef, serviceName, null, options, successCallback, failureCallback);
     kony.sdk.logsdk.trace("Exiting kony.sdk.OfflineObjectService.getMetadataOfAllObjects");
   };
   /**
    * This method is used to retrive metadata of a specific object
    * @param objectName
    * @param options
    * @param successCallback
    * @param failureCallback
    */
   this.getMetadataOfObject = function(objectName, options, successCallback, failureCallback) {
     kony.sdk.logsdk.trace("Entering kony.sdk.OfflineObjectService.getMetadataOfObject");
     _getMetadataForObjectsOrServiceOnlineUtil(konyRef, serviceName, objectName, options, successCallback, failureCallback);
     kony.sdk.logsdk.trace("Exiting kony.sdk.OfflineObjectService.getMetadataOfObject");
   };
   /**
    * This method is used to execute an sql query
    * @param queryStr
    * @param successCallback
    * @param failureCallback
    */
   this.executeSelectQuery = function(queryStr, successCallback, failureCallback) {
     kony.sdk.logsdk.trace("Entering kony.sdk.OfflineObjectService.executeSelectQuery");

     function selctSuccess(response) {
       kony.sdk.logsdk.debug("### OfflineObjectService::executeSelectQuery::selectSuccess Response:", response);
       kony.sdk.verifyAndCallClosure(successCallback, response);
     }

     function selectError(error) {
       kony.sdk.logsdk.error("### OfflineObjectService::executeSelectQuery::selectError Error:", error);
       kony.sdk.verifyAndCallClosure(failureCallback, error);
     }
     kony.sync.single_select_execute(kony.sdk.util.getSyncDbName(), queryStr, null, selctSuccess, selectError);
   };
   /**
    * Helps to get the binary content of the specified column on the Object
    * @param {map} options - includes {"dataObject":(@link kony.sdk.dto.DataObject), "responsetype":"base64string/filepath(Default)", "binaryAttrName":columnName}
    * @param successCallback
    * @param failureCallback
    */
   this.getBinaryContent = function(options, successCallback, failureCallback) {
     kony.sdk.logsdk.trace("Entering kony.sdk.OfflineObjectService.getBinaryContenttion");
     if (kony.sdk.isNullOrUndefined(options)) {
       kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getClientErrObj(kony.sdk.errorcodes.null_or_undefined, "options" + kony.sdk.errormessages.null_or_undefined));
       return;
     }
     var dataObject = options["dataObject"];
     if (!(dataObject instanceof kony.sdk.dto.DataObject)) {
       kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getClientErrObj(kony.sdk.errorcodes.invalid_dataobject_instance, kony.sdk.errormessages.invalid_dataobject_instance));
       return;
     }
     var binaryColName = options["binaryAttrName"];
     if (kony.sdk.isNullOrUndefined(binaryColName)) {
       kony.sdk.logsdk.error("### OfflineObjectService::getBinaryContent Error: Please provide column name to fetch binary content");
       kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getClientErrObj("90000", "Please provide column name to fetch binary content"));
       return;
     }
     var getBase64 = options["responsetype"] === "base64string" ? true : false;
     var config = options["config"];

     function getBinaryDataHandler(objMetadata) {
       function selectSuccessCallback(response) {
         kony.sdk.logsdk.debug("### OfflineObjectService::getBinaryContent::selectSuccessCallback Response", response);
         var filePath = response["FilePath"];
         if (getBase64) {
           getBase64BasedOnFileType(filePath, successCallback, failureCallback);
         } else {
           //get filepath from response
           kony.sdk.verifyAndCallClosure(successCallback, filePath);
         }
       }

       function selectErrorCallback(error) {
         kony.sdk.logsdk.error("### OfflineObjectService::getBinaryContent::selectErrorCallback Error:", error);
         _invokeOfflineErrorCallback(failureCallback, error);
       }

       function getBase64BasedOnFileType(filePath, successCallback, failureCallback) {
         var id = filePath.substring(filePath.lastIndexOf("/") + 1, filePath.length);
         var query = "Select type from " + kony.sync.blobStoreManagerTable + " where id = " + id;
         sync.executeSelectQuery(query, function(res) {
           var base64String;
           try {
             if (res[0].type && res[0].type === kony.sync.blobTypeBase64) {
               //get base64 from base64 file using SDK's FFI BlobStoreUtil
               base64String = binary.util.getBase64FromFile(filePath);
             } else {
               //get base64 from binary file using FW APIs
               var tempFile = new kony.io.File(filePath);
               if (!kony.sdk.isNullOrUndefined(tempFile) && tempFile.exists() && tempFile.readable) {
                 var tempRawBytes = tempFile.read();
                 base64String = kony.convertToBase64(tempRawBytes);
               } else {
                 invokeFailureCallbackForGetBinaryContent(filePath, failureCallback);
               }
             }
           } catch (ex) {
             invokeFailureCallbackForGetBinaryContent(JSON.stringify(ex), failureCallback);
           }
           kony.sdk.verifyAndCallClosure(successCallback, base64String);
         }, function(err) {
           invokeFailureCallbackForGetBinaryContent(JSON.stringify(err), failureCallback);
         });
       }

       function invokeFailureCallbackForGetBinaryContent(msg, failureCallback) {
         kony.sdk.logsdk.error("Error in creating base64 string from local file : ", msg);
         var errorCode = kony.sdk.errorcodes.invalid_blob;
         var errorMessage = kony.sdk.errormessages.invalid_blob;
         kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getClientErrObj(errorCode, errorMessage));
       }
       var dbName = kony.sdk.util.getSyncDbName();
       var objName = dataObject.getObjectName();
       var columnValues = kony.sdk.util.populateColumnValues(dataObject.getRecord(), null);
       var colMeta = kony.sdk.util.getMetadataOfColumn(objMetadata, binaryColName);
       if (kony.sdk.isNullOrUndefined(colMeta)) {
         kony.sdk.logsdk.warn("### OfflineObjectService::getBinaryContent Error: Invalid binary attribute name.");
         kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getClientErrObj("90000", "Invalid binary attribute name."));
         return;
       }
       if (colMeta["datatype"] !== kony.sdk.constants.BINARY_DATATYPE) {
         kony.sdk.logsdk.warn("### OfflineObjectService::getBinaryContent Error: Datatype is not binary for the specified binary attribute name");
         kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getClientErrObj("90000", "Datatype is not binary for the specified binary attribute name"));
         return;
       }
       var pkTable = kony.sdk.util.getPkTableForBinary(objMetadata, columnValues, failureCallback);
       kony.sync.getBinary(dbName, objName, binaryColName, pkTable, config, selectSuccessCallback, selectErrorCallback);
     }
     this.getMetadataOfObject(dataObject.getObjectName(), {}, getBinaryDataHandler, failureCallback);
   };

   function _invokeOfflineErrorCallback(failureCallback, errorObject) {
     //call the failureCallback after adding opstatus to the errorObject.
     var errorCode, errorMessage;
     if (errorObject) {
       errorCode = (errorObject.hasOwnProperty("errorCode")) ? errorObject["errorCode"] : kony.sdk.errorcodes.transaction_failed;
       errorMessage = (errorObject.hasOwnProperty("errorMessage")) ? errorObject["errorMessage"] : kony.sdk.errormessages.transaction_failed;
     } else {
       errorCode = kony.sdk.errorcodes.transaction_failed;
       errorMessage = kony.sdk.errormessages.transaction_failed;
     }
     kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getClientErrObj(errorCode, errorMessage));
   }

   function _invokeOfflineCreate(dataObject, successCallback, failureCallback, options) {
     var dbname = kony.sdk.util.getSyncDbName();
     kony.sync.single_insert_execute(dbname, dataObject.getObjectName(), dataObject.getRecord(), successCallback, function(err) {
       _invokeOfflineErrorCallback(failureCallback, err);
     }, true, options);
   }

   function _invokeOfflineUpdate(dataObject, successCallback, failureCallback, options) {
     var objectName = dataObject.getObjectName();
     var columnValues = dataObject.getRecord();
     var objMetadata = kony.sdk.ObjectServiceUtil.getCachedObjectMetadata(serviceName, objectName);
     var pkTable = {};
     var whereClause = [];
     if (objMetadata.primaryKey != null && objMetadata.primaryKey != undefined) {
       for (var indx = 0; indx < objMetadata.primaryKey.length; indx++) {
         var pKey = objMetadata.primaryKey[indx];
         var pKeyValue = columnValues[pKey];
         if (pKeyValue == null || pKeyValue == undefined || pKeyValue == "") {
           //TODO change to error object
           kony.sdk.logsdk.error("### OfflineObjectService::_invokeOfflineUpdate Error: Primarykey details missing so unable to update");
           kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getClientErrObj(kony.sdk.errorcodes.primarykey_unavailable, kony.sdk.errormessages.primarykey_unavailable));
           return;
         }
         pkTable.pKey = {
           "key": pKey,
           "value": pKeyValue
         };
         var condition = {};
         condition.key = pKey;
         condition.value = pKeyValue;
         whereClause.push(condition);
       }
     } else {
       //TODO change to error object
       kony.sdk.logsdk.error("### OfflineObjectService::_invokeOfflineUpdate Error: Primarykey details missing so unable to update");
       kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getClientErrObj(kony.sdk.errorcodes.primarykey_unavailable, kony.sdk.errormessages.primarykey_unavailable));
       return;
     }
     var dbName = kony.sdk.util.getSyncDbName();
     kony.sync.single_update_execute(dbName, objectName, columnValues, whereClause, successCallback, function(err) {
       _invokeOfflineErrorCallback(failureCallback, err);
     }, false, true, null, options);
   }

   function _invokeOfflineDelete(dataObject, successCallback, failureCallback, options) {
     var isError = false;
     var markForUpload = false;
     var tbname = dataObject.getObjectName();
     var errMsg = null;
     var wcs = [];
     var objMetadata = kony.sdk.ObjectServiceUtil.getCachedObjectMetadata(serviceName, dataObject.getObjectName());
     var dbName = kony.sdk.util.getSyncDbName();
     var srcAttributes = kony.sdk.util.getPrimarykeysFromMetadata(objMetadata);
     if (srcAttributes != null && srcAttributes != undefined) {
       var pkLen = Object.keys(srcAttributes).length;
       for (var indx = 0; indx < pkLen; indx++) {
         var pKey = Object.keys(srcAttributes)[indx];
         var pKeyValue = dataObject.getRecord()[pKey];
         if (pKeyValue == null || pKeyValue == undefined || pKeyValue == "") {
           //TODO
           //throw error
           kony.sdk.logsdk.error("### _invokeOfflineDelete:: Error Primarykey details missing so unable to delete");
           kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getClientErrObj(kony.sdk.errorcodes.primarykey_unavailable, kony.sdk.errormessages.primarykey_unavailable));
           return;
         }
         var whereClause = {};
         whereClause.key = pKey;
         whereClause.value = pKeyValue;
         kony.table.insert(wcs, whereClause);
       }
     } else {
       //TODO
       //throw error
       kony.sdk.logsdk.error("### _invokeOfflineDelete:: Error Primarykey details missing so unable to delete");
       kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getClientErrObj(kony.sdk.errorcodes.primarykey_unavailable, kony.sdk.errormessages.primarykey_unavailable));
       return;
     }
     kony.sync.single_delete_execute(dbName, tbname, wcs, successCallback, function(err) {
       _invokeOfflineErrorCallback(failureCallback, err);
     }, false, false, true, options);
   }
 };
 //Utils specific to MVVM/MDA/MVC SDK
 // This function is responsible for checking if the array contains the object based on object's name property.
 // returns the array element if the object matches
 kony.sdk.util.getExtendedFieldsFromArray = function(array, object) {
   kony.sdk.logsdk.trace("Entering into kony.sdk.util.getExtendedFieldsFromArray");
   if (array instanceof Array) {
     for (var i = 0; i < array.length; i++) {
       if (array[i] instanceof kony.sdk.dto.FieldMetadata && object instanceof kony.sdk.dto.Column) {
         if (kony.sdk.util.matchIgnoreCase(array[i].name, object.getName()) && kony.sdk.util.matchIgnoreCase(array[i].type, "extendedfield")) {
           return array[i];
         }
       }
     }
     return null;
   }
 };
 /**
  * This Object represent picklist values
  * @constructor
  */
 kony.sdk.dto.PickList = function() {
   kony.sdk.logsdk.trace("Entering into kony.sdk.dto.PickList");
   this.id = null;
   this.active = null;
   this.label = null;
   this.value = null;
   this.validFor = null;
   this.defaultValue = null;
   this.fieldMappingId = null;
   this.setId = function(id) {
     this.id = id;
   }
   this.getId = function() {
     return this.id;
   }
   this.setActive = function(active) {
     this.active = active;
   }
   this.isActive = function() {
     return this.active;
   }
   this.setLabel = function(label) {
     this.label = label;
   }
   this.getLabel = function() {
     return this.label;
   }
   this.setValue = function(value) {
     this.value = value;
   }
   this.getValue = function() {
     return this.value;
   }
   this.setValidFor = function(validFor) {
     this.validFor = validFor;
   }
   this.getValidFor = function() {
     return this.validFor;
   }
   this.setDefaultValue = function(defaultValue) {
     this.defaultValue = defaultValue;
   }
   this.getDefaultValue = function() {
     return this.defaultValue;
   }
   this.setFieldMappingId = function(fieldMappingId) {
     this.fieldMappingId = fieldMappingId;
   }
   this.getFieldMappingId = function() {
     return this.fieldMappingId;
   }
 }
 /**
  * The structure of Object Metadata obtained from server
  * @constructor
  */
 kony.sdk.dto.ObjectMetadata = function() {
   //variables to store metadata of the object.
   this.custom;
   this.customizable;
   this.displayName;
   this.entityTypeID;
   this.columns;
   this.junction;
   this.name;
   this.primaryKey;
   this.relationshipList;
   this.sourceEntityName;
   this.updateable;
   this.uniqueKeys;
 }
 /**
  * The structure of Field Metadata obtained from server
  * @constructor
  */
 kony.sdk.dto.FieldMetadata = function() {
   this.auditColumn;
   this.createable;
   this.custom;
   this.customizable;
   this.type;
   this.defaultValue;
   this.displayName;
   this.fieldMappingId;
   this.hasIndex;
   this.name;
   this.nameField;
   this.nullable;
   this.primaryKey;
   this.sourceFieldName;
   this.table;
   this.updateable;
   // array of picklistValueDto objects to hold the pick list values. This will be populated only when the data type is of picklist type
   this.pickListValues;
 }
 /**
  * The structure of Object Relationship in metadata obtained from server
  * @constructor
  */
 kony.sdk.dto.ObjectRelationship = function() {
   this.entityName;
   this.entityPageTemplateId;
   this.id;
   this.junctionTableName;
   this.operationType;
   this.relatedEntity;
   this.relationshipFields;
   this.relationshipName;
   this.relationshipType;
   this.custom;
 }
 /**
  * The Object used to define select query object, in order to fetch data
  * @param serviceName
  * @param tableObj {@link kony.sdk.dto.Table}
  * @constructor
  */
 kony.sdk.dto.SelectQuery = function(serviceName, tableObj) {
   this.tables = [];
   this.columnList = [];
   this.criteriaList = [];
   this.isDistinct = false;
   this.orderList = [];
   this.joinList = [];
   this.groupList = [];
   this.limit = null;
   this.skip = null;
   this.oDataURL = null;
   if (tableObj instanceof kony.sdk.dto.Table) {
     this.tables.push(tableObj);
   }
   /**
    * This function is used to set Limit value
    * @param val
    */
   this.setLimit = function(val) {
     this.limit = val;
   };
   /**
    * This function is used to set Skip value
    * @param val
    */
   this.setSkip = function(val) {
     this.skip = val;
   };
   /**
    * This function is used to get the Limit Value
    * @returns {integer} limit
    */
   this.getLimit = function() {
     return this.limit;
   };
   /**
    * This function is used to get the Skip Value
    * @returns {integer} skip
    */
   this.getSkip = function() {
     return this.skip;
   };
   /**
    * This function is used to add a column object into the select query
    * @param columnObj {@Link kony.sdk.dto.Column}
    * @returns {Array}
    */
   this.addColumn = function(columnObj) {
     if (columnObj instanceof kony.sdk.dto.Column) {
       this.columnList.push(columnObj);
       return this.columnList;
     }
   };
   /**
    * This function is used to add a criteria object to the select query
    * @param criteriaObj
    * @returns {Array}
    */
   this.addCriteria = function(criteriaObj) {
     if (kony.sdk.util.validateCriteriaObject(criteriaObj)) {
       this.criteriaList.push(criteriaObj);
       return this.criteriaList;
     }
   };
   /**
    * This function is used to add a group object to select query
    * @param groupObj
    */
   this.addGroup = function(groupObj) {
     if (groupObj instanceof kony.sdk.dto.Group) {
       this.groupList.push(groupObj);
       for (var i = 0; i < this.tables.length; i++) {
         if (this.tables[i].getName().toUpperCase() === groupObj.getColumn().getTable().getName().toUpperCase()) {
           return;
         }
       }
       this.tables.push(groupObj.getColumn().getTable());
     }
   };
   /**
    * This function is used to add a join object
    * @param joinObj
    */
   this.addJoin = function(joinObj) {
     if (joinObj instanceof kony.sdk.dto.Join) {
       this.joinList.push(joinObj);
       for (var i = 0; i < this.tables.length; i++) {
         if (this.tables[i].getName().toUpperCase() === joinObj.getTable().getName().toUpperCase()) {
           if (this.tables[i].getAlias() != null || joinObj.getTable().getAlias() != null || this.tables[i].getAlias() != undefined || joinObj.getTable().getAlias() != undefined) {
             if (this.tables[i].getAlias().toUpperCase() === joinObj.getTable().getAlias().toUpperCase()) {
               return;
             } else {
               this.tables.push(joinObj.getTable());
               return;
             }
           } else {
             return;
           }
         }
       }
       this.tables.push(joinObj.getTable());
     }
   };
   /**
    * This function is used to add order object to a select query
    * @param orderObj
    */
   this.addOrder = function(orderObj) {
     var currentobject = this;
     if (orderObj instanceof kony.sdk.dto.Order) {
       this.orderList.push(arguments[0]);
       for (var i = 0; i < this.tables.length; i++) {
         if (this.tables[i].getName().toUpperCase() === arguments[0].getColumn().getTable().getName().toUpperCase()) {
           return;
         }
       }
       this.tables.push(orderObj.getColumn().getTable());
     }
   };
   /**
    * This function is used to return tables in select query
    * @returns {Array} Tables
    */
   this.getTables = function() {
     return this.tables;
   };
   /**
    * This function is used to get isDistinct flag
    * @returns {boolean}
    */
   this.getDistinct = function() {
     return this.isDistinct;
   };
   /**
    * This function is used to return columns in select query
    * @returns {Array} Columns
    */
   this.getColumns = function() {
     return this.columnList;
   };
   /**
    * This function is used to get criteria objects in the select query
    * @returns {Array} Criterias
    */
   this.getCriterias = function() {
     return this.criteriaList;
   };
   /**
    * This function is used to get the group objects in the select query
    * @returns {Array} GroupObjs
    */
   this.getGroups = function() {
     return this.groupList;
   };
   /**
    * This function is used to get the Join objects in the select query
    * @returns {Array} Joins
    */
   this.getJoins = function() {
     return this.joinList;
   };
   /**
    * This function is used to get the Order Objects in the select query
    * @returns {Array} OrderObjs
    */
   this.getOrders = function() {
     return this.orderList;
   };
   /**
    * This function is used to remove columnobject set in select query
    * @param columnObj {@link kony.sdk.dto.Column}
    */
   this.removeColumn = function(columnObj) {
     if (columnObj instanceof kony.sdk.dto.Column) {
       this.columnList.splice(this.columnList.indexOf(columnObj), 1);
     }
   };
   /**
    * This function is used to remove criteriaObject from select query
    * @param criteriaObj
    */
   this.removeCriteria = function(criteriaObj) {
     if (criteriaObj instanceof Criteria) {
       this.criteriaList.splice(this.criteriaList.indexOf(criteriaObj), 1);
     }
   };
   /**
    * This function is used to remove group set from select query
    * @param groupObj
    */
   this.removeGroup = function(groupObj) {
     if (groupObj instanceof kony.sdk.dto.Group) {
       this.groupList.splice(this.groupList.indexOf(groupObj), 1);
     }
   };
   /**
    * This function is used to remove Join set in select query
    * @param joinObj
    */
   this.removeJoin = function(joinObj) {
     if (joinObj instanceof kony.sdk.dto.Criteria) {
       this.joinList.splice(this.joinList.indexOf(joinObj), 1);
     }
   };
   /**
    * This function is used to remove OrderObj set in SelectQuery
    * @param orderObj
    */
   this.removeOrder = function(orderObj) {
     if (orderObj instanceof kony.sdk.dto.Order) {
       this.orderList.splice(this.orderList.indexOf(orderObj), 1);
     }
   };
   /**
    * This function is used to set isDistinct
    * @param isDistinct
    */
   this.setDistinct = function(isDistinct) {
     this.isDistinct = isDistinct;
   };
   /**
    * This function is used to get the select query in the form of a string
    * @returns {string}
    */
   this.toString = function() {
     var selectQueryDto = this;
     var query = "";
     query = query + "SELECT ";
     if (this.getDistinct() == true || this.getDistinct() == "true") {
       query = query + " DISTINCT ";
     }
     // Fetch the metadata for the base table and see if there are any extended fields associated with it
     // If there are any, create a join between the base table and the corresponding parent table and fetch it
     var columns = this.columnList;
     var extendedFields = [];
     var columnsArr = [];
     var extendedJoins = [];
     var baseTable = this.getTables()[0];
     var objectMetadata = kony.sdk.ObjectServiceUtil.getCachedObjectMetadata(serviceName, baseTable.getName());
     if (columns.length !== 0) {
       var field = null;
       for (var colIndex = 0; colIndex < columns.length; colIndex++) {
         field = kony.sdk.util.getExtendedFieldsFromArray(objectMetadata.columns, columns[colIndex]);
         if (field !== null && field !== undefined) {
           selectQueryDto.columnList[colIndex].dataType = field.type;
           selectQueryDto.columnList[colIndex].parentFieldName = field.parentFieldName;
           extendedFields.push(field);
           field = null;
         } else {
           columnsArr.push(columns[colIndex]);
         }
       }
     } else {
       var col = null;
       var field = null;
       for (var colIndex = 0; colIndex < objectMetadata.columns.length; colIndex++) {
         field = objectMetadata.columns[colIndex];
         col = new kony.sdk.dto.Column(baseTable, field.name);
         col.dataType = field.type;
         col.parentFieldName = field.parentFieldName;
         selectQueryDto.columnList.push(col);
         if (field !== null && field !== undefined && kony.sdk.util.matchIgnoreCase(field.type, "extendedfield")) {
           extendedFields.push(field);
           field = null;
         } else {
           columnsArr.push(columns[colIndex]);
         }
       }
     }
     var columnStr = selectQueryDto.appendListToQuery(columnsArr, ", ", 0);
     if (columnStr !== null && columnStr !== "") {
       query = query + columnStr;
     }
     //TODO have to modify the code based on latest metadata
     if (extendedFields !== null && extendedFields !== undefined && extendedFields.length !== 0) {
       var join = null;
       var table = null;
       var srcCol = null;
       var destCol = null;
       var joinType = kony.sdk.constants.JoinType.LEFT;
       var col = null;
       var colList = [];
       var extendedTablesAdded = {};
       for (var extIndex = 0; extIndex < extendedFields.length; extIndex++) {
         if (extendedTablesAdded !== null && extendedTablesAdded.hasOwnProperty(extendedFields[extIndex].parentTableName)) {
           extendedTablesAdded["" + extendedFields[extIndex].parentTableName] = ++extendedTablesAdded["" + extendedFields[extIndex].parentTableName];
         } else {
           extendedTablesAdded["" + extendedFields[extIndex].parentTableName] = 0;
         }
         table = new kony.sdk.dto.Table(extendedFields[extIndex].parentTableName);
         // Now add all extended field columns to the query
         col = new kony.sdk.dto.Column(table, extendedFields[extIndex].parentFieldName);
         colList.push(col);
         // Need to fetch the source table's primary key name from the metadata. For now hard coding it to 'id'
         //TODO
         srcCol = new kony.sdk.dto.Column(baseTable, extendedFields[extIndex].foreignKeyFieldName);
         destCol = new kony.sdk.dto.Column(table, extendedFields[extIndex].referencedField || "id");
         join = new kony.sdk.dto.Join(table, srcCol, destCol, joinType);
         if (join !== null && join !== undefined && extendedTablesAdded["" + extendedFields[extIndex].parentTableName] === 0) {
           extendedJoins.push(join);
         }
       }
       var extColStr = "";
       for (var i = 0; i < colList.length; i++) {
         extColStr = extColStr + colList[i].toString();
         if (i < colList.length - 1) {
           extColStr = extColStr + ",";
         }
       }
       if (extColStr !== null && extColStr !== "") {
         query = query + "," + extColStr;
       }
       if (extendedJoins !== null && extendedJoins !== undefined) {
         for (var joinIndex = 0; joinIndex < extendedJoins.length; joinIndex++) {
           selectQueryDto.addJoin(extendedJoins[joinIndex]);
         }
       }
     }
     query = query + " FROM ";
     query = query + selectQueryDto.getTables()[0].toString();
     if (selectQueryDto.getJoins().length !== 0) {
       var joinStr = selectQueryDto.appendListToQuery(selectQueryDto.joinList, " ", -1);
       query = query + joinStr;
     }
     if (!(selectQueryDto.criteriaList.length == 0)) {
       query = query + " WHERE ";
       query = query + selectQueryDto.appendListToQuery(selectQueryDto.criteriaList, " AND ", -1);
     }
     if (!(selectQueryDto.groupList.length == 0)) {
       query = query + " GROUP BY ";
       query = query + selectQueryDto.appendListToQuery(selectQueryDto.groupList, ", ", -1);
     }
     if (!(selectQueryDto.orderList.length == 0)) {
       query = query + " ORDER BY ";
       query = query + selectQueryDto.appendListToQuery(selectQueryDto.orderList, " ,", -1);
     }
     if (selectQueryDto.limit !== null && selectQueryDto.limit !== undefined && kony.sdk.util.isValidNumberType(selectQueryDto.limit) && selectQueryDto.limit !== 0) {
       query = query + " LIMIT " + selectQueryDto.limit;
     }
     if (selectQueryDto.skip !== null && selectQueryDto.skip !== undefined && kony.sdk.util.isValidNumberType(selectQueryDto.skip) && selectQueryDto.skip !== 0) {
       query = query + " OFFSET " + selectQueryDto.skip;
     }
     return query;
   };
   this.appendListToQuery = function(objectList, seperator, mode) {
     kony.sdk.logsdk.trace("Entering into kony.sdk.dto.appendListToQuery");
     var listBuffer = "";
     for (var i = 0; i < objectList.length; i++) {
       var obj = objectList[i];
       if (mode > -1) {
         if (obj !== null) {
           if (obj instanceof kony.sdk.dto.Column) {
             listBuffer = listBuffer.concat(obj.toString());
           } else {
             listBuffer = listBuffer.concat(obj.toString());
           }
         }
       } else if (obj !== null && obj !== undefined) {
         listBuffer = listBuffer.concat(obj.toString());
       }
       if (i < objectList.length - 1) {
         listBuffer = listBuffer.concat(seperator);
       }
     }
     return listBuffer;
   };
 };
 /**
  * This function is the Table constructor.
  * @param tableName
  * @param tableAlias
  * @param junctionType
  * @constructor
  */
 kony.sdk.dto.Table = function(tableName, tableAlias, junctionType) {
   kony.sdk.logsdk.trace("Entering into kony.sdk.dto.Table");
   this.name = tableName;
   this.alias = tableAlias;
   this.isjunction = junctionType;
   this.getAlias = function() {
     return this.alias;
   };
   /**
    * This function is used to set alias.
    *
    * @param alias
    */
   this.setAlias = function(alias) {
     this.alias = alias;
   };
   this.getName = function() {
     return this.name;
   };
   /**
    * This function is used to set name.
    *
    * @param name
    */
   this.setName = function(name) {
     this.name = name;
   };
   /**
    * This function is used to check object equality.
    *
    * @param obj
    * @return Boolean
    */
   this.equals = function(obj) {
     var areObjectsEqual = false;
     if (obj === null || obj === undefined) {
       areObjectsEqual = false;
     } else if (typeof(this) === typeof(obj)) {
       areObjectsEqual = true;
       if (this.hasAlias() && obj.hasAlias()) {
         areObjectsEqual = this.getAlias() === obj.getAlias();
       } else {
         areObjectsEqual = this.getName() === obj.getName();
       }
     } else {
       areObjectsEqual = false;
     }
     return areObjectsEqual;
   };
   this.getColumn = function(columnName) {
     return new kony.sdk.dto.Column(this, columnName);
   };
   /**
    * This function is used to check if alias is present or not.
    *
    * @return Boolean
    */
   this.hasAlias = function() {
     return (this.alias !== null && this.alias !== undefined);
   };
   /**
    * This function is used to convert to String.
    *
    * @return string
    */
   this.toString = function() {
     return this.getName() + (this.hasAlias() ? " " + this.getAlias() : "");
   };
   /**
    * This function is used to return if the table is a junction table.
    *
    * @return boolean
    */
   this.isJunction = function() {
     return (this.isjunction && this.isjunction == true);
   };
   /**
    * This function is used to set the type of table junction/non-junction table.
    *
    * @param junctionType
    */
   this.setJunction = function(junctionType) {
     this.isjunction = junctionType;
   };
 };
 /**
  * This function is a Column constructor
  * @param tableObj {@link kony.sdk.dto.Table}
  * @param colName
  * @constructor
  */
 kony.sdk.dto.Column = function(tableObj, colName) {
   kony.sdk.logsdk.trace("Entering into kony.sdk.dto.Column");
   if (tableObj instanceof kony.sdk.dto.Table) {
     this.aggregation = null;
     this.alias = null;
     this.dataType = null;
     this.name = null;
     this.table = null;
     if (colName !== undefined && colName !== null && typeof(colName) === "string") {
       this.name = colName;
     } else {
       //TODO
       //throw error
       kony.sdk.logsdk.error("### kony.sdk.dto.Column:: Error: colName is undefined");
     }
     this.table = tableObj;
   } else {
     //TODO
     //throw error
     kony.sdk.logsdk.error("### kony.sdk.dto.Column:: Error: tableObj is not an instance of kony.sdk.dto.Table");
   }
   this.getAggregation = function() {
     return this.aggregation;
   };
   this.setAggregation = function(aggregation) {
     this.aggregation = aggregation;
   };
   this.getAlias = function() {
     return this.alias;
   };
   this.setAlias = function(alias) {
     this.alias = alias;
   };
   this.getDataType = function() {
     return this.dataType;
   };
   this.setDataType = function(dataType) {
     this.dataType = dataType;
   };
   this.isComputedField = function() {
     return this.fieldComputed;
   };
   this.setComputedField = function(fieldComputed) {
     this.fieldComputed = fieldComputed;
   };
   this.getName = function() {
     return this.name;
   };
   this.setName = function(name) {
     if (name !== undefined && name !== null && typeof(name) === "string") {
       this.name = name;
     } else {
       //TODO
       //throw error
       kony.sdk.logsdk.error("### kony.sdk.dto.Column::setName:: Error: name is undefined");
     }
   };
   this.getTable = function() {
     return this.table;
   };
   this.setTable = function(table) {
     if (table instanceof kony.sdk.dto.Table) {
       this.table = table;
     } else {
       //TODO
       //throw error
       kony.sdk.logsdk.error("### kony.sdk.dto.Column:: Error: setTable is undefined");
     }
   };
   this.toStringByMode = function(mode) {
     var tableName = (this.getTable().getAlias() !== null && this.getTable().getAlias() !== undefined) ? this.getTable().getAlias() : this.getTable().getName();
     var constructedColumn = null;
     var constructDataType = null;
     var constructAlias = null;
     var constructAggregation = null;
     switch (mode) {
       case 0:
         if (this.getDataType() !== null && this.getDataType() !== undefined) {
           if (kony.sdk.util.matchIgnoreCase(this.getDataType(), "Integer")) {
             constructDataType = "CAST (" + tableName + "." + this.getName() + " AS INTEGER)";
           } else if (kony.sdk.util.matchIgnoreCase(this.getDataType(), "Numeric")) {
             constructDataType = "CAST (" + tableName + "." + this.getName() + " AS NUMERIC)";
           } else if (kony.sdk.util.matchIgnoreCase(this.getDataType(), "Date")) {
             constructDataType = "date(" + tableName + "." + this.getName() + ")";
           } else {
             constructDataType = tableName + "." + this.getName();
           }
         } else {
           constructDataType = tableName + "." + this.getName();
         }
         constructAlias = (this.getAlias() !== null && this.getAlias() !== undefined && this.getAlias() !== "") ? " AS " + this.getAlias() : "";
         constructAggregation = (this.getAggregation() === kony.sdk.constants.Aggregation.NONE || (this.getAggregation() === null || this.getAggregation() === undefined)) ? constructDataType : (this.isComputedField() ? this.getAggregation() : this.getAggregation() + "(" + constructDataType + ")");
         constructedColumn = constructAggregation + constructAlias;
         break;
       case 1:
         if (this.getDataType() !== null && this.getDataType() !== undefined) {
           if (kony.sdk.util.matchIgnoreCase(this.getDataType(), "STRING")) this.setDataType("text");
         }
         constructDataType = (this.getDataType() !== null && this.getDataType() !== undefined) ? "CAST (" + tableName + "." + this.getName() + " AS " + this.getDataType() + ")" : tableName + "." + this.getName();
         constructAggregation = (this.getAggregation() === kony.sdk.constants.Aggregation.NONE || (this.getAggregation() === null || this.getAggregation() === undefined)) ? constructDataType : (this.isComputedField() ? this.getAggregation() : this.getAggregation() + "(" + constructDataType + ")");
         constructedColumn = constructAggregation;
         break;
       case 2:
         constructedColumn = this.getName();
         break;
       case 3:
         constructedColumn = this.getName();
         break;
       default:
         if (this.getDataType() !== null && this.getDataType() !== undefined) {
           if (kony.sdk.util.matchIgnoreCase(this.getDataType(), "STRING")) this.setDataType("text");
         }
         constructDataType = (this.getDataType() !== null && this.getDataType() !== undefined) ? "CAST (" + tableName + "." + this.getName() + " AS " + this.getDataType() + ")" : tableName + "." + this.getName();
         constructAlias = (this.getAlias() !== null && this.getAlias() !== undefined) ? " AS " + this.getAlias() : "";
         constructAggregation = (this.getAggregation() === kony.sdk.constants.Aggregation.NONE || (this.getAggregation() === null || this.getAggregation() === undefined)) ? constructDataType : (this.isComputedField() ? this.getAggregation() : this.getAggregation() + "(" + constructDataType + ")");
         constructedColumn = constructAggregation + constructAlias;
         break;
     }
     return constructedColumn;
   };
   this.toString = function() {
     // To be removed later from here
     if (this.getDataType() !== null && this.getDataType() !== undefined) {
       if (kony.sdk.util.matchIgnoreCase(this.getDataType(), "STRING")) dataType = "text";
     }
     var tableName = (this.getTable().getAlias() !== null && this.getTable().getAlias() !== undefined && this.getTable().getAlias() !== "") ? this.getTable().getAlias() : this.getTable().getName();
     var constructedColumn = null;
     var constructDataType = null;
     var constructAggregation = null;
     if (this.getDataType() !== null && this.getDataType() !== undefined) {
       if (kony.sdk.util.matchIgnoreCase(this.getDataType(), "Integer")) {
         constructDataType = "CAST (" + tableName + "." + this.getName() + " AS INTEGER)";
       } else if (kony.sdk.util.matchIgnoreCase(this.getDataType(), "Numeric")) {
         constructDataType = "CAST (" + tableName + "." + this.getName() + " AS NUMERIC)";
       } else if (kony.sdk.util.matchIgnoreCase(this.getDataType(), "Date")) {
         constructDataType = "date(" + tableName + "." + this.getName() + ")";
       } else {
         if (!this.isComputedField()) constructDataType = tableName + "." + this.getName();
       }
     } else {
       if (!this.isComputedField()) constructDataType = tableName + "." + this.getName();
     }
     var constructAlias = (this.getAlias() !== null && this.getAlias() !== undefined && this.getAlias() !== "") ? " AS " + this.getAlias() : "";
     constructAggregation = (this.getAggregation() === kony.sdk.constants.Aggregation.NONE || (this.getAggregation() === null || this.getAggregation() === undefined)) ? constructDataType : (this.isComputedField() ? this.getAggregation() : this.getAggregation() + "(" + constructDataType + ")");
     constructedColumn = constructAggregation + constructAlias;
     return constructedColumn;
   };
   this.toStringByTablePrefix = function(includeTablePrefix) {
     if (includeTablePrefix) {
       return this.toString();
     } else {
       return this.getName();
     }
   }
 };
 /**
  * This Object represents a groupby clause in select query
  * @param columnObj {@link kony.sdk.dto.Column}
  * @constructor
  */
 kony.sdk.dto.Group = function(columnObj) {
   kony.sdk.logsdk.trace("Entering into kony.sdk.dto.Group");
   if (columnObj instanceof kony.sdk.dto.Column) {
     this.column = columnObj;
   }
   this.getColumn = function() {
     return this.column;
   };
   this.setColumn = function(column) {
     if (column instanceof kony.sdk.dto.Column) {
       this.column = column;
     }
   };
   this.toString = function() {
     var tableName = (this.column.getTable().getAlias() !== null && this.column.getTable().getAlias() !== undefined) ? this.column.getTable().getAlias() : this.column.getTable().getName();
     return tableName + "." + this.column.getName();
   };
 };
 /**
  * This Object represents JOINS used in kony.sdk.dto.SelectQuery
  * @constructor
  */
 kony.sdk.dto.Join = function() {
   kony.sdk.logsdk.trace("Entering into kony.sdk.dto.Join");
   this.criteria;
   this.table;
   this.joinType;
   var currentObject = this;
   if (arguments.length === 3) {
     getJoinByTableCriteriaAndJoinType(arguments[0], arguments[1], arguments[2]);
   } else if (arguments.length === 4) {
     getJoinByDestTableAndSrcColumnAndDestColumnAndJoinType(arguments[0], arguments[1], arguments[2], arguments[3]);
   }
   /**
    * This function is the Join constructor which has 3 arguments.
    *
    * @param table
    * @param criteria
    * @param joinType
    */
   function getJoinByTableCriteriaAndJoinType(table, criteria, joinType) {
     kony.sdk.logsdk.trace("Entering into getJoinByTableCriteriaAndJoinType");
     if (table instanceof kony.sdk.dto.Table && kony.sdk.util.validateCriteriaObject(criteria) && joinType !== null && joinType !== undefined && (joinType === kony.sdk.constants.JoinType.INNER || joinType === kony.sdk.constants.JoinType.LEFT)) {
       currentObject.table = table;
       currentObject.joinType = joinType;
       currentObject.criteria = criteria;
       return currentObject;
     } else {
       //TODO
       //throw error
       kony.sdk.logsdk.error("### kony.sdk.dto.Join::getJoinByTableCriteriaAndJoinType:: Error: Validation error at getJoinByTableCriteriaAndJoinType");
     }
   }
   /**
    * This function is the Join constructor which has 4 arguments.
    *
    * @param destTable
    * @param srcColumn
    * @param destColumn
    * @param joinTypeObj
    */
   function getJoinByDestTableAndSrcColumnAndDestColumnAndJoinType(destTable, srcColumn, destColumn, joinTypeObj) {
     kony.sdk.logsdk.trace("Entering into getJoinByDestTableAndSrcColumnAndDestColumnAndJoinType");
     if (destTable instanceof kony.sdk.dto.Table && srcColumn instanceof kony.sdk.dto.Column && destColumn instanceof kony.sdk.dto.Column && joinTypeObj !== null && joinTypeObj !== undefined && joinTypeObj !== '' && (joinTypeObj === kony.sdk.constants.JoinType.INNER || joinTypeObj === kony.sdk.constants.JoinType.LEFT)) {
       currentObject.table = destTable;
       currentObject.joinType = joinTypeObj;
       var criteria = new kony.sdk.dto.Match(srcColumn, kony.sdk.constants.MatchType.EQUALS, destColumn);
       currentObject.criteria = criteria;
       return currentObject;
     } else {
       //TODO
       //throw error
       kony.sdk.logsdk.error("### kony.sdk.dto.Join::getJoinByDestTableAndSrcColumnAndDestColumnAndJoinType:: Error: Validation error at getJoinByDestTableAndSrcColumnAndDestColumnAndJoinType");
     }
   }
   this.getCriteria = function() {
     return this.criteria;
   };
   this.setCriteria = function(criteria) {
     if (kony.sdk.util.validateCriteriaObject(criteria)) {
       this.criteria = criteria;
     }
   };
   this.getTable = function() {
     return this.table;
   };
   this.setTable = function(table) {
     if (table instanceof kony.sdk.dto.Table) {
       this.table = table;
     }
   };
   this.getJoinType = function() {
     return this.joinType;
   };
   this.setJoinType = function(joinType) {
     if (joinType !== null) {
       this.joinType = joinType;
     }
   };
   this.initCriteria = function(srcColumn, destColumn) {
     if ((srcColumn instanceof kony.sdk.dto.Column) && (destColumn instanceof kony.sdk.dto.Column)) {
       var criteria = new kony.sdk.dto.Match(srcColumn, kony.sdk.constants.MatchType.EQUALS, destColumn);
       this.setCriteria(criteria);
     } else {
       //TODO
       //throw error
       kony.sdk.logsdk.error("### kony.sdk.dto.Join::initCriteria:: Error: srcColumn or destColumn is not an isntanceof kony.sdk.dto.Column");
     }
   };
   this.toString = function() {
     var returnString = null;
     var temp = null;
     var join;
     if (kony.sdk.constants.JoinType.INNER == this.getJoinType()) {
       join = "INNER";
     } else if (kony.sdk.constants.JoinType.LEFT == this.getJoinType()) {
       join = "LEFT";
     } else if (kony.sdk.constants.JoinType.RIGHT == this.getJoinType()) {
       join = "RIGHT";
     }
     returnString = " " + join + " JOIN " + this.getTable().toString() + " ON ";
     temp = this.getCriteria().toString();
     returnString = returnString + temp;
     return returnString;
   };
 };
 /**
  * This function is the Order constructor.
  * @param columnObj
  * @param orderTypeObj
  */
 kony.sdk.dto.Order = function(columnObj, orderTypeObj) {
   kony.sdk.logsdk.trace("Entering into kony.sdk.dto.Order");
   if ((columnObj instanceof kony.sdk.dto.Column) && (orderTypeObj == kony.sdk.constants.OrderType.ASCENDING || orderTypeObj == kony.sdk.constants.OrderType.DESCENDING)) {
     this.column = columnObj;
     this.type = orderTypeObj;
     return this;
   } else {
     //TODO
     //throw error
     kony.sdk.logsdk.error("### kony.sdk.dto.Order:: Error: Validation error")
   }
   this.getColumn = function() {
     return this.column;
   };
   /**
    * This function is used to set column.
    *
    * @param column
    */
   this.setColumn = function(column) {
     if (column instanceof kony.sdk.dto.Column) {
       this.column = column;
     } else {
       //TODO
       //throw error
       kony.sdk.logsdk.error("### kony.sdk.dto.Order::setColumn: Error: column is not an instance of kony.sdk.dto.Column");
     }
   };
   this.getType = function() {
     return this.type;
   };
   /**
    * This function is used to set type.
    *
    * @param type
    */
   this.setType = function(type) {
     this.type = type;
   };
   /**
    * This function is used to convert to String.
    *
    * @return string
    */
   this.toString = function() {
     return this.column.toString() + " " + (this.type);
   };
 };
 /**
  * This function is used to check the range of values of columnObj
  * @param columnObj {@link kony.sdk.dto.Column}
  * @param colRange
  * @constructor
  */
 kony.sdk.dto.Between = function(columnObj, colRange) {
   kony.sdk.logsdk.trace("Entering into kony.sdk.dto.Between");
   this.column;
   this.range;
   if (columnObj instanceof kony.sdk.dto.Column && (colRange instanceof kony.sdk.dto.DateRange || colRange instanceof kony.sdk.dto.StringRange || colRange instanceof kony.sdk.dto.IntegerRange || colRange instanceof kony.sdk.dto.FloatRange)) {
     this.column = columnObj;
     this.range = colRange;
   } else {
     //TODO
     //throw error
     kony.sdk.logsdk.error("### kony.sdk.dto.Between:: Error: Vaildation error");
   }
   this.quote = function(str) {
     if (kony.sdk.util.isNull(str)) {
       return "null";
     }
     // var str1 = new String(str);
     var strBuf = [];
     strBuf.push('\'');
     for (var index = 0; index < str.length; index++) {
       var charItem = str.charAt(index);
       if (charItem == '\\' || charItem == '\"' || charItem == '\'') {
         // strBuf.concat('\\');
         strBuf.push('\\');
       }
       strBuf.push(charItem);
     }
     strBuf.push('\'');
     return strBuf.join("");
   };
   this.setColumn = function(column) {
     if (column instanceof kony.sdk.dto.Column) {
       this.column = column;
     } else {
       //TODO
       //throw error
       kony.sdk.logsdk.error("### kony.sdk.dto.Between::setColumn: Error:column is not an instance of kony.sdk.dto.Column");
     }
   };
   this.setRange = function(range) {
     if (range instanceof kony.sdk.dto.DateRange || range instanceof kony.sdk.dto.StringRange || range instanceof kony.sdk.dto.IntegerRange || range instanceof kony.sdk.dto.FloatRange) {
       this.range = range;
     } else {
       //TODO
       //throw error
       kony.sdk.logsdk.error("### kony.sdk.dto.Between::setRange: Error: Validation Error");
     }
   };
   this.getColumn = function() {
     return this.column;
   };
   this.getRange = function() {
     return this.range;
   };
   this.toString = function() {
     var returnStr = "";
     returnStr = this.getColumn().toString() + " Between " + this.getRange().toString();
     return returnStr;
   };
 };
 /**
  * This function is the DateRange constructor.
  * @param startDate
  * @param endDate
  */
 kony.sdk.dto.DateRange = function() {
   this.end;
   this.start;
   if (arguments.length === 2) {
     var startDate = arguments[0];
     var endDate = arguments[1];
     if (startDate instanceof Date && endDate instanceof Date) {
       this.start = startDate;
       this.end = endDate;
     } else {
       //TODO
       //throw error
       kony.sdk.logsdk.error("### kony.sdk.dto.DataRange:: Error: startDate or endDate is not an instance of Date");
     }
   } else if (arguments.length === 1) {
     var dateType = arguments[0];
     if (kony.sdk.util.validateDateTypeInput(dateType)) {
       var range = kony.sdk.util.getDateRange(dateType);
       if (range.length !== 2 || range[0] === 0 || range[1] === 0) {
         //TODO
         //throw error
         kony.sdk.logsdk.error("### kony.sdk.dto.DateRange:: Error: Validation Error");
       } else {
         this.start = range[0];
         this.end = range[1];
       }
     }
   }
   this.getEnd = function() {
     return this.end;
   };
   /**
    * This function is used to set End value.
    *
    * @param end
    */
   this.setEnd = function(end) {
     if (end instanceof Date) {
       var month = end.getMonth() + 1;
       var date = end.getDate();
       var hr = end.getHours();
       var min = end.getMinutes();
       var sec = end.getSeconds();
       if (month < 10) {
         month = "0" + month;
       }
       if (date < 10) {
         date = "0" + date;
       }
       if (hr < 10) {
         hr = "0" + hr;
       }
       if (min < 10) {
         min = "0" + min;
       }
       if (sec < 10) {
         sec = "0" + sec;
       }
       var endDate = end.getFullYear() + "-" + month + "-" + date + " " + hr + ":" + min + ":" + sec;
       this.end = endDate;
     } else {
       //TODO
       //throw error
       kony.sdk.logsdk.error("### kony.sdk.dto.DateRange::setEnd:: Error: end is not an instance of Date");
     }
   };
   this.getStart = function() {
     return this.start;
   };
   /**
    * This function is used to set start value.
    *
    * @param start
    */
   this.setStart = function(start) {
     if (start instanceof Date) {
       var month = start.getMonth() + 1;
       var date = start.getDate();
       var hr = start.getHours();
       var min = start.getMinutes();
       var sec = start.getSeconds();
       if (month < 10) {
         month = "0" + month;
       }
       if (date < 10) {
         date = "0" + date;
       }
       if (hr < 10) {
         hr = "0" + hr;
       }
       if (min < 10) {
         min = "0" + min;
       }
       if (sec < 10) {
         sec = "0" + sec;
       }
       var startDate = start.getFullYear() + "-" + month + "-" + date + " " + hr + ":" + min + ":" + sec;
       this.start = startDate;
     } else {
       //TODO
       //throw error
       kony.sdk.logsdk.error("### kony.sdk.dto.DateRange::setStart:: Error: start is not an instance of Date");
     }
   };
   /**
    * This function is used to convert to String.
    *
    * @return string
    */
   this.toString = function() {
     var returnString = null;
     returnString = "'" + this.start + "'" + " AND " + "'" + this.end + "'";
     return returnString;
   };
 };
 /**
  * This function is the DecimalRange constructor.
  * @param startDecimal
  * @param endDecimal
  */
 kony.sdk.dto.DecimalRange = function(startDecimal, endDecimal) {
   kony.sdk.logsdk.trace("Entering into kony.sdk.dto.DecimalRange");
   if ((endDecimal !== null && endDecimal !== undefined && typeof endDecimal === 'number') && (startDecimal !== null && startDecimal !== undefined && typeof startDecimal === 'number')) {
     this.end = endDecimal;
     this.start = startDecimal;
   } else {
     //TODO
     //throw error
     kony.sdk.logsdk.error("### kony.sdk.dto.DecimalRange:: Error: Validation Error");
   }
   this.getEnd = function() {
     return this.end;
   };
   /**
    * This function is used to set End value.
    *
    * @param end
    */
   this.setEnd = function(end) {
     if (end !== null && end !== undefined && typeof end === 'number') {
       this.end = end;
     } else {
       //TODO
       //throw error
       kony.sdk.logsdk.error("### kony.sdk.dto.DecimalRange::setEnd:: Error: Validation Error");
     }
   };
   this.getStart = function() {
     return this.start;
   };
   /**
    * This function is used to set start value.
    *
    * @param start
    */
   this.setStart = function(start) {
     if (start !== null && start !== undefined && typeof start === 'number') {
       this.start = start;
     } else {
       //TODO
       //throw error
       kony.sdk.logsdk.error("### kony.sdk.dto.DecimalRange::setStart:: Error: Validation Error");
     }
   };
   /**
    * This function is used to convert to String.
    *
    * @return string
    */
   this.toString = function() {
     var returnString = null;
     returnString = this.start + " AND " + this.end;
     return returnString;
   };
 };
 /**
  * This function is the FloatRange constructor.
  * @param startFloat
  * @param endFloat
  */
 kony.sdk.dto.FloatRange = function(startFloat, endFloat) {
   kony.sdk.logsdk.trace("Entering into kony.sdk.dto.FloatRange");
   this.end = endFloat;
   this.start = startFloat;
   this.getEnd = function() {
     return this.end;
   };
   /**
    * This function is used to set End value.
    *
    * @param end
    */
   this.setEnd = function(end) {
     if (end !== null && end !== undefined && typeof end === 'number') {
       this.end = end;
     } else {
       //TODO
       //throw error
       kony.sdk.logsdk.error("### kony.sdk.dto.FloatRange::setEnd:: Error: Validation Error");
     }
   };
   this.getStart = function() {
     return this.start;
   };
   /**
    * This function is used to set start value.
    *
    * @param start
    */
   this.setStart = function(start) {
     if (start !== null && start !== undefined && typeof start === 'number') {
       this.start = start;
     } else {
       //TODO
       //throw error
       kony.sdk.logsdk.error("### kony.sdk.dto.FloatRange::setStart:: Error: Validation Error");
     }
   };
   /**
    * This function is used to convert to String.
    *
    * @return string
    */
   this.toString = function() {
     var returnString = null;
     returnString = this.start + " AND " + this.end;
     return returnString;
   };
 };
 /**
  * This function is the IntegerRange constructor.
  * @param startInt
  * @param endInt
  */
 kony.sdk.dto.IntegerRange = function(startInt, endInt) {
   if ((endInt !== null && endInt !== undefined && typeof endInt === 'number') && (startInt !== null && startInt !== undefined && typeof startInt === 'number')) {
     this.end = endInt;
     this.start = startInt;
   } else {
     //TODO
     //throw error
     kony.sdk.logsdk.error("### kony.sdk.dto.IntegerRange:: Error: Validation Error");
   }
   this.getEnd = function() {
     return this.end;
   };
   /**
    * This function is used to set End value.
    *
    * @param end
    */
   this.setEnd = function(end) {
     if (end !== null && end !== undefined && typeof end === 'number') {
       this.end = end;
     } else {
       //TODO
       //throw error
       kony.sdk.logsdk.error("### kony.sdk.dto.IntegerRange::setEnd:: Error: Validation Error");
     }
   };
   this.getStart = function() {
     return this.start;
   };
   /**
    * This function is used to set start value.
    *
    * @param start
    */
   this.setStart = function(start) {
     if (start !== null && start !== undefined && typeof start === 'number') {
       this.start = start;
     } else {
       //TODO
       //throw error
       kony.sdk.logsdk.error("### kony.sdk.dto.IntegerRange::setStart:: Error: Validation Error");
     }
   };
   /**
    * This function is used to convert to String.
    *
    * @return string
    */
   this.toString = function() {
     var returnString = null;
     returnString = this.start.toFixed() + " AND " + this.end.toFixed();
     return returnString;
   };
 };
 /**
  * This function is the StringRange constructor.
  * @param startString
  * @param endString
  */
 kony.sdk.dto.StringRange = function(startString, endString) {
   kony.sdk.logsdk.trace("Entering into kony.sdk.dto.StringRange");
   if ((endString !== null && endString !== undefined && typeof endString === 'string') && (startString !== null && startString !== undefined && typeof startString === 'string')) {
     this.end = endString;
     this.start = startString;
   } else {
     //TODO
     //throw error
     kony.sdk.logsdk.error("### kony.sdk.dto.StringRange:: Error: Validation Error");
   }
   this.getEnd = function() {
     return this.end;
   };
   /**
    * This function is used to set End value.
    *
    * @param end
    */
   this.setEnd = function(end) {
     if (end !== null && end !== undefined && typeof end === 'string') {
       this.end = end;
     } else {
       //TODO
       //throw error
       kony.sdk.logsdk.error("### kony.sdk.dto.StringRange::setEnd:: Error: Validation Error");
     }
   };
   this.getStart = function() {
     return this.start;
   };
   /**
    * This function is used to set start value.
    *
    * @param start
    */
   this.setStart = function(start) {
     if (start !== null && start !== undefined && typeof start === 'string') {
       this.start = start;
     } else {
       //TODO
       //throw error
       kony.sdk.logsdk.error("### kony.sdk.dto.StringRange::setStart:: Error: Validation Error");
     }
   };
   /**
    * This function is used to convert to String.
    *
    * @return string
    */
   this.toString = function() {
     var returnString = null;
     var crit = new kony.sdk.dto.Criteria();
     returnString = crit.quote(this.start) + " AND " + crit.quote(this.end);
     return returnString;
   };
 };
 /**
  * This function helps in preparing And {@link kony.sdk.dto.And} and Or {@Link kony.sdk.dto.Or} clauses
  * @param operatorLg
  * @param leftOp
  * @param rightOp
  * @constructor
  */
 kony.sdk.dto.LogicGroup = function(operatorLg, leftOp, rightOp) {
   kony.sdk.logsdk.trace("Entering into kony.sdk.dto.LogicGroup");
   this.left = leftOp;
   this.operator = operatorLg;
   this.right = rightOp;
   /**
    * This function is used to initialize LogicGroup.
    *
    * @param operator
    * @param left
    * @param right
    */
   this.initializeLogicGroup = function(operator, left, right) {
     this.left = left;
     this.operator = operator;
     this.right = right;
   };
   this.getLeft = function() {
     return this.left;
   };
   /**
    * This function is used to set left.
    *
    * @param val
    */
   this.setLeft = function(val) {
     this.val = val;
   };
   this.getOperator = function() {
     return this.operator;
   };
   /**
    * This function is used to set Operator.
    *
    * @param val
    */
   this.setOperator = function(val) {
     this.operator = val;
   };
   this.getRight = function() {
     return this.right;
   };
   /**
    * This function is used to set Right.
    *
    * @param val
    */
   this.setRight = function(val) {
     this.right = val;
   };
   /**
    * This function is used to convert to String.
    *
    * @return string
    */
   this.toString = function() {
     var leftOperator = (this.getLeft() !== null && this.getLeft !== undefined) ? this.getLeft().toString() : "";
     var rightOperator = (this.getRight() !== null && this.getRight() !== undefined) ? this.getRight().toString() : "";
     return "(" + leftOperator + " " + this.getOperator() + " " + rightOperator + ")";
   };
 };
 /**
  * This function is the And constructor.
  *
  * @param left
  * @param right
  */
 kony.sdk.dto.And = function(left, right) {
   kony.sdk.logsdk.trace("Entering into kony.sdk.dto.And");
   if (arguments.length !== 2) {
     //TODO
     //throw error
     kony.sdk.logsdk.error("### kony.sdk.dto.And:: Error: invalid number of arguments, expected are left and right");
   }
   if ((right !== null && left !== null && right !== undefined && left !== undefined && kony.sdk.util.validateCriteriaObject(left) && kony.sdk.util.validateCriteriaObject(right))) {
     kony.sdk.dto.LogicGroup.call(this, 'AND', left, right);
   } else {
     //TODO
     //throw error
     kony.sdk.logsdk.error("### kony.sdk.dto.And:: Error: Validation Error");
   }
   this.initializeAnd = function(left, right) {
     kony.sdk.dto.LogicGroup.call(this, 'AND', left, right);
   };
 };
 /**
  * This function is the Or constructor.
  *
  * @param left
  * @param right
  */
 kony.sdk.dto.Or = function(left, right) {
   kony.sdk.logsdk.trace("Entering into kony.sdk.dto.Or");
   if (arguments.length !== 2) {
     //TODO
     //throw error
     kony.sdk.logsdk.error("### kony.sdk.dto.Or:: Error: invalid number of arguments, expected are left and right");
   }
   if ((right !== null && left !== null && right !== undefined && left !== undefined && kony.sdk.util.validateCriteriaObject(left) && kony.sdk.util.validateCriteriaObject(right))) {
     kony.sdk.dto.LogicGroup.call(this, 'OR', left, right);
   } else {
     //TODO
     //throw error
     kony.sdk.logsdk.error("### kony.sdk.dto.Or:: Error: Validation Error");
   }
   this.initializeOr = function(left, right) {
     kony.sdk.dto.LogicGroup.call(this, 'OR', left, right);
   };
 };
 /**
  * This function is the Not constructor.
  *
  * @param right
  */
 kony.sdk.dto.Not = function(right) {
   if (arguments.length !== 1) {
     //TODO
     //throw error
     kony.sdk.logsdk.error("### kony.sdk.dto.Not:: Error: invalid number of arguments, expected right");
   }
   if (right !== null && right !== undefined && kony.sdk.util.validateCriteriaObject(right)) {
     kony.sdk.dto.LogicGroup.call(this, 'NOT', null, right);
   } else {
     //TODO
     //throw error
     kony.sdk.logsdk.error("### kony.sdk.dto.Not:: Error: Validation Error");
   }
   this.initializeNot = function(right) {
     kony.sdk.dto.LogicGroup.call(this, 'NOT', null, right);
   };
 };
 /**
  * This function is a constructor for Expression Object
  * @constructor
  */
 kony.sdk.dto.Expression = function() {
   this.term;
   this.operator;
   this.expression;
   var currentExpObj = this;
   if (arguments.length === 1) {
     if (kony.sdk.util.validateCriteriaObject(arguments[0])) {
       setTerm(arguments[0]);
     } else {
       //TODO
       //throw error
       kony.sdk.logsdk.error("### kony.sdk.dto.Expression:: Error: Validation Error");
     }
   } else if (arguments.length === 2) {
     initExpression(arguments[0], arguments[1]);
   } else if (arguments.length === 3) {
     initExpressionByExpression(arguments[0], arguments[1], arguments[2]);
   } else {
     //TODO
     //throw error
     kony.sdk.logsdk.error("### kony.sdk.dto.Expression:: Error: invalid number of arguments, atleast 'term' is expected");
   }
   /**
    * Recursively generates a Expression from a given list of
    * criteria and an infix operator to join each criteria with the
    * next in the list. Operator AND or Operator OR that joins each
    * criteria term with the next in the list.
    *
    * @param criterias
    *            the list of criteria terms from which the
    *            constructor generates the new criteria expression.
    * @param operator
    *            the infix operator
    */
   function initExpression(criterias, operator) {
     if (operator === kony.sdk.constants.Operator.OR) {
       setOperator(kony.sdk.constants.Operator.OR);
     } else if (operator === kony.sdk.constants.Operator.AND) {
       setOperator(kony.sdk.constants.Operator.AND);
     } else {
       //TODO
       //throw error
       kony.sdk.logsdk.error("### kony.sdk.dto.Expression::initExpression:: Error: Invalid Operator");
     }
     if (criterias !== null && criterias !== undefined && criterias instanceof Array && criterias.length > 0) {
       if (kony.sdk.util.validateCriteriaObject(criterias[0])) {
         setTerm(criterias[0]);
       }
       if (criterias.length > 1) {
         var tmpOperator = operator;
         criterias.shift();
         setExpression(new kony.sdk.dto.Expression(criterias, tmpOperator));
       }
     } else {
       if (kony.sdk.util.validateCriteriaObject(criterias)) {
         setTerm(criterias);
         // return currentExpObj;
       } else {
         //TODO
         //throw error
         kony.sdk.logsdk.error("### kony.sdk.dto.Expression::initExpression:: Error: Validation Error");
       }
     }
   }

   function setExpression(expression) {
     if (expression instanceof kony.sdk.dto.Expression) {
       currentExpObj.expression = expression;
       // return currentExpObj;
     } else {
       //TODO
       //throw error
       kony.sdk.logsdk.error("### kony.sdk.dto.Expression::setExpression:: Error: expression not an instance of kony.sdk.do.Expression");
     }
   }

   function setTerm(term) {
     if (kony.sdk.util.validateCriteriaObject(term)) {
       currentExpObj.term = term;
       // return currentExpObj;
     } else {
       //TODO
       //throw error
       kony.sdk.logsdk.error("### kony.sdk.dto.Expression::setTerm:: Error: Validation Error");
     }
   }
   /**
    * Initializes a Expression with an initial criteria term, an
    * operator, and a another trailing criteria expression.
    *
    * @param criterias
    *            the starting criteria to assign to the new
    *            criteria expression.
    * @param operator
    *            the infix operator
    * @param expression
    *            the trailing expression to assign to the new
    *            criteria expression.
    */
   function initExpressionByExpression(criterias, operator, expression) {
     if (operator === kony.sdk.constants.Operator.OR) {
       initExpression(criterias, kony.sdk.constants.Operator.OR);
     } else if (operator === kony.sdk.constants.Operator.AND) {
       initExpression(criterias, kony.sdk.constants.Operator.AND);
     } else {
       //TODO
       //throw error
       kony.sdk.logsdk.error("### kony.sdk.dto.Expression::initExpressionByExpression:: Error: Invalid Operator");
     }
     setExpression(expression);
     // return currentExpObj;
   }

   function setOperator(operator) {
     currentExpObj.operator = operator;
   }
   this.getTerm = function() {
     return this.term;
   };
   this.getOperator = function() {
     return this.operator;
   };
   this.getExpression = function() {
     return this.expression;
   };
   this.toString = function() {
     var returnString = null;
     if ((this.getTerm() === null || this.getTerm() === undefined) && (this.getExpression() === null || this.getExpression() === undefined)) {
       returnString = "";
     } else if (this.getExpression() === null || this.getExpression() === undefined) {
       returnString = this.getTerm().toString();
     } else if (this.getOperator() === kony.sdk.constants.Operator.AND) {
       returnString = (new kony.sdk.dto.And(this.getTerm(), this.getExpression())).toString();
     } else if (this.getOperator() === kony.sdk.constants.Operator.OR) {
       returnString = (new kony.sdk.dto.Or(this.getTerm(), this.getExpression())).toString();
     }
     return returnString;
   }
 };
 /**
  * This function is a constructor for InCriteria Object
  * @constructor
  */
 kony.sdk.dto.InCriteria = function() {
   kony.sdk.logsdk.trace("Entering into kony.sdk.dto.InCriteria");
   this.column;
   this.values;
   var currentInCriteriaObj = this;
   if (arguments.length === 2) {
     getInCriteriaByColumnAndCollection(arguments[0], arguments[1]);
   } else if (arguments.length === 3) {
     getInCriteriaByTableAndCollection(arguments[0], arguments[1], arguments[2]);
   } else {
     //TODO
     //throw error
     kony.sdk.logsdk.error("### kony.sdk.dto.InCriteria:: Error: invalid number of arguments, atleast column,values are expected");
   }
   /**
    * This function is the InCriteria constructor which has 3
    * arguments.
    *
    * @param table
    * @param columnname
    * @param values
    */
   function getInCriteriaByTableAndCollection(table, columnname, values) {
     kony.sdk.logsdk.trace("Entering into getInCriteriaByTableAndCollection");
     if (table instanceof kony.sdk.dto.Table) {
       currentInCriteriaObj.column = new kony.sdk.dto.Column(table, columnname);
       currentInCriteriaObj.values = values;
       return currentInCriteriaObj;
     } else {
       //TODO
       //throw error
       kony.sdk.logsdk.error("### kony.sdk.dto.InCriteria::getInCriteriaByTableAndCollection:: Error: table is not an instance of kony.sdk.dto.Table");
     }
   }
   /**
    * This function is the InCriteria constructor which has 2
    * arguments.
    *
    * @param column
    * @param values
    */
   function getInCriteriaByColumnAndCollection(column, values) {
     kony.sdk.logsdk.trace("Entering into getInCriteriaByColumnAndCollection");
     if (column instanceof kony.sdk.dto.Column && values instanceof Array && values.length > 0) {
       currentInCriteriaObj.column = column;
       currentInCriteriaObj.values = values;
       return currentInCriteriaObj;
     } else {
       //TODO
       //throw error
       kony.sdk.logsdk.error("### kony.sdk.dto.InCriteria::getInCriteriaByColumnAndCollection:: Error: Validation Error");
     }
   }
   this.getColumnForTable = function(table, columnName) {
     if (table instanceof kony.sdk.dto.Table) {
       var column = new kony.sdk.dto.Column(table, columnName);
       return column;
     } else {
       //TODO
       //throw error
       kony.sdk.logsdk.error("### kony.sdk.dto.InCriteria::getColumnForTable:: Error: table not an instance of kony.sdk.dto.Table");
     }
   };
   this.getColumn = function() {
     return this.column;
   };
   this.setColumn = function(column) {
     if (column instanceof kony.sdk.dto.Column) {
       this.column = column;
     }
   };
   this.setValues = function(valuesCollection) {
     this.values = valuesCollection;
   };
   this.getValues = function() {
     return this.values;
   };
   this.toString = function() {
     var result = "";
     result = this.column.toString() + " IN (";
     if (this.values !== null && this.values !== undefined && this.values.length > 0) {
       for (var index = 0; index < this.values.length; index++) {
         var value;
         var criteria = new kony.sdk.dto.Criteria();
         if (typeof(this.values[index]) === "string") {
           value = criteria.quote(this.values[index]);
         } else {
           value = this.values[index];
         }
         result = result + value;
         if (index !== (this.values.length - 1)) {
           result = result + ", ";
         }
       }
     }
     /*
      * else if (this.subSelect !== null && this.subSelect !==
      * undefined) { result = result + this.subSelect; }
      */
     result = result + ")";
     return result;
   };
 };
 /**
  * This function is used to in set Exists param in select query
  * @param subSelectQuery {@link kony.sdk.dto.SelectQuery}
  * @constructor
  */
 kony.sdk.dto.Exists = function(subSelectQuery) {
   kony.sdk.logsdk.trace("Entering into kony.sdk.dto.Exists");
   if (subSelectQuery instanceof kony.sdk.dto.SelectQuery) {
     this.subSelect = subSelectQuery;
   } else {
     //TODO
     //throw error
     kony.sdk.logsdk.error("### kony.sdk.dto.Exists:: Error: subSelectQuery is not an instance of kony.sdk.dto.SelectQuery");
   }
   this.getSubSelect = function() {
     return this.subSelect;
   };
   this.setSubSelect = function(subSelect) {
     if (subSelect instanceof kony.sdk.dto.SelectQuery) {
       this.subSelect = subSelect;
     } else {
       //TODO
       //throw error
       kony.sdk.logsdk.error("### kony.sdk.dto.Exists::subSelectQuery:: Error: subSelectQuery is not an instance of kony.sdk.dto.SelectQuery");
     }
   };
   this.toString = function() {
     return "EXISTS ( " + this.subSelect.toString() + " )";
   };
 };
 /**
  * This is Interface to define where clauses
  * @constructor
  */
 kony.sdk.dto.Criteria = function() {
   kony.sdk.logsdk.trace("Entering into kony.sdk.dto.Criteria");
   this.quote = function(str) {
     if (str === null || str === undefined) {
       return "null";
     }
     // var str1 = new String(str);
     var strBuf = [];
     strBuf.push('\'');
     for (var index = 0; index < str.length; index++) {
       var charItem = str.charAt(index);
       if (charItem == '\\' || charItem == '\"' || charItem == '\'') {
         // strBuf.concat('\\');
         strBuf.push('\\');
       }
       strBuf.push(charItem);
     }
     strBuf.push('\'');
     return strBuf.join("");
   };
 };
 /**
  * This function is used to define where clause
  * @constructor
  */
 kony.sdk.dto.Match = function() {
   this.column;
   this.matchType;
   this.value;
   var currentMatchObj = this;
   if (arguments.length === 3) {
     initMatchByColumn(arguments[0], arguments[1], arguments[2]);
   } else if (arguments.length === 4) {
     initMatchByTableAndColName(arguments[0], arguments[1], arguments[2], arguments[3]);
   } else {
     //TODO
     //throw error
     kony.sdk.logsdk.error("### kony.sdk.dto.Match:: Error: Invalid number of arguments, atleast columnObj,matchType,value is required")
   }
   /**
    * This function is the Match constructor which has 3 arguments.
    *
    * @param columnObj
    * @param matchType
    * @param value
    */
   function initMatchByColumn(columnObj, matchType, value) {
     if (columnObj instanceof kony.sdk.dto.Column) {
       currentMatchObj.column = columnObj;
       if (matchType !== kony.sdk.constants.MatchType.EQUALS && matchType !== kony.sdk.constants.MatchType.GREATER && matchType !== kony.sdk.constants.MatchType.GREATEREQUAL && matchType !== kony.sdk.constants.MatchType.LESS && matchType !== kony.sdk.constants.MatchType.LESSEQUAL && matchType !== kony.sdk.constants.MatchType.STARTSWITH && matchType !== kony.sdk.constants.MatchType.CONTAINS && matchType !== kony.sdk.constants.MatchType.LIKE && matchType !== kony.sdk.constants.MatchType.ENDSWITH && matchType !== kony.sdk.constants.MatchType.NOTEQUAL && matchType !== kony.sdk.constants.MatchType.ISNULL && matchType !== kony.sdk.constants.MatchType.ISNOTNULL) {
         //TODO
         //throw error
         kony.sdk.logsdk.error("### kony.sdk.dto.Match::initMatchByColumn:: Error: Invalid MatchType");
       } else {
         if (matchType !== kony.sdk.constants.MatchType.ISNULL && matchType !== kony.sdk.constants.MatchType.ISNOTNULL) {
           // check if the value is passed or not except
           // for NULL and NOT NULL cases.
           if (value !== null && value !== undefined) {
             if (value instanceof Array && value.length <= 0) {
               //TODO
               //throw error
               kony.sdk.logsdk.error("### kony.sdk.dto.Match::initMatchByColumn:: Error: value is undefined ,null or empty object");
             }
             currentMatchObj.value = value;
           } else {
             //TODO
             //throw error
             kony.sdk.logsdk.error("### kony.sdk.dto.Match::initMatchByColumn:: Error: Invalid MatchType");
           }
         }
         currentMatchObj.matchType = matchType;
         return currentMatchObj;
       }
     } else {
       //TODO
       //throw error
       kony.sdk.logsdk.error("### kony.sdk.dto.Match::initMatchByColumn:: Error: columnObj is not an instance of kony.sdk.dto.Column");
     }
   }
   /**
    * This function is the Match constructor which has 4 arguments.
    *
    * @param tableObj
    * @param columnName
    * @param matchType
    * @param value
    */
   function initMatchByTableAndColName(tableObj, columnName, matchType, value) {
     // check for validity of tableObj
     if (tableObj instanceof kony.sdk.dto.Table) {
       // columnName should not empty or null or undefined.
       if (columnName !== null && columnName !== undefined && typeof(columnName) === 'string' && columnName.trim().length > 0) {
         currentMatchObj.column = tableObj.getColumn(columnName);
         if (matchType !== kony.sdk.constants.MatchType.EQUALS && matchType !== kony.sdk.constants.MatchType.GREATER && matchType !== kony.sdk.constants.MatchType.GREATEREQUAL && matchType !== kony.sdk.constants.MatchType.LESS && matchType !== kony.sdk.constants.MatchType.LESSEQUAL && matchType !== kony.sdk.constants.MatchType.STARTSWITH && matchType !== kony.sdk.constants.MatchType.CONTAINS && matchType !== kony.sdk.constants.MatchType.LIKE && matchType !== kony.sdk.constants.MatchType.ENDSWITH && matchType !== kony.sdk.constants.MatchType.NOTEQUAL && matchType !== kony.sdk.constants.MatchType.ISNULL && matchType !== kony.sdk.constants.MatchType.ISNOTNULL) {
           //TODO
           //throw error
           kony.sdk.logsdk.error("### kony.sdk.dto.Match::initMatchByTableAndColName:: Error: Invalid MatchType");
         } else {
           if (matchType !== kony.sdk.constants.MatchType.ISNULL && matchType !== kony.sdk.constants.MatchType.ISNOTNULL) {
             // check if the value is passed or not
             // except for NULL and NOT NULL cases.
             if (value !== null && value !== undefined) {
               currentMatchObj.value = value;
             } else {
               //TODO
               //throw error
               kony.sdk.logsdk.error("### kony.sdk.dto.Match::initMatchByTableAndColName:: Error: value is undefined ,null or empty object");
             }
           }
           currentMatchObj.matchType = matchType;
         }
         return currentMatchObj;
       } else {
         //TODO
         //throw error
         kony.sdk.logsdk.error("### kony.sdk.dto.Match::initMatchByTableAndColName:: Error: Invalid MatchType");
       }
     } else {
       //TODO
       //throw error
       kony.sdk.logsdk.error("### kony.sdk.dto.Match:: Error: columnObj is not an instance of kony.sdk.dto.Column");
     }
   }
   this.getColumn = function() {
     if (this.column !== null && this.column !== undefined) {
       return this.column;
     } else {
       //TODO
       //throw error
       kony.sdk.logsdk.error("### kony.sdk.dto.Match::getColumn:: Error: column is null or undefined");
     }
   };
   this.getMatchType = function() {
     if (this.matchType !== null && this.matchType !== undefined) {
       return this.matchType;
     } else {
       //TODO
       //throw error
       kony.sdk.logsdk.error("### kony.sdk.dto.Match::getMatchType:: Error: matchType is null or undefined");
     }
   };
   /**
    * This function is used to set match type.
    *
    * @param matchType
    */
   this.setMatchType = function(matchType) {
     this.matchType = matchType;
   };
   this.getValue = function() {
     return this.value;
   };
   /*
    * quote=function(value){ return "'"+value+"'"; }
    */
   /**
    * This function is used to convert to String.
    *
    * @return string
    */
   this.toString = function() {
     if (this.matchType !== null && this.matchType !== undefined && this.column !== null && this.column !== undefined) {
       var constructedMatch = null;
       var constructedValue = null;
       var type = this.matchType;
       var val = this.matchType.name;
       if (this.value instanceof Date) {
         var dateStr = "";
         var month = this.getValue().getMonth() + 1;
         var date = this.getValue().getDate();
         if (month < 10) {
           month = "0" + month;
         }
         if (date < 10) {
           date = "0" + date;
         }
         dateStr = this.getValue().getFullYear() + "-" + month + "-" + date;
         constructedMatch = "date(substr(" + this.getColumn().toString() + ",0,11)) " + this.getMatchType().value + "'" + dateStr + "'";
         return constructedMatch;
       }
       if (typeof(this.getValue()) === 'boolean') {
         if (this.getValue() === true) {
           return "(" + this.getColumn().toString() + " = 'true' OR " + this.getColumn().toString() + " = 1)";
         } else if (this.getValue() === false) {
           return "(" + this.getColumn().toString() + " = 'false' OR " + this.getColumn().toString() + " = 0)";
         } else {
           this.value = "'" + this.value + "'";
         }
       }
       constructedMatch = this.getColumn().toString() + " " + this.getMatchType().value + " ";
       if (typeof(this.getValue()) === 'string') {
         constructedValue = kony.sdk.util.replaceAll(this.getValue(), "'", "");
         if (kony.sdk.util.matchIgnoreCase(type.name, "STARTSWITH")) {
           constructedValue = constructedValue + "%";
         } else if (kony.sdk.util.matchIgnoreCase(type.name, "CONTAINS")) {
           constructedValue = "%" + constructedValue + "%";
         } else if (kony.sdk.util.matchIgnoreCase(type.name, "ENDSWITH")) {
           constructedValue = "%" + constructedValue;
         } else if (kony.sdk.util.matchIgnoreCase(type.name, "ISNULL")) {
           return "(lower(" + this.getColumn().toString() + ") = 'null' OR " + this.getColumn().toString() + " IS NULL)";
         } else if (kony.sdk.util.matchIgnoreCase(type.name, "ISNOTNULL")) {
           return "(lower(" + this.getColumn().toString() + ") != 'null' OR " + this.getColumn().toString() + " IS NOT NULL)";
         }
         constructedValue = new kony.sdk.dto.Criteria().quote(constructedValue);
       } else {
         if (kony.sdk.util.matchIgnoreCase(type.name, "ISNULL")) {
           return "(lower(" + this.getColumn().toString() + ") = 'null' OR " + this.getColumn().toString() + " IS NULL)";
         } else if (kony.sdk.util.matchIgnoreCase(type.name, "ISNOTNULL")) {
           return "(lower(" + this.getColumn().toString() + ") != 'null' OR " + this.getColumn().toString() + " IS NOT NULL)";
         }
         constructedValue = this.getValue().toString();
       }
       if (!(kony.sdk.util.matchIgnoreCase(type.name, "ISNULL") || kony.sdk.util.matchIgnoreCase(type.name, "ISNOTNULL"))) {
         constructedMatch = constructedMatch + constructedValue;
       }
       return constructedMatch;
     } else {
       //TODO
       //throw error
       kony.sdk.logsdk.error("### kony.sdk.dto.Match::toString:: Error: matchType is undefined");
     }
   }
 };
 /**
  * Method to create the sync service instance.
  * @returns {SyncService} sync service instance
  */
 kony.sdk.prototype.getSyncService = function() {
   throw new Exception(kony.sdk.errorConstants.SYNC_FAILURE, "Sync service is no longer supported ");
 }

 function OAuthHandler(serviceUrl, providerName, appkey, callback, type, options, isMFVersionCompatible) {
   if (options[kony.sdk.constants.IS_ENABLE_IDENTITY_PKCE] === true) {
     kony.sdk.pkceUtilityInstance = kony.sdk.util.getUtilityForPKCE();
     if (!kony.sdk.pkceUtilityInstance.initializePKCEObject()) {
       var err = kony.sdk.error.getErrObj(kony.sdk.errorcodes.pkce_params_generation_failed, kony.sdk.errormessages.pkce_params_generation_failed);
       var isErr = true;
       callback(null, null, null, isErr, err);
       return;
     }
   }
   var urlType = "/" + type + "/";
   var isSuccess = true;
   var isLogout = false;
   // This will make sure the scheduler to request tokens will be instantiated only once in the method handleRequestCallback.
   // In case of Google OAuth changes Identity returns the success_url, so page gets refreshed twice which will fail in instantiating the scheduler twice.
   var isLoginCallbackInvoked = false;
   if (options && options.hasOwnProperty("logout") && options["logout"] === true) {
     isLogout = true;
   }
   var slo = false;
   if (options && options.hasOwnProperty("slo") && options["slo"] === true) {
     slo = options["slo"];
   }
   var customQueryParamsForOAuth;
   if (options && options.hasOwnProperty(kony.sdk.constants.CUSTOM_QUERY_PARAMS_FOR_OAUTH)) {
     customQueryParamsForOAuth = kony.sdk.util.objectToQueryParams(options[kony.sdk.constants.CUSTOM_QUERY_PARAMS_FOR_OAUTH]);
   }
   var requestUrl;

   function appendCustomOAuthParamsToURL(url) {
     if (!kony.sdk.util.isNullOrEmptyString(customQueryParamsForOAuth)) {
       url = url + "&" + customQueryParamsForOAuth;
     }
     return url;
   }

   function constructURLIE11(crossPlatformBaseURL, identityOAuthUrl) {
     //Protocol param is to differentiate between http and https
     var protocolParam = 0;
     //Identity Server will route the final result be it success or error to Injected callback page
     if (identityOAuthUrl.indexOf("https") !== -1) {
       protocolParam = 1;
     }
     identityOAuthUrl = identityOAuthUrl.replace(/^https?:\/\//, '');
     //Invoking the identity through the injected Redirect Page to overcome IE imposed cross domain security restrictions.
     var finalRequestUrl = crossPlatformBaseURL + "/" + kony.sdk.constants.KNY_OAUTH_REDIRECT_HTML + "?" + kony.sdk.constants.KNY_OAUTH_REDIRECT_URL + "=" + encodeURIComponent(identityOAuthUrl) + "&" + kony.sdk.constants.KNY_OAUTH_PROTOCOL_PARAM + "=" + protocolParam;
     return finalRequestUrl;
   }
   if (typeof(XMLHttpRequest) !== 'undefined') {
     var _window = window;
     var _popup = null;
     var _listener = function(event) {
       var eventOrigin = event.origin;
       //checking whether the message(event) gets posted from the same origin as service url. This avoids handling of irrelevant
       //message. Without this check, any message with valid string content posted on window was getting processed. But, we
       //need to process the message posted from service url origin only
       if (!kony.sdk.util.isValidString(eventOrigin) || (serviceUrl.toLowerCase().indexOf(eventOrigin.toLowerCase()) < 0)) {
         return;
       }
       var _contents = event.data;
       /**
        MFSDK-3431 - Recieving post message event from other endpoints.
        This is a short term fix. Currently Identity sends us only string in post message event, later on they have to
        send json with some more keys giving us the knowledge of source
        */
       if (kony.sdk.util.isValidString(_contents) && !kony.sdk.isJson(_contents)) {
         _popup.close();
         _detachEvent();
         try {
           kony.sdk.logsdk.debug("### OAuthHandler::_listener received authorization code as " + _contents);
           var headers = {};
           if (type === "oauth2" || type === "saml") {
             headers[kony.sdk.constants.HTTP_CONTENT_HEADER] = kony.sdk.constants.CONTENT_TYPE_FORM_URL_ENCODED
           }
           var bodyParams = {
             code: _contents
           };
           if (!kony.sdk.isNullOrUndefined(kony.sdk.pkceUtilityInstance)) {
             bodyParams = kony.sdk.pkceUtilityInstance.appendAppVerifierInBodyParams(bodyParams);
           }
           callback(urlType + "token", bodyParams, headers);
         } catch (err) {
           kony.sdk.logsdk.error("exception ::" + err);
           failureCallback();
         }
       } else if (kony.sdk.isJson(_contents) || kony.sdk.util.isJsonObject(_contents)) {
         kony.sdk.logsdk.debug("### OAuthHandler::_listener received event.data in unknown format as " + JSON.stringify(_contents));
         //TODO - After Identity changes check for desired key in the json.
       }
     };
     var _attachEvent = function() {
       if (_window.addEventListener) {
         _window.addEventListener('message', _listener, false);
       } else if (_window.attachEvent) {
         _window.attachEvent('message', _listener);
       } else {
         throw new Exception(kony.sdk.errorConstants.INIT_FAILURE, "environment doesn't support event attaching");
       }
     };
     var _detachEvent = function() {
       if (_window.detachEvent) {
         _window.detachEvent('message', _listener);
       } else if (_window.removeEventListener) {
         _window.removeEventListener('message', _listener);
       } else {
         throw new Exception(kony.sdk.errorConstants.INIT_FAILURE, "environment doesn't support detaching an event");
       }
     };
     _attachEvent();
     if (isLogout) {
       requestUrl = serviceUrl + urlType + "logout?provider=" + providerName + "&appkey=" + appkey + "&slo=" + slo;
       // Due to the non-stickiness of SAML sessions, SID (session id) has to be passed
       // to identity server for logout to fetch session specific context.
       if (type == kony.sdk.constants.AUTH_PROVIDER_TYPE_SAML) {
         requestUrl += "&session_id=" + konyRef.idSid;
       }

       function handleLogoutInSPA() {
         callback(1);
         _popup.close();
         _detachEvent();
       }
       kony.timer.schedule("SPALogout", handleLogoutInSPA, 3, false);
     } else {
       requestUrl = serviceUrl + urlType + "login?provider=" + providerName + "&appkey=" + appkey;
       var appVersion = kony.sdk.getFabricAppVersion();
       if (!kony.sdk.isNullOrUndefined(appVersion)) {
         requestUrl += "&app_version=" + appVersion;
       }
       requestUrl = appendCustomOAuthParamsToURL(requestUrl);
       //Checking whether server is compatable to redirect to user defined callback url
       //Changes to support OAuth on IE11, MFSDK-3657
       if (kony.sdk.util.checkForIE11() && kony.sdk.util.isJsonObject(options) && options.hasOwnProperty(kony.sdk.constants.IE11_CROSS_DOMAIN_OAUTH_BASE_URL)) {
         requestUrl = constructURLIE11(stripTrailingCharacter(options[kony.sdk.constants.IE11_CROSS_DOMAIN_OAUTH_BASE_URL], "/"), requestUrl);
       }
       if (!kony.sdk.isNullOrUndefined(kony.sdk.pkceUtilityInstance)) {
         requestUrl = kony.sdk.pkceUtilityInstance.appendAppChallengeOnURL(requestUrl);
       }
     }
     if (kony.sdk.getPlatformName() === kony.sdk.constants.PLATFORM_THIN_CLIENT && options[kony.sdk.constants.NO_POP_UP] === true) {
       //we will not override success url value given by user
       if (requestUrl.indexOf(kony.sdk.constants.OAUTH_REDIRECT_SUCCESS_URL) === -1) {
         requestUrl = requestUrl + "&" + kony.sdk.constants.OAUTH_REDIRECT_SUCCESS_URL + "=" + kony.application.getBrowserProtocol() + "//" + kony.application.getBaseURL();
       }
       var loginHelperFunction = callback;
       var isError = false;
       var codeVerifierBodyParamsJSON = {};
       var metaDataManagerForLoginInSameWindow = options[kony.sdk.constants.METADATA_MANAGER_FOR_LOGIN_IN_SAME_WINDOW_OBJECT];
       if (kony.sdk.util.isPlatformPlainJS()) {
         if (!kony.sdk.isNullOrUndefined(appConfig)) {
           metaDataManagerForLoginInSameWindow.setItem(kony.sdk.constants.KEY_APPCONFIG_FOR_SINGLE_WINDOW_LOGIN, JSON.stringify(appConfig));
         } else {
           kony.sdk.logsdk.error("Appconfig is null or undefined.");
           var errorObject = kony.sdk.error.getSingleWindowLoginErrObj(kony.sdk.errorcodes.invalid_appconfig, kony.sdk.errormessages.invalid_appconfig);
           isError = true;
           metaDataManagerForLoginInSameWindow.destroy();
           loginHelperFunction(null, null, null, isError, errorObject);
           return;
         }
       }
       metaDataManagerForLoginInSameWindow.setItem(kony.sdk.constants.ENABLE_IDENTITY_PKCE, options[kony.sdk.constants.IS_ENABLE_IDENTITY_PKCE]);
       if (!kony.sdk.isNullOrUndefined(kony.sdk.pkceUtilityInstance)) {
         codeVerifierBodyParamsJSON = kony.sdk.pkceUtilityInstance.appendAppVerifierInBodyParams(codeVerifierBodyParamsJSON);
         metaDataManagerForLoginInSameWindow.saveAppVerifier(codeVerifierBodyParamsJSON, saveAppVerifierSuccessCallback, function(errorObject) {
           kony.sdk.logsdk.error("Failed to save app_verifier at middleware.");
           isError = true;
           metaDataManagerForLoginInSameWindow.destroy();
           loginHelperFunction(null, null, null, isError, errorObject);
         });
       } else {
         saveAppVerifierSuccessCallback();
       }

       function saveAppVerifierSuccessCallback() {
         if (!kony.sdk.isNullOrUndefined(kony.sdk.pkceUtilityInstance)) {
           kony.sdk.logsdk.info("app_verifier was saved at middleware");
         }
         metaDataManagerForLoginInSameWindow.saveMetaData();
         kony.sdk.logsdk.info("login metadata for no popup login was saved");
         var userCustomDataSaveHandle = options[kony.sdk.constants.CUSTOM_DATA_SAVE_HANDLE];
         if (kony.sdk.isNullOrUndefined(userCustomDataSaveHandle)) {
           //user does not want to store data before app lose context
           kony.sdk.logsdk.info("user has not provided" + kony.sdk.constants.CUSTOM_DATA_SAVE_HANDLE + ", we will proceed directly to auth");
           _openWindowInSelfMode();
         } else {
           if (typeof(userCustomDataSaveHandle) !== 'function') {
             kony.sdk.logsdk.error("user has provided" + kony.sdk.constants.CUSTOM_DATA_SAVE_HANDLE + " but argument type is not a function");
             var errorObject = kony.sdk.error.getSingleWindowLoginErrObj(kony.sdk.errorcodes.invalid_custom_data_save_handle, kony.sdk.errormessages.invalid_custom_data_save_handle);
             isError = true;
             metaDataManagerForLoginInSameWindow.destroy();
             loginHelperFunction(null, null, null, isError, errorObject);
             return;
           }
           kony.sdk.logsdk.info("calling user's " + kony.sdk.constants.CUSTOM_DATA_SAVE_HANDLE);
           userCustomDataSaveHandle(_openWindowInSelfMode, function(err) {
             kony.sdk.logsdk.error("Error occurred while performing customDataSaveHandle.");
             var errorObject = kony.sdk.error.getSingleWindowLoginErrObj(kony.sdk.errorcodes.custom_data_save_handle_failed, kony.sdk.errormessages.custom_data_save_handle_failed);
             isError = true;
             metaDataManagerForLoginInSameWindow.destroy();
             loginHelperFunction(null, null, null, isError, errorObject);
             return;
           })
         }

         function _openWindowInSelfMode() {
           var config = {};
           config[kony.sdk.constants.KEY_URL] = requestUrl;
           config[kony.sdk.constants.KEY_IS_SAME_WINDOW] = true;
           kony.application.openURLAsync(config);
         }
       }
     } else {
       if (kony.os.deviceInfo().name === kony.sdk.constants.PLATFORM_SPA && !kony.sdk.util.isMobileDevice() && kony.sdk.util.isPWAStandaloneOrFullscreen()) {
         _popup = kony.sdk.util.openPopupWindow(requestUrl, "");
       } else {
         _popup = _window.open(requestUrl);
       }
     }
   } else {
     var browserSF = null;
     var userDefined = false;
     var userDefinedBrowserOnSuccess = null;
     var userDefinedBrowserOnFailure = null;
     var userDefinedBrowserEvent = null;
     if (kony.sdk.util.hasBrowserWidget(options)) {
       browserSF = options[kony.sdk.constants.BROWSER_WIDGET];
       userDefined = true;
     } else if (options && options["UseDeviceBrowser"] && isMFVersionCompatible) {
       kony.sdk.util.OAuthCallback = callback;
       kony.sdk.util.OAuthType = type;
     } else {
       var formBasic = {
         id: "popUp",
         skin: null,
         isModal: false,
         transparencyBehindThePopup: 80,
         "layoutType": kony.flex.FREE_FORM,
         "needAppMenu": false
       };
       var formLayout = {
         containerWeight: 100,
         padding: [5, 5, 5, 5],
         "paddingInPixel": true
       };
       var formPSP = {
         "titleBar": true,
         "titleBarConfig": {
           "renderTitleText": true,
           "prevFormTitle": false,
           "titleBarLeftSideView": "button",
           "labelLeftSideView": "Back",
           "titleBarRightSideView": "none"
         },
         "titleBarSkin": "slTitleBar"
       };
       //to do.. this is a workaround for android browser issue.. need to refactor this code
       browserSF = new kony.ui.Browser({
         "id": "browserSF",
         "text": "Browser",
         "isVisible": true,
         "detectTelNumber": true,
         "screenLevelWidget": true,
         "left": "0%",
         "top": "0%",
         "width": "100%",
         "height": "100%",
         "enableZoom": false
       }, {}, {});
       var prevForm = kony.application.getCurrentForm();
       var oauthForm = new kony.ui.Form2(formBasic, formLayout, formPSP);
       oauthForm.add(browserSF);
       oauthForm.show();
     }
     var urlConf;
     var headersConf = kony.sdk.getDefaultHeaders();
     if (!kony.sdk.isNullOrUndefined(konyRef.currentClaimToken)) {
       headersConf[kony.sdk.constants.KONY_AUTHORIZATION_HEADER] = konyRef.currentClaimToken;
     }
     konyRef.appendGlobalHeaders(headersConf);
     requestUrl = serviceUrl + urlType;
     if (isLogout) {
       requestUrl += "logout?provider=" + providerName + "&appkey=" + appkey + "&slo=" + slo;
       // Due to the non-stickiness of SAML sessions, SID (session id) has to be passed
       // to identity server for logout to fetch session specific context.
       if (type == kony.sdk.constants.AUTH_PROVIDER_TYPE_SAML) {
         requestUrl += "&session_id=" + konyRef.idSid;
       }
     } else {
       requestUrl += "login?provider=" + providerName + "&appkey=" + appkey;
     }
     if (!kony.sdk.isNullOrUndefined(kony.sdk.getFabricAppVersion())) {
       requestUrl += "&app_version=" + kony.sdk.getFabricAppVersion();
     }
     if (isLogout) {
       userDefinedBrowserOnSuccess = browserSF.onSuccess;
       userDefinedBrowserOnFailure = browserSF.onFailure;
       browserSF.onSuccess = handleOAuthLogoutSuccessCallback;
       browserSF.onFailure = handleOAuthLogoutFailureCallback;
     } else {
       if (options && options["success_url"] && isMFVersionCompatible) requestUrl += "&success_url=" + options["success_url"];
       if (!kony.sdk.isNullOrUndefined(kony.sdk.pkceUtilityInstance)) {
         requestUrl = kony.sdk.pkceUtilityInstance.appendAppChallengeOnURL(requestUrl);
       }
       if (options && options["UseDeviceBrowser"] && isMFVersionCompatible) {
         kony.application.openURL(requestUrl);
         return;
       } else {
         isLoginCallbackInvoked = false;
         verifyAndStoreDefinedBrowserEvent(browserSF.handleRequest);
         browserSF.handleRequest = handleRequestCallback;
         requestUrl = appendCustomOAuthParamsToURL(requestUrl);
       }
     }
     urlConf = {
       URL: requestUrl,
       requestMethod: constants.BROWSER_REQUEST_METHOD_GET
     };
     if (!isLogout && Object.keys(headersConf).length > 0) {
       urlConf["headers"] = headersConf;
     }
     browserSF.requestURLConfig = urlConf;

     function resetBrowserOnSuccessandFailureEvents(browser) {
       //Resetting the overridden onSuccess and onFailure callbacks to user defined callbacks
       browser.onSuccess = userDefinedBrowserOnSuccess;
       browser.onFailure = userDefinedBrowserOnFailure;
     }

     function handleOAuthLogoutSuccessCallback(browser) {
       if (!userDefined) {
         var prevFormPostShow = prevForm.postShow;

         function postShowOverride() {
           oauthForm.destroy();
           if (prevFormPostShow) {
             prevFormPostShow();
           }
           prevForm.postShow = prevFormPostShow;
         }
         prevForm.postShow = postShowOverride;
         prevForm.show();
       }
       kony.sdk.isOAuthLogoutInProgress = false;
       callback(isSuccess);
       //Invoking user defined onSuccess event of browser widget
       if (!kony.sdk.isNullOrUndefined(userDefinedBrowserOnSuccess)) kony.sdk.verifyAndCallClosure(userDefinedBrowserOnSuccess, browser);
       resetBrowserOnSuccessandFailureEvents(browser);
     }

     function handleOAuthLogoutFailureCallback(browser) {
       kony.sdk.isOAuthLogoutInProgress = false;
       isSuccess = false;
       //Invoking user defined onFailure event of browser widget
       if (!kony.sdk.isNullOrUndefined(userDefinedBrowserOnFailure)) kony.sdk.verifyAndCallClosure(userDefinedBrowserOnFailure, browser);
       resetBrowserOnSuccessandFailureEvents(browser);
     }

     function displayPrevForm() {
       var prevFormPostShow = prevForm.postShow;

       function postShowOverride() {
         oauthForm.destroy();
         if (prevFormPostShow) {
           prevFormPostShow();
         }
         prevForm.postShow = prevFormPostShow;
       }
       prevForm.postShow = postShowOverride;
       prevForm.show();
     }

     function verifyAndStoreDefinedBrowserEvent(browserEvent) {
       if (browserEvent !== null) {
         userDefinedBrowserEvent = browserEvent;
       }
     }

     function verifyAndCallUserDefinedBrowserEvent(browserWidget, params) {
       if (userDefinedBrowserEvent !== null) {
         userDefinedBrowserEvent(browserWidget, params);
       }
     }

     function resetOAuthLoginUserDefinedBrowserEvent(browserWidget) {
       //Resetting the overridden onPageStarted/handleRequest callbacks to user defined callback after invoking /token call.
       //If not reset, when the user does login next time using same browser widget, overridden SDK's handleRequestCallback
       //is considered as user defined callback on these events. This ends up calling handleRequestCallback again.
       browserWidget.handleRequest = userDefinedBrowserEvent;
     }

     function handleRequestCallback(browserWidget, params) {
       var originalUrl = params["originalURL"];
       if (originalUrl.toLowerCase().indexOf(serviceUrl.toLowerCase()) >= 0) {
         if (!isLoginCallbackInvoked && !kony.sdk.isNullOrUndefined(params.queryParams) && !kony.sdk.isNullOrUndefined(params.queryParams.code)) {
           if (!kony.sdk.isNullOrUndefined(kony.sdk.pkceUtilityInstance) && kony.sdk.isNullOrUndefined(params.queryParams.oauth_session_id)) {
             verifyAndCallUserDefinedBrowserEvent(browserWidget, params);
             return false;
           }
           if (!userDefined) {
             displayPrevForm();
           }
           var headers = {};
           if (type === "oauth2" || type === "saml") {
             headers[kony.sdk.constants.HTTP_CONTENT_HEADER] = kony.sdk.constants.CONTENT_TYPE_FORM_URL_ENCODED;
           }
           if (!isLoginCallbackInvoked) {
             // make request for tokens
             kony.timer.schedule(new Date().getTime().toString(), function(url, callback, code, headers) {
               return function() {
                 var bodyParams = {
                   code: code
                 };
                 if (!kony.sdk.isNullOrUndefined(kony.sdk.pkceUtilityInstance)) {
                   bodyParams = kony.sdk.pkceUtilityInstance.appendAppVerifierInBodyParams(bodyParams);
                 }
                 if (!(kony.sdk.isNullOrUndefined(kony.sdk.pkceUtilityInstance) || kony.sdk.isNullOrUndefined(params.queryParams.oauth_session_id))) {
                   bodyParams.oauth_session_id = params.queryParams.oauth_session_id;
                 }
                 callback(url, bodyParams, headers);
               };
             }(urlType + "token", callback, decodeURIComponent(params.queryParams.code), headers), 1, false);
             isLoginCallbackInvoked = true;
           }
         } else if (!isLoginCallbackInvoked && typeof(params.queryParams) !== "undefined" && typeof(params.queryParams.error) !== "undefined") {
           if (!userDefined) {
             displayPrevForm();
           }
           isLoginCallbackInvoked = true;
           callback(urlType, {
             error: decodeURIComponent(params.queryParams.error)
           }, headers, true);
         }
       }
       verifyAndCallUserDefinedBrowserEvent(browserWidget, params);
       if (isLoginCallbackInvoked) {
         resetOAuthLoginUserDefinedBrowserEvent(browserWidget);
       }
       return false;
     }
   }
 }
 /**
  * Handles the deeplink callback, this needs to be called once deep link redirection is done.
  * @param {json} params parameters from Identity service - "code": HashValue
  */
 function handleDeeplinkCallback(params) {
   if (params && kony.sdk.isValidDeeplinkCallback(params)) {
     var headers = {};
     var requestUrl;
     if (kony.sdk.util.OAuthType === "oauth2" || kony.sdk.util.OAuthType === "saml") {
       headers[kony.sdk.constants.HTTP_CONTENT_HEADER] = kony.sdk.constants.CONTENT_TYPE_FORM_URL_ENCODED;
     }
     if (kony.sdk.util.OAuthType === "oauth2") {
       requestUrl = "/oauth2/token";
     } else if (kony.sdk.util.OAuthType === "saml") {
       requestUrl = "/saml/token";
     } else {
       requestUrl = "/login";
     }
     // make request for tokens
     var bodyParams = {
       code: decodeURIComponent(params.launchparams.code)
     };
     if (!kony.sdk.isNullOrUndefined(kony.sdk.pkceUtilityInstance)) {
       bodyParams = kony.sdk.pkceUtilityInstance.appendAppVerifierInBodyParams(bodyParams);
     }
     if (!kony.sdk.isNullOrUndefined(params.launchparams.oauth_session_id)) {
       bodyParams.oauth_session_id = params.launchparams.oauth_session_id;
     }
     kony.sdk.util.OAuthCallback(requestUrl, bodyParams, headers);
   }
 }
 if (kony.sdk) {
   kony.sdk.offline = {};
 }
 //defined constants related to offline authentication.
 kony.sdk.offline.isOfflineEnabled = false;
 kony.sdk.offline.persistToken = false;
 kony.sdk.constants.iterations = 1024;
 kony.sdk.constants.keyLength = 256;
 /**
  *	This API is to be used to store the user login success response to the device and read it in the offline auth success scenario.
  */
 kony.sdk.offline.saveUserAuthInformation = function(dbKey, authResponse) {
   //validating arguments
   if (kony.sdk.isNullOrUndefined(dbKey) || typeof(dbKey) != "string" || dbKey.length === 0 || kony.sdk.isNullOrUndefined(authResponse) || typeof(authResponse) != "object" || Object.keys(authResponse).length === 0) {
     kony.sdk.logsdk.warn("### kony.sdk.offline.saveUserAuthInformation invalid arguments passed, returning");
     return;
   }
   var stringifiedResponse = JSON.stringify(authResponse);
   var encryptedAuthResponse = kony.sdk.util.encryptText(stringifiedResponse, [kony.sdk.util.getSharedClientId()], kony.sdk.constants.ENCRYPTION_ALGO_AES);
   kony.sdk.dataStore.setItem(dbKey, encryptedAuthResponse);
   kony.sdk.logsdk.info("saved auth info from the login success response");
 };
 /**
  *	This API is to be used to retrieve the user login success response to the device and read it in the offline auth success scenario.
  */
 kony.sdk.offline.getUserAuthInformation = function(dbKey) {
   var decryptedAuthResponse = null;
   var encryptedAuthResponse;
   if (!kony.sdk.isNullOrUndefined(dbKey) && typeof(dbKey) == "string") encryptedAuthResponse = kony.sdk.dataStore.getItem(dbKey);
   if (!kony.sdk.isNullOrUndefined(encryptedAuthResponse)) {
     decryptedAuthResponse = kony.sdk.util.decryptText(encryptedAuthResponse, [kony.sdk.util.getSharedClientId()], kony.sdk.constants.ENCRYPTION_ALGO_AES);
     if (kony.sdk.isNullOrUndefined(decryptedAuthResponse) || decryptedAuthResponse === '') {
       kony.sdk.offline.removePersistedUserAuthInformation();
     }
   }
   return decryptedAuthResponse;
 };
 /**
  *	This Utility API is to enable the developer read the claims token when the device is in offline mode.
  */
 kony.sdk.offline.getClaimsToken = function() {
   var userAuthInfoStr = kony.sdk.offline.getUserAuthInformation("authResponse");
   if (userAuthInfoStr != null && userAuthInfoStr != undefined) {
     var userAuthInfo = JSON.parse(userAuthInfoStr);
     return userAuthInfo.claims_token;
   }
   return null;
 };
 /**
  *	This Utility API is to update the the backend token.
  */
 kony.sdk.offline.updatePersistedToken = function(data) {
   var userAuthInfoStr = kony.sdk.offline.getUserAuthInformation(kony.sdk.constants.PERSISTED_AUTH_RESPONSE);
   if (userAuthInfoStr != null && userAuthInfoStr != undefined) {
     kony.sdk.offline.saveUserAuthInformation(kony.sdk.constants.PERSISTED_AUTH_RESPONSE, data);
   }
 };
 /**
  * Utility method to get persistToken flag from data store.
  */
 kony.sdk.offline.isPersistentLoginResponseEnabled = function() {
   var persistTokenFlag = kony.sdk.dataStore.getItem(kony.sdk.constants.PERSIST_LOGIN_RESPONSE_FLAG);
   if (!kony.sdk.isNullOrUndefined(persistTokenFlag) && persistTokenFlag === true) {
     return true;
   }
   return false;
 }
 kony.sdk.offline.removePersistedUserAuthInformation = function() {
   kony.store.removeItem(kony.sdk.constants.PERSISTED_AUTH_RESPONSE);
 };
 /**
  *  Stubs for offline login for spa and windows
  */
 kony.sdk.offline.loginOffline = function(providerName, successCallback, errorCallback) {
   kony.sdk.logsdk.warn("kony.sdk.offline.loginOffline:: Offline login not supported for spa and windows.");
   errorCallback(kony.sdk.error.getClientErrObj(kony.sdk.errorcodes.offline_auth_failed, kony.sdk.errormessages.offline_auth_failed));
 };
 kony.sdk.offline.saveTempUserCredentials = function(options) {
   kony.sdk.logsdk.warn("kony.sdk.offline.saveTempUserCredentials:: Offline login is not supported for spa and windows.");
   return null;
 };
 kony.sdk.offline.updateAuthToken = function(data) {
   kony.sdk.logsdk.warn("kony.sdk.offline.updateAuthToken:: Offline login is not supported for spa and windows.");
   return null;
 };
 kony.sdk.offline.updateSuccessUserCredentials = function(providerName) {
   kony.sdk.logsdk.warn("kony.sdk.offline.updateSuccessUserCredentials:: Offline login is not supported for spa and windows.");
   return null;
 };
 kony.sdk.offline.removeUserAuthInformation = function() {
   kony.sdk.logsdk.warn("kony.sdk.offline.removeUserAuthInformation:: Offline login is not supported for spa and windows.");
   return null;
 };
 kony.sdk.offline.removeUserCredentials = function(providerName) {
   kony.sdk.logsdk.warn("kony.sdk.offline.removeUserCredentials:: Offline login is not supported for spa and windows.");
   return null;
 };
 /**
  * Created by Tharalika Palakurthy
  */
 /**
  * Created by Chirag Mantri
  */
 /**
  * Save the SSO Token in storage
  */
 kony.sdk.util.saveSSOToken = function(SSOToken) {
   kony.sdk.logsdk.trace("Entered Method : saveSSOToken.");
   if (!kony.sdk.isNullOrUndefined(SSOToken)) {
     kony.sdk.util.saveSSOTokenInLocalStorage(kony.sdk.constants.DW_SSO_TOKEN_KEY, kony.sdk.util.encryptSSOToken(SSOToken));
     return true;
   } else {
     kony.sdk.logsdk.warn("SSO token is either empty, null or undefined to save");
     return false;
   }
 };
 /**
  * Get the SSO Token from storage
  */
 kony.sdk.util.getSSOToken = function() {
   kony.sdk.logsdk.trace("Entered Method : getSSOToken.");
   var tokenString = kony.sdk.util.getSSOTokenFromLocalStorage(kony.sdk.constants.DW_SSO_TOKEN_KEY);
   if (kony.sdk.util.isNullOrEmptyString(tokenString)) {
     return null;
   }
   var decryptedToken = kony.sdk.util.decryptSSOToken(tokenString);
   if (!kony.sdk.util.isNullOrUndefinedOrEmptyObject(decryptedToken)) {
     return decryptedToken;
   } else {
     return null;
   }
 };
 /**
  * Delete all SSO Tokens in storage
  */
 kony.sdk.util.deleteSSOToken = function() {
   kony.sdk.logsdk.trace("Entered Method : deleteSSOToken.");
   var tokenString = kony.sdk.util.getSSOTokenFromLocalStorage(kony.sdk.constants.DW_SSO_TOKEN_KEY);
   if (kony.sdk.util.isNullOrEmptyString(tokenString)) {
     kony.sdk.logsdk.debug("SSO token found to be empty.");
     return;
   }
   //Deleting all SSO tokens from local storage.
   kony.sdk.util.saveSSOTokenInLocalStorage(kony.sdk.constants.DW_SSO_TOKEN_KEY, "");
   kony.sdk.logsdk.trace("All SSO tokens deleted.");
 };
 /**
  * Wrapper to save SSO token via localstorage API
  *
  * @param key
  * @param value
  */
 kony.sdk.util.saveSSOTokenInLocalStorage = function(key, value) {
   if (!kony.sdk.isNullOrUndefined(key)) {
     if (!kony.sdk.isNullOrUndefined(value)) {
       localStorage.setItem(key, value);
     } else {
       kony.sdk.logsdk.warn("value passed cannot be null or undefined.");
     }
   } else {
     kony.sdk.logsdk.warn("key passed cannot be null or undefined.");
   }
 };
 /**
  * Wrapper to get SSO token via localstorage API
  *
  * @param key
  */
 kony.sdk.util.getSSOTokenFromLocalStorage = function(key) {
   if (!kony.sdk.isNullOrUndefined(key)) {
     return localStorage.getItem(key);
   } else {
     kony.sdk.logsdk.warn("key passed cannot be null or undefined.");
   }
 };
 /**
  * Returns a unique identifier for device to encrypt/decrypt sso token.
  * Android & iOS SDK is generating a UUID if not exist and share accross multiple applications.
  * This UUID is used as a secure key for encrypting/decrypting tokens.
  * @return {string}
  * @private
  */
 kony.sdk.util.getAndSaveUUIDforSSO = function() {
   var deviceUUID = kony.sdk.util.getSSOTokenFromLocalStorage(kony.sdk.constants.SSO_SECRET_KEY);
   if (kony.sdk.util.isNullOrUndefinedOrEmptyObject(deviceUUID)) {
     deviceUUID = kony.license.generateUUID().toString();
     kony.sdk.util.saveSSOTokenInLocalStorage(kony.sdk.constants.SSO_SECRET_KEY, deviceUUID);
   }
   return deviceUUID;
 };
 var KNYMobileFabric = null;
 var KNYMetricsService = null;
 var KNYMessagingService = null;
 kony.setupsdks = function(initConfig, successCallBack, errorCallBack) {
   var acceptedSvcDoc = {};
   var acceptedMfAppMetaData = null;
   // Function to get appMetadata from cache if available else it should create metadata
   //  from appConfig in startup.js (metadata bundled by tools during build time)
   function getAppConfigFromCache() {
     var dsAppConfig;
     var dsAppData = null;
     var dsAppMetaData = null;
     var dsAppServiceDoc = null;
     // Clear app Meta data if developer has set kony.sdk.clearAppCredentials as true
     if (kony.sdk.clearAppCredentials === true) {
       kony.sdk.dataStore.removeItem(initConfig.appConfig.appId);
     } else {
       dsAppData = kony.sdk.dataStore.getItem(appConfig.appId);
       dsAppServiceDoc = kony.sdk.dataStore.getItem(kony.sdk.util.prefixAppid(kony.sdk.constants.MOBILE_FABRIC_SERVICE_DOC));
     }
     if (!kony.sdk.isNullOrUndefined(dsAppData)) {
       dsAppMetaData = JSON.parse(dsAppData);
     } else {
       kony.sdk.logsdk.debug("Failed to retrieve config data form Cache");
       return null;
     }
     //create meta data from retrieved cache
     if (!kony.sdk.isNullOrUndefined(dsAppMetaData)) {
       if (kony.sdk.util.isAppConfigEncrypted()) {
         var appKey = kony.sdk.util.decryptAppConfig(dsAppMetaData.appKey);
         var appSecret = kony.sdk.util.decryptAppConfig(dsAppMetaData.appSecret);
         var serviceUrl = kony.sdk.util.decryptAppConfig(dsAppMetaData.serviceUrl);
         if (!kony.sdk.isNullOrUndefined(appKey) || !kony.sdk.isNullOrUndefined(appSecret) || !kony.sdk.isNullOrUndefined(serviceUrl) || !kony.sdk.isNullOrUndefined(dsAppServiceDoc)) {
           //update the decrypted values back in dsAppMetaData
           dsAppMetaData.appKey = appKey;
           dsAppMetaData.appSecret = appSecret;
           dsAppMetaData.serviceUrl = serviceUrl;
         } else {
           kony.sdk.logsdk.debug("Failed to retrieve config data form Cache");
           return null;
         }
         //decrypting the service doc here, to avoid data inconsistency
         if (!kony.sdk.isNullOrUndefined(dsAppServiceDoc)) {
           var decryptedSvcDoc = kony.sdk.util.decryptAppConfig(dsAppServiceDoc);
           if (!kony.sdk.isNullOrUndefined(decryptedSvcDoc)) {
             try {
               dsAppServiceDoc = JSON.parse(decryptedSvcDoc);
             } catch (err) {
               kony.sdk.logsdk.debug("Failed to parse the service doc : ", err.toString());
               return null;
             }
           } else {
             kony.sdk.logsdk.debug("Failed to decrypt cached service doc");
             return null;
           }
         } else {
           kony.sdk.logsdk.debug("Failed to retrieve service doc form Cache");
           return null;
         }
       } else {
         // App getting crashed while trying to parse encrypted AppServiceDoc data.
         // To handle this scenario adding try catch and checking for salt key. If salt key is available
         // setting flag to true and calling same getAppConfigFromCache() again to decrypt the data else returning null
         try {
           dsAppServiceDoc = JSON.parse(dsAppServiceDoc);
         } catch (err) {
           if (!kony.sdk.isNullOrUndefined(kony.sdk.dataStore.getItem(kony.sdk.util.prefixAppid(kony.sdk.constants.SHARED_CLIENT_IDENTIFIER)))) {
             kony.sdk.logsdk.debug("Setting Encryption App Config flag to true");
             kony.sdk.dataStore.setItem(kony.sdk.util.prefixAppid(kony.sdk.constants.ENCRYPTION_APPCONFIG_FLAG), true);
             return getAppConfigFromCache();
           } else {
             kony.sdk.logsdk.debug("Failed to parse App Service Doc data form Cache" + err);
             return null;
           }
         }
       }
     } else {
       kony.sdk.logsdk.debug("Failed to retrieve config data form Cache");
       return null;
     }
     dsAppConfig = {
       "dsAppMetaData": dsAppMetaData,
       "dsAppServiceDoc": dsAppServiceDoc
     };
     return dsAppConfig;
   }
   // Function to create an SDK object and set client params
   //  with client application's appId and appName
   function initializeKNYMobileFabricObject(appId, appName, appVersion) {
     var sdkObj = new kony.sdk();
     sdkObj.setClientParams({
       "aid": appId,
       "aname": appName,
       "aversion": appVersion
     });
     return sdkObj;
   }
   // Function to create session url (IST) for non-MF app
   function getLicenseUrl(appConfig) {
     var url = "";
     if (appConfig.isturlbase) {
       url = appConfig.isturlbase + "/IST";
     } else if (appConfig.secureurl) {
       url = getFromServerUrl(appConfig.secureurl, "IST");
     } else if (appConfig.url) {
       url = getFromServerUrl(appConfig.url, "IST");
     }
     return url;
   }
   // Function to create session url (IST) for non-MF app
   function getMetricsUrl(appConfig) {
     var url = "";
     if (appConfig.isturlbase) {
       url = appConfig.isturlbase + "/CMS";
     } else if (appConfig.secureurl) {
       url = getFromServerUrl(appConfig.secureurl, "CMS");
     } else if (appConfig.url) {
       url = getFromServerUrl(appConfig.url, "CMS");
     }
     return url;
   }
   // Function to make anonymous login if required.
   function callAnonymousLoginIfRequired(sdkObj) {
     if (kony.sdk.skipAnonymousCall) {
       // Enabling this flag to connect to any protected integration service.
       sdkObj.isAnonymousProvider = true;
     } else {
       var identityObject = sdkObj.getIdentityService("$anonymousProvider");
       identityObject.login(null, function(res) {
         kony.sdk.logsdk.trace("Anonymous login finished successfully.");
       }, function(res) {
         kony.sdk.logsdk.warn("Anonymous login finished with failure. \n" + JSON.stringify(res));
       });
     }
   };
   // Function to initialize Metrics Service for APM
   function initializeMetricsForAPM(sdkObj, eventTypes) {
     var metricsService = sdkObj.getMetricsService();
     if (!kony.sdk.isNullOrUndefined(metricsService)) {
       metricsService.setEventTracking(eventTypes);
     }
     return metricsService;
   }
   //Picking default values from startup.js
   acceptedSvcDoc = initConfig.appConfig.svcDoc;
   acceptedMfAppMetaData = {
     "appKey": initConfig.appKey,
     "appSecret": initConfig.appSecret,
     "serviceUrl": initConfig.serviceUrl
   };
   // Fetching data from cache
   var cachedAppConfig = getAppConfigFromCache();
   // Picking the latest appKey, appSecret and ServiceDoc for initialization
   // with respect to the latest published fabric app, if cached.
   if (!kony.sdk.util.isNullOrUndefinedOrEmptyObject(cachedAppConfig)) {
     var cachedSvcDoc = cachedAppConfig.dsAppServiceDoc;
     var cachedMfAppMetaData = cachedAppConfig.dsAppMetaData;
     // Checking for same Fabric app and version
     if ((cachedMfAppMetaData.appKey === initConfig.appKey) && (cachedMfAppMetaData.appSecret === initConfig.appSecret) && validateServiceUrls() && (Math.abs(parseFloat(appConfig.svcDoc.app_version) - parseFloat(cachedSvcDoc.app_version)) < 1e-9)) {
       var toolsBundledSvcDocEtagDateTime = new Date(parseInt(initConfig.appConfig.svcDoc.service_doc_etag, 16)).getTime();
       var cachedSvcDocEtagDateTime = new Date(parseInt(kony.sdk.dataStore.getItem(kony.sdk.constants.TOOLS_ETAG_ID), 16)).getTime();
       // Checking for latest published service doc
       if (cachedSvcDocEtagDateTime > toolsBundledSvcDocEtagDateTime) {
         acceptedSvcDoc = cachedSvcDoc;
         acceptedMfAppMetaData = cachedMfAppMetaData;
       } else {
         kony.sdk.util.deleteMetadatafromDs();
       }
     } else {
       kony.sdk.util.deleteMetadatafromDs();
     }
   }
   //To validate both the service urls from cache and startup.js.
   function validateServiceUrls() {
     if (getBaseUrl(cachedMfAppMetaData.serviceUrl).toLowerCase() !== getBaseUrl(initConfig.serviceUrl).toLowerCase()) {
       return false;
     }
     if (getPathFromUrl(cachedMfAppMetaData.serviceUrl) !== getPathFromUrl(initConfig.serviceUrl)) {
       return false;
     }
     return true;
   }
   // To fetch base url from service url
   function getBaseUrl(serviceUrl) {
     var index = serviceUrl.indexOf("//");
     var baseUrl = "";
     // adding +2 to avoid double slash in the service url to get serviceUrl without hostname
     index = index + 2;
     var serviceUrlWithOutHostName = serviceUrl.substring(index);
     //fetching the baseurl substring from serviceUrl
     baseUrl = serviceUrl.substring(0, (serviceUrlWithOutHostName.indexOf("/")) + index);
     return baseUrl;
   }
   // To fetch remaining path from service url
   function getPathFromUrl(serviceUrl) {
     var remainingPath = serviceUrl.split(getBaseUrl(serviceUrl));
     return remainingPath[1];
   }
   // Initialize KNYMobileFabric Object
   if (KNYMobileFabric === null) {
     KNYMobileFabric = initializeKNYMobileFabricObject(initConfig.appConfig.appId, initConfig.appConfig.appName, initConfig.appConfig.appVersion);
   }
   //Set the isLivePreview flag if provided.
   if (initConfig && initConfig.enableCORSCredentialsGlobally == true) {
     KNYMobileFabric.enableWithCredentialsGloabally = true;
   }
   if (initConfig && initConfig.appConfig && (getLicenseUrl(initConfig.appConfig) === "")) {
     if (kony.license && kony.license.setIsLicenseUrlAvailable) {
       kony.license.setIsLicenseUrlAvailable(false);
       kony.sdk.isLicenseUrlAvailable = false;
     }
   }
   try {
     // Pass the appkey, appSecret, SvcDoc to initWithServiceDoc
     KNYMobileFabric.initWithServiceDoc(acceptedMfAppMetaData.appKey, acceptedMfAppMetaData.appSecret, acceptedSvcDoc);
     // set eventtypes for APM
     KNYMetricsService = initializeMetricsForAPM(KNYMobileFabric, initConfig.eventTypes);
     if (kony.sdk.getPlatformName() !== kony.sdk.constants.PLATFORM_THIN_CLIENT) {
       //Call anonymous login to avoid delay in first call invocation
       // or to avoid timing issues in case of parallel service calls at application startup.
       // This is an asynchronous call, and it is  good to have at this place. Can be removed if we see delays in App launch
       callAnonymousLoginIfRequired(KNYMobileFabric);
     }
     // call successcallback if exists
     kony.sdk.verifyAndCallClosure(successCallBack, KNYMobileFabric);
   } catch (error) {
     // call errorcallback
     var errorMsg = error ? error.toString() : "";
     kony.print("Error in setupsdks " + errorMsg);
     kony.sdk.verifyAndCallClosure(errorCallBack, error);
   }
 };
 /*
     // An example to show the usage of invokeEASMetaServiceWithLiteInit
 	var appCredentials = {
 					"appKey":"40c6c885d62f0981f115badb25b79e17",
 					"appSecret":"463e9450bbe238d58b75449370dc1b84",
 					"serviceUrl":"https://100000010.auth.sit2-konycloud.com/appconfig"
 	};
 	// dataObject is optional in this case(GET Operation).
 	// Not necessary if you are passing other values in options like oDataUrl and objectName.
 	var mDataObject = new kony.sdk.dto.DataObject("Employee", {});
 	var versionCheckOptions = {
 					"serviceName":"EmployeeModelSchema",
 					"objectName":"Employee",
 					"headers": {},
 					"params":{  "dataObject":mDataObject,  //dataObject is optional
 								"queryParams": {},
 								"oDataUrl": ""
 						}
 	};
 	versionCheckSuccessCallback = function(serviceResponse) {
       alert(JSON.stringify(serviceResponse))
     }
     versionCheckErrorCallback = function(serviceResponse) {
       alert(JSON.stringify(serviceResponse))
     }

     function checkLatestAppversionFromEAS(){
       kony.invokeEASMetaServiceWithLiteInit(appCredentials, versionCheckOptions, versionCheckSuccessCallback, versionCheckErrorCallback);
     }
  checkLatestAppversionFromEAS();
 */
 kony.invokeEASMetaServiceWithLiteInit = function(appCredentials, versionCheckOptions, versionCheckSuccessCallback, versionCheckFailureCallback) {
   var claimsToken = null;
   var networkProvider = new konyNetworkProvider();
   // calling lite_init, which does not impact the child apps servicedoc. as it won't save any metadata
   lite_init(appCredentials, function(svcDoc) {
     var svcObj = null;
     if (svcDoc && typeof(svcDoc.services_meta) === 'object') {
       svcObj = svcDoc.services_meta[versionCheckOptions["serviceName"]];
     }
     // check if the service exists in the Mf app.
     if (!kony.sdk.isNullOrUndefined(svcObj)) {
       var identitySelfLoginUrl = svcDoc.selflink.replace("/appconfig", "/login");
       // get Claims Token to make a service call
       getClaimsToken(identitySelfLoginUrl, appCredentials, function(token) {
         // Make Service call to check new version
         claimsToken = token;
         fetchCurrentVersion(svcObj, versionCheckOptions["objectName"], versionCheckOptions["headers"], versionCheckOptions["params"], function(versionResponse) {
           versionCheckSuccessCallback(versionResponse);
         }, function(integrationError) {
           versionCheckFailureCallback(integrationError);
         });
       }, function(identityError) {
         versionCheckFailureCallback(identityError);
       });
     } else {
       // Service doesn't exist, we are creating a custom error object
       var error = {};
       error[kony.sdk.constants.MF_OPSTATUS] = kony.sdk.errorcodes.invalid_user_app_services;
       error[kony.sdk.constants.MF_ERROR_CODE] = kony.sdk.errorcodes.invalid_user_app_services;
       error[kony.sdk.constants.MF_ERROR_MSG] = "Service name '" + versionCheckOptions["serviceName"] + "' doesn't exist.";
       versionCheckFailureCallback(error);
     }
   }, function(initError) {
     versionCheckFailureCallback(initError);
   });

   function lite_init(appCredentials, successCallback, errorCallback) {
     if (!(appCredentials && appCredentials.appKey && appCredentials.appSecret && appCredentials.serviceUrl)) {
       kony.sdk.verifyAndCallClosure(errorCallback, "Invalid initialization parameters passed. Please check appKey, appSecret and ServiceUrl parameters");
       return;
     }
     networkProvider = new konyNetworkProvider();
     var serviceUrl = appCredentials.serviceUrl.trim();
     // to handle http integrity in network calls
     var options = {};
     options[kony.sdk.constants.IGNORE_MESSAGE_INTEGRITY] = true;
     options[kony.sdk.constants.IS_APP_CONFIG_CALL] = true;
     var headers = {};
     headers[kony.sdk.constants.APP_KEY_HEADER] = appCredentials.appKey;
     headers[kony.sdk.constants.APP_SECRET_HEADER] = appCredentials.appSecret;
     headers[kony.sdk.constants.HTTP_OVERRIDE_HEADER] = "GET";
     //Resetting the value.
     kony.sdk.setFabricAppVersion(null);
     networkProvider.post(serviceUrl, {}, headers, function(data) {
       data = kony.sdk.formatSuccessResponse(data);
       successCallback(data);
     }, function(data) {
       errorCallback(data);
     }, null, null);
   }

   function getClaimsToken(endPointUrl, appCredentials, claimsSuccessCallback, claimsFailureCallback) {
     var headers = {};
     headers[kony.sdk.constants.APP_KEY_HEADER] = appCredentials.appKey;
     headers[kony.sdk.constants.APP_SECRET_HEADER] = appCredentials.appSecret;
     headers[kony.sdk.constants.SDK_TYPE_HEADER] = kony.sdk.getSdkType();
     headers[kony.sdk.constants.SDK_VERSION_HEADER] = kony.sdk.version;
     headers[kony.sdk.constants.PLATFORM_TYPE_HEADER] = kony.sdk.getPlatformName();
     headers[kony.sdk.constants.HTTP_REQUEST_HEADER_ACCEPT] = kony.sdk.constants.CONTENT_TYPE_JSON;
     headers[kony.sdk.constants.HTTP_CONTENT_HEADER] = kony.sdk.constants.CONTENT_TYPE_FORM_URL_ENCODED;
     networkProvider.post(endPointUrl, {}, headers, function(data) {
       data = kony.sdk.formatSuccessResponse(data);
       claimsToken = data.claims_token.value;
       claimsSuccessCallback(data.claims_token.value)
     }, function(errorResponse) {
       claimsFailureCallback(errorResponse);
     }, null, null);
   }

   function mergeHeaders(defaultHeaders, headers) {
     // if the user has defined his own headers, use them
     if (!kony.sdk.isNullOrUndefined(headers)) {
       if ((Object.keys(headers)).length !== 0 && typeof(headers) === "object") {
         var defaultKeys = Object.keys(defaultHeaders);
         var lowerCaseHeaders = defaultKeys.map(function(x) {
           return x.toLowerCase()
         });
         for (var header in headers) {
           var headerConst = header;
           if (lowerCaseHeaders.indexOf(headerConst.toLowerCase()) !== -1) {
             for (var i = 0; i < defaultKeys.length; i++) {
               var tempKey = defaultKeys[i];
               if (tempKey.toLowerCase() === headerConst.toLowerCase()) {
                 defaultHeaders[tempKey] = headers[header];
               }
             }
           } else {
             defaultHeaders[header] = headers[header];
           }
         }
       }
     }
     return defaultHeaders;
   }

   function fetchCurrentVersion(serviceObj, objectName, headers, versionCheckOptions, onSuccess, onFailure) {
     if (versionCheckOptions && !kony.sdk.isNullOrUndefined(headers) && kony.sdk.isNullOrUndefined(versionCheckOptions["headers"])) {
       versionCheckOptions["headers"] = headers;
     }
     var tmpDataUrl = encodeURI(stripTrailingCharacter(serviceObj["url"] + "/objects/", "/"));
     _fetch(serviceObj, objectName, versionCheckOptions, tmpDataUrl, onSuccess, onFailure);
   }

   function _fetch(serviceObj, objectName, options, tmpDataUrl, successCallback, serviceErrorCallback) {
     var dataObject = options["dataObject"];
     var odataqueryStr = kony.sdk.isNullOrUndefined(dataObject) ? null : dataObject.getOdataUrl();
     if (kony.sdk.isNullOrUndefined(odataqueryStr)) {
       odataqueryStr = options["oDataUrl"];
     }
     var headers = options["headers"];
     var queryParams = options["queryParams"];
     var url = tmpDataUrl + "/" + objectName;
     var version = null;
     if (serviceObj) {
       version = serviceObj["version"];
     }
     if (!kony.sdk.isNullOrUndefined(odataqueryStr)) {
       url = url + "?" + encodeURI(odataqueryStr);
       if (!kony.sdk.isNullOrUndefined(queryParams)) {
         url = url + "&" + kony.sdk.util.objectToQueryParams(queryParams);
       }
     } else if (!kony.sdk.isNullOrUndefined(queryParams)) {
       url = url + "?" + kony.sdk.util.objectToQueryParams(queryParams);
     }
     if (!headers) {
       //if headers not sent by the deveolper
       headers = {};
     }
     var isKonyApiVersionAvailable = false;
     //check for x-kony-api-version case insensitive
     for (var header in headers) {
       if (header !== null && header !== 'undefined') {
         if (header.toLowerCase() === kony.sdk.constants.API_VERSION_HEADER.toLowerCase()) isKonyApiVersionAvailable = true
       }
     }
     if (!isKonyApiVersionAvailable) {
       headers[kony.sdk.constants.API_VERSION_HEADER] = version;
     }
     invokeObjectOperation(url, objectName, headers, null, kony.sdk.constants.HTTP_METHOD_GET, function(response) {
       kony.sdk.verifyAndCallClosure(successCallback, response);
     }, function(error) {
       kony.sdk.verifyAndCallClosure(serviceErrorCallback, error);
     }, kony.sdk.util.checkAndFetchNetworkProviderOptions(options));
   }

   function invokeObjectOperation(url, svcid, headers, formData, httpMethod, successCallback, failureCallback, networkProviderOptions) {
     var networkProvider = new konyNetworkProvider();
     //var reportingData = kony.sdk.getEncodedReportingParamsForSvcid(svcid);
     var defaultHeaders = {};
     if (!httpMethod) {
       //default http method is post
       httpMethod = "POST";
     }
     defaultHeaders[kony.sdk.constants.KONY_AUTHORIZATION_HEADER] = claimsToken;
     defaultHeaders[kony.sdk.constants.HTTP_REQUEST_HEADER_ACCEPT] = kony.sdk.constants.CONTENT_TYPE_JSON;
     defaultHeaders[kony.sdk.constants.HTTP_CONTENT_HEADER] = kony.sdk.constants.CONTENT_TYPE_JSON;
     var deviceId = kony.sdk.getDeviceId();
     if (!kony.sdk.isNullOrUndefined(deviceId)) {
       defaultHeaders[kony.sdk.constants.DEVICEID_HEADER] = deviceId;
     }
     // if the user has defined his own headers, use them
     if (headers) {
       var tempHeader = "";
       for (var header in headers) {
         if (kony.sdk.constants.HTTP_REQUEST_HEADER_ACCEPT.toLowerCase() === header.toLowerCase()) {
           //Accept can be multiple
           //Reason being client can be programmed to accept more than one type of content from server.
           tempHeader = kony.sdk.constants.HTTP_REQUEST_HEADER_ACCEPT;
           if (defaultHeaders[tempHeader].toLowerCase() !== headers[header].toLowerCase()) {
             defaultHeaders[header] = defaultHeaders[tempHeader] + "," + headers[header];
           }
         } else if (kony.sdk.constants.KONY_AUTHORIZATION_HEADER.toLowerCase() === header.toLowerCase()) {
           tempHeader = kony.sdk.constants.KONY_AUTHORIZATION_HEADER;
           if (defaultHeaders[tempHeader] !== headers[header]) {
             defaultHeaders[tempHeader] = headers[header];
           }
         } else if ("content-type" === header.toLowerCase()) {
           tempHeader = kony.sdk.constants.HTTP_CONTENT_HEADER;
           //Content-type can and should be a single value.
           //Reason being client can only send a single kind of content at a single instance
           if (defaultHeaders[tempHeader].toLowerCase() !== headers[header].toLowerCase()) {
             defaultHeaders[tempHeader] = headers[header];
           }
         } else {
           if (defaultHeaders[header] !== headers[header]) {
             defaultHeaders[header] = headers[header];
           }
         }
       }
     }

     function networksuccess(res) {
       kony.sdk.verifyAndCallClosure(successCallback, res);
     }

     function networkerror(xhr, status, err) {
       if (xhr && !(status && err)) {
         err = xhr;
       }
       kony.sdk.verifyAndCallClosure(failureCallback, kony.sdk.error.getObjectServiceErrObj(err));
     }
     if (httpMethod === "GET") {
       networkProvider.get(url, null, defaultHeaders, networksuccess, networkerror, "formdata", networkProviderOptions);
     } else {
       networkProvider.post(url, formData, defaultHeaders, networksuccess, networkerror, "formdata", networkProviderOptions);
     }
   }
 };
 kony.sdk.util = kony.sdk.util || {};

 function konyLogger() {
   this.log = function(text) {
     if (kony.sdk.isDebugEnabled) {
       kony.print(text);
     }
   }
 }
 /**
  * Flag used to override the network availability api for automation testing.
  * @type {boolean}
  */
 overrideNetworkFlag = false;
 /**
  *	Utility Method for the application to check the network availability.
  */
 kony.sdk.isNetworkAvailable = function() {
   //Check the network flag if set for testing. This would mandate the application to be offline if device has network connectivity.
   if (overrideNetworkFlag !== undefined && overrideNetworkFlag !== null && overrideNetworkFlag && overrideNetworkFlag === true) return false;
   return kony.net.isNetworkAvailable(constants.NETWORK_TYPE_ANY);
 };
 /**
  *	Utility method to set the network flag for offline testing.
  */
 kony.sdk.overrideNetworkFlag = function() {
   overrideNetworkFlag = true;
 };
 /**
  *	Utility method to reset the network flag set for offline testing.
  */
 kony.sdk.resetNetworkFlag = function() {
   overrideNetworkFlag = false;
   overrideNetworkFlag = undefined;
 };
 kony.sdk.overrideAnonymousLoginFlag = function() {
   kony.sdk.skipAnonymousCall = true;
 };
 kony.sdk.resetAnonymousLoginFlag = function() {
   kony.sdk.skipAnonymousCall = false;
 };

 function konyNetworkProvider() {
   this.post = function(url, params, headers, successCallback, failureCallback, konyContentType, options) {
     if (kony.sdk.util.isNullOrEmptyString(url)) {
       kony.sdk.verifyAndCallClosure(failureCallback, "url cannot be null or empty");
       return;
     }
     //Appending global params
     if (kony.sdk.isNullOrUndefined(params)) {
       params = {};
     }
     if (!kony.sdk.isNullOrUndefined(kony.sdk.currentInstance)) {
       url = kony.sdk.currentInstance.appendGlobalParams(url, headers, params);
     }
     konyNetHttpRequest(url, params, headers, "POST", konyContentType, successCallback, failureCallback, options);
   };
   this.put = function(url, params, headers, successCallback, failureCallback, konyContentType, options) {
     if (kony.sdk.util.isNullOrEmptyString(url)) {
       kony.sdk.verifyAndCallClosure(failureCallback, "url cannot be null or empty");
       return;
     }
     //Appending global params
     if (kony.sdk.isNullOrUndefined(params)) {
       params = {};
     }
     if (!kony.sdk.isNullOrUndefined(kony.sdk.currentInstance)) {
       url = kony.sdk.currentInstance.appendGlobalParams(url, headers, params);
     }
     konyNetHttpRequest(url, params, headers, "PUT", konyContentType, successCallback, failureCallback, options);
   };
   this.invokeDeleteRequest = function(url, params, headers, successCallback, failureCallback, konyContentType, options) {
     if (kony.sdk.util.isNullOrEmptyString(url)) {
       kony.sdk.verifyAndCallClosure(failureCallback, "url cannot be null or empty");
       return;
     }
     //Appending global params
     if (kony.sdk.isNullOrUndefined(params)) {
       params = {};
     }
     if (!kony.sdk.isNullOrUndefined(kony.sdk.currentInstance)) {
       url = kony.sdk.currentInstance.appendGlobalParams(url, headers, params);
     }
     konyNetHttpRequest(url, params, headers, "DELETE", konyContentType, successCallback, failureCallback, options);
   };
   //postSync will only work for Richclients like Android,IOS
   this.postSync = function(url, params, headers) {
     if (kony.sdk.util.isNullOrEmptyString(url)) {
       kony.sdk.verifyAndCallClosure(failureCallback, "url cannot be null or empty");
       return;
     }
     //Appending global params
     if (kony.sdk.isNullOrUndefined(params)) {
       params = {};
     }
     if (!kony.sdk.isNullOrUndefined(kony.sdk.currentInstance)) {
       url = kony.sdk.currentInstance.appendGlobalParams(url, headers, params);
     }
     return konyNetHttpRequestSync(url, params, headers);
   };
   this.get = function(url, params, headers, successCallback, failureCallback, konyContentType, options) {
     if (kony.sdk.util.isNullOrEmptyString(url)) {
       kony.sdk.verifyAndCallClosure(failureCallback, "url cannot be null or empty");
       return;
     }
     //Appending global params
     if (kony.sdk.isNullOrUndefined(params)) {
       params = {};
     }
     if (!kony.sdk.isNullOrUndefined(kony.sdk.currentInstance)) {
       url = kony.sdk.currentInstance.appendGlobalParams(url, headers, params);
     }
     konyNetHttpRequest(url, null, headers, "GET", konyContentType, successCallback, failureCallback, options);
   }
 }

 function konyNetHttpRequest(url, params, headers, httpMethod, konyContentType, successCallback, failureCallback, options) {
   // give failure call back if network is not available
   if (!kony.net.isNetworkAvailable(constants.NETWORK_TYPE_ANY)) {
     var errorObj = {};
     errorObj.httpresponse = {};
     errorObj[kony.sdk.constants.MF_OPSTATUS] = kony.sdk.errorcodes.connectivity_error_code;
     errorObj[kony.sdk.constants.MF_ERROR_CODE] = kony.sdk.errorcodes.connectivity_error_code;
     errorObj[kony.sdk.constants.MF_ERROR_MSG] = kony.sdk.errormessages.connectivity_error_message;
     errorObj.httpresponse.headers = {};
     errorObj.httpresponse.url = url;
     failureCallback(errorObj);
     return;
   }
   var paramsTable = null;
   var httpRequest;
   if (options && options["httpRequestOptions"] && options["httpRequestOptions"] instanceof Object) {
     httpRequest = new kony.net.HttpRequest(options["httpRequestOptions"]);
   } else {
     httpRequest = new kony.net.HttpRequest();
   }
   if (options && options["queryParams"] && options["queryParams"] instanceof Object) {
     url = addQueryParamsToURL(url, options["queryParams"]);
   }
   if (options && options["responseType"]) {
     httpRequest.responseType = options["responseType"];
   }
   // check for the deprecated property if set in appmiddlewaresecureinvokerasync() API
   if (options && options["httpconfig_old"]) {
     if (options["httpconfig_old"]["timeout"]) {
       httpRequest.timeout = options["httpconfig_old"]["timeout"] * 1000;
     }
   }
   // As older versions of IE doesn't have xmlHttpRequest2, and it doesn't support "withCredentials" property
   // We put a check to handle a crash. Cookies will not be transferred in CORS request for IE due to this restriction
   if (typeof(XMLHttpRequest) !== "undefined" && "withCredentials" in (new XMLHttpRequest())) {
     if ((!kony.sdk.isNullOrUndefined(KNYMobileFabric) && KNYMobileFabric.enableWithCredentialsGloabally === true) || (options && options["xmlHttpRequestOptions"] && options["xmlHttpRequestOptions"]["enableWithCredentials"] === true)) {
       httpRequest.enableWithCredentials = true;
     }
   }
   var isInvalidResponse = false;
   //if httpmethod is not provided falling back to POST
   if (!httpMethod) {
     httpMethod = constants.HTTP_METHOD_POST;
   }
   httpRequest.open(httpMethod, url);

   function localRequestCallback(result) {
     var readyState = Number(httpRequest.readyState.toString());
     var status = Number(httpRequest.status.toString());
     var response = {};
     if (readyState === 4) {
       var responseHeaders = httpRequest.getAllResponseHeaders();
       //If response headers has X-Kony-Passthrough, ignoring parsing the response content. With this, passthrough flag
       //is optional for passthrough services and will be deprecated in future releases
       if (responseHeaders && (responseHeaders.hasOwnProperty(kony.sdk.constants.PASSTHROUGH_RESPONSE_HEADER.toLowerCase()) || responseHeaders.hasOwnProperty(kony.sdk.constants.PASSTHROUGH_RESPONSE_HEADER)) && (kony.sdk.convertPassthroughResponseToJson !== true)) {
         response.rawResponse = result.response;
       } else if (options && options[kony.sdk.constants.PASSTHROUGH] && kony.sdk.convertPassthroughResponseToJson !== true) {
         //If option "passthrough" is enabled then SDK will not parse the result from backend.
         response.rawResponse = result.response;
       } else {
         //parseHttpResponse parse response based on the content-type response header
         var parsedResp = parseHttpResponse(httpRequest);
         if (parsedResp.isRawResponse) {
           response.rawResponse = parsedResp.response;
         } else {
           response = parsedResp.response;
         }
         isInvalidResponse = parsedResp.isInvalidResponse;
       }
       kony.sdk.setLogLevelFromServerResponse(responseHeaders);
       if (response && !isInvalidResponse) {
         response.httpresponse = {};
         response.httpresponse.headers = responseHeaders;
         response.httpresponse.url = url;
         response.httpresponse.responsecode = status;
       }
       if (isInvalidResponse || (!response && status >= 200 && status < 300)) {
         var errorMessage = {};
         errorMessage.httpresponse = {};
         errorMessage[kony.sdk.constants.MF_OPSTATUS] = kony.sdk.errorcodes.invalid_json_code;
         errorMessage[kony.sdk.constants.MF_ERROR_MSG] = kony.sdk.errormessages.invalid_json_message;
         errorMessage[kony.sdk.constants.MF_ERROR_CODE] = kony.sdk.errorcodes.invalid_json_code;
         errorMessage[kony.sdk.constants.HTTP_STATUS_CODE] = status;
         errorMessage.httpresponse["response"] = parsedResp.response;
         errorMessage.httpresponse.headers = responseHeaders;
         errorMessage.httpresponse.url = url;
         errorMessage.httpresponse.responsecode = status;
         failureCallback(errorMessage);
       } else if (status >= 200 && status < 300) {
         if (!response.opstatus) {
           response.opstatus = 0;
         }
         if (response.opstatus == 0 || (response.opstatus >= 500100 && response.opstatus <= 500200)) {
           if (responseHeaders && (responseHeaders.hasOwnProperty(kony.sdk.constants.PASSTHROUGH_RESPONSE_HEADER.toLowerCase()) || responseHeaders.hasOwnProperty(kony.sdk.constants.PASSTHROUGH_RESPONSE_HEADER))) {
             validateIntegrityAndHandleCallbackInvocation(response);
           } else if (options && (options[kony.sdk.constants.DISABLE_INTEGRITY] || options[kony.sdk.constants.PASSTHROUGH] || options[kony.sdk.constants.IGNORE_MESSAGE_INTEGRITY])) {
             successCallback(response);
           } else {
             validateIntegrityAndHandleCallbackInvocation(response);
           }
         } else {
           failureCallback(response);
         }
       } else {
         invokeNetworkErrorCallback(url, httpRequest, response, status);
       }

       function invokeNetworkErrorCallback(url, httpRequest, response, status) {
         var errorObj = {};
         errorObj.httpresponse = {};
         if (status == 408) {
           errorObj[kony.sdk.constants.MF_OPSTATUS] = kony.sdk.errorcodes.request_timed_out_code;
           errorObj[kony.sdk.constants.MF_ERROR_CODE] = kony.sdk.errorcodes.request_timed_out_code;
           errorObj[kony.sdk.constants.MF_ERROR_MSG] = kony.sdk.errormessages.request_timed_out_message;
         } else if (status == 503) {
           errorObj[kony.sdk.constants.MF_OPSTATUS] = kony.sdk.errorcodes.service_unavailable;
           errorObj[kony.sdk.constants.MF_ERROR_CODE] = kony.sdk.errorcodes.service_unavailable;
           errorObj[kony.sdk.constants.MF_ERROR_MSG] = kony.sdk.errormessages.service_unavailable_message;
         } else if (status == 504) {
           errorObj[kony.sdk.constants.MF_OPSTATUS] = kony.sdk.errorcodes.connection_timeout;
           errorObj[kony.sdk.constants.MF_ERROR_CODE] = kony.sdk.errorcodes.connection_timeout;
           errorObj[kony.sdk.constants.MF_ERROR_MSG] = kony.sdk.errormessages.connection_timeout_message;
         } else if ((status > 99) && (!kony.sdk.isNullOrUndefined(response))) {
           errorObj = response;
         } else {
           errorObj[kony.sdk.constants.MF_OPSTATUS] = kony.sdk.errorcodes.connectivity_error_code;
           errorObj[kony.sdk.constants.MF_ERROR_CODE] = kony.sdk.errorcodes.connectivity_error_code;
           errorObj[kony.sdk.constants.MF_ERROR_MSG] = kony.sdk.errormessages.connectivity_error_message;
         }
         errorObj[kony.sdk.constants.HTTP_STATUS_CODE] = status;
         errorObj.httpresponse.headers = httpRequest.getAllResponseHeaders();
         errorObj.httpresponse.url = url;
         failureCallback(errorObj);
       }

       function validateIntegrityAndHandleCallbackInvocation(response) {
         if (typeof(konyRef) !== "undefined" && konyRef && konyRef.mainRef.integrityKey === true) {
           if (response.httpresponse.headers.hasOwnProperty(kony.sdk.constants.INTEGRITY_HEADER) || response.httpresponse.headers.hasOwnProperty(kony.sdk.constants.INTEGRITY_HEADER.toLowerCase())) {
             if (!(kony.sdk.isNullOrUndefined(httpRequest.integrityStatus))) {
               var integrityStatus = parseInt(httpRequest["integrityStatus"].toString());
               switch (integrityStatus) {
                 case constants.HTTP_INTEGRITY_CHECK_NOT_DONE:
                   failureCallback(kony.sdk.error.getIntegrityErrorMessage(httpRequest, url));
                   break;
                 case constants.HTTP_INTEGRITY_CHECK_SUCCESSFUL:
                   successCallback(response);
                   break;
                 case constants.HTTP_INTEGRITY_CHECK_FAILED:
                   //With V9-P2 release, for binary calls integrity check happens on random string.
                   //With V8 client and V9 server, integrity check will fail for binary. So based on
                   //ignoreintegrity flag calling successcallback as these calls happens to be binary.
                   if (!kony.sdk.isNullOrUndefined(options) && options[kony.sdk.constants.IGNORE_MESSAGE_INTEGRITY]) {
                     successCallback(response);
                   } else {
                     failureCallback(kony.sdk.error.getIntegrityErrorMessage(httpRequest, url));
                   }
                   break;
               }
             } else {
               failureCallback(kony.sdk.error.getIntegrityErrorMessage(httpRequest, url));
             }
           } else if (options && options != null && options[kony.sdk.constants.IGNORE_MESSAGE_INTEGRITY]) {
             successCallback(response);
           } else {
             failureCallback(kony.sdk.error.getIntegrityErrorMessage(httpRequest, url));
           }
         } else {
           successCallback(response);
         }
       }
     }
   }
   if (konyContentType === "application/json") {
     if (params) {
       paramsTable = JSON.stringify(params);
     }
   } else if (konyContentType == "formdata" || konyContentType == "multipart") {
     //for specific requests like object services we will send formdata through form encoding mechanism.
     if (params) {
       //for object services we are getting kony.net.FormData so using the same.
       paramsTable = params;
     }
   } else {
     //preparing params for other than object services
     var firstKey = true;
     for (var key in params) {
       if (firstKey) {
         paramsTable = new kony.net.FormData();
         firstKey = false;
       }
       if (typeof(params[key]) != "undefined") {
         if (typeof(params[key]) !== "string") {
           params[key] = JSON.stringify(params[key]);
         }
         paramsTable.append((key), (params[key]));
       }
     }
   }
   if (headers) {
     for (var key in headers) {
       httpRequest.setRequestHeader(key, headers[key]);
     }
   } else {
     httpRequest.setRequestHeader(kony.sdk.constants.HTTP_CONTENT_HEADER, kony.sdk.constants.CONTENT_TYPE_JSON);
   }
   httpRequest.onReadyStateChange = localRequestCallback;
   if ((typeof(konyRef) !== "undefined" && konyRef && konyRef.mainRef.integrityKey === true) || (!kony.sdk.isNullOrUndefined(options) && options.isAppConfigCall === true)) {
     var properties = konyRef.mainRef.integrityParams;
     try {
       //check is for windows 8.x and Kiosk platforms,which doesn't support integrity
       if (kony.sdk.constants.SET_INTEGRITY_CHECK in kony.net) {
         kony.net.setIntegrityCheck(properties);
       }
     } catch (e) {
       kony.sdk.logsdk.warn("Invalid Integrity properties received");
       throw "Invalid Integrity properties received";
     }
   } else {
     if ((options && (options[kony.sdk.constants.DISABLE_INTEGRITY] || options[kony.sdk.constants.PASSTHROUGH])) || ((typeof(konyRef) !== "undefined" && konyRef && konyRef.mainRef.integrityKey === false) || (!kony.sdk.isNullOrUndefined(options) && options.isAppConfigCall === false))) {
       //mesasging service and pass through enabled integration svc doesn't support http message body integrity
       //if integrity is enabled earlier,remove integrity
       //check is for windows 8.x and Kiosk platforms,which doesn't support integrity
       if (kony.sdk.constants.DISABLE_INTEGRITY_CHECK in httpRequest) {
         httpRequest.disableIntegrityCheck = true;
       } else if (kony.sdk.constants.REMOVE_INTEGRITY_CHECK in kony.net) {
         kony.net.removeIntegrityCheck();
       }
     }
   }
   if (paramsTable) {
     httpRequest.send(paramsTable);
   } else {
     httpRequest.send();
   }
   /**
    * copied from spa_offlineobjects/KSUtils/KSNetworkUtils.js
    * Method to add the query parameters after URI encoding to the URL.
    * @param {string} url URL to which the query params are to be appended.
    * @param {Object} queryParams JSON object containing the query parameters.
    */
   function addQueryParamsToURL(url, queryParams) {
     if (queryParams && Object.keys(queryParams).length > 0) {
       var encodedQueryParams = "";
       var ampersandSubstring = "&";
       for (var key in queryParams) {
         encodedQueryParams += key + "=" + encodeURIComponent(queryParams[key]) + ampersandSubstring;
       }
       //Remove the trailing ampersand for the last key-value pair..
       encodedQueryParams = encodedQueryParams.slice(0, -1);
       //Check if the URL has query params already..
       if (url.indexOf('?') > -1) {
         url += "&" + encodedQueryParams;
       } else {
         url += "?" + encodedQueryParams;
       }
     }
     return url;
   }
 }

 function konyNetHttpRequestSync(url, params, headers) {
   var paramsTable = null;
   var httpRequest = new kony.net.HttpRequest();
   var isInvalidJSON = false;
   httpRequest.open(constants.HTTP_METHOD_POST, url, false);
   var firstKey = true;
   for (var key in params) {
     if (firstKey) {
       paramsTable = new kony.net.FormData();
       firstKey = false;
     }
     if (typeof(params[key]) != "undefined") {
       if (typeof(params[key]) !== "string") {
         params[key] = JSON.stringify(params[key]);
       }
       paramsTable.append((key), (params[key]));
     }
   }
   if (headers) {
     for (var key in headers) {
       httpRequest.setRequestHeader(key, headers[key]);
     }
   } else {
     httpRequest.setRequestHeader(kony.sdk.constants.HTTP_CONTENT_HEADER, kony.sdk.constants.CONTENT_TYPE_JSON);
   }
   //httpRequest.onReadyStateChange = localRequestCallback;
   httpRequest.send(paramsTable);
   var response = null;
   var status = Number(httpRequest.status.toString());
   kony.sdk.setLogLevelFromServerResponse(httpRequest.getAllResponseHeaders());
   if (httpRequest.response) {
     response = httpRequest.response;
   }
   if (response && typeof(response) === 'string') {
     if (kony.sdk.isJson(response)) {
       response = JSON.parse(response);
     } else {
       isInvalidJSON = true;
     }
   }
   if (response && !(isInvalidJSON)) {
     response.httpresponse = {};
     response.httpresponse.headers = httpRequest.getAllResponseHeaders();
     response.httpresponse.url = url;
     response.httpresponse.responsecode = status;
   }
   if (isInvalidJSON || (!response && status >= 200 && status < 300)) {
     var errorMessage = {};
     errorMessage.httpresponse = {};
     errorMessage[kony.sdk.constants.MF_OPSTATUS] = kony.sdk.errorcodes.invalid_json_code;
     errorMessage[kony.sdk.constants.MF_ERROR_MSG] = kony.sdk.errormessages.invalid_json_message;
     errorMessage[kony.sdk.constants.MF_ERROR_CODE] = kony.sdk.errorcodes.invalid_json_code;
     errorMessage[kony.sdk.constants.HTTP_STATUS_CODE] = status;
     errorMessage.httpresponse["response"] = response;
     errorMessage.httpresponse.headers = httpRequest.getAllResponseHeaders();
     errorMessage.httpresponse.url = url;
     errorMessage.httpresponse.responsecode = status;
     return errorMessage;
   } else if (status >= 200 && status < 300) {
     if (!response.opstatus) {
       response.opstatus = 0;
     }
     return response;
   } else {
     var resultTable = {};
     if (response) {
       resultTable = response;
       resultTable.httpStatusCode = httpRequest.status.toString();
     } else {
       resultTable[kony.sdk.constants.MF_OPSTATUS] = kony.sdk.errorcodes.connectivity_error_code;
       resultTable[kony.sdk.constants.MF_ERROR_CODE] = kony.sdk.errorcodes.connectivity_error_code;
       resultTable[kony.sdk.constants.MF_ERROR_MSG] = kony.sdk.errormessages.connectivity_error_message;
     }
     return resultTable;
   }
 }

 function konyDataStore() {
   //kony.sdk.logsdk.trace("Setting konyDataStore");
   this.setItem = function(key, value) {
     if (typeof(key) !== "string") {
       throw new Exception(kony.sdk.errorConstants.DATA_STORE_EXCEPTION, "Invalid Key");
     } else {
       try {
         key = key.replace(/\//gi, "");
         kony.store.setItem(key, value);
       } catch (e) {
         kony.sdk.logsdk.error("Failed to set item in dtastore:" + e);
       }
     }
   };
   this.getItem = function(key) {
     kony.sdk.logsdk.debug("Getting item for key:" + key);
     if (typeof(key) !== "string") {
       throw new Exception(kony.sdk.errorConstants.DATA_STORE_EXCEPTION);
     } else {
       key = key.replace(/\//gi, "");
       var value = kony.store.getItem(key);
       if (value === null || value === undefined) {
         kony.sdk.logsdk.debug("No value found with key:" + key);
         return null;
       } else {
         return value;
       }
     }
   };
   this.removeItem = function(key) {
     kony.sdk.logsdk.debug("Removing item for key:" + key);
     if (typeof(key) !== "string") {
       throw new Exception(Error.DATA_STORE_EXCEPTION);
     } else {
       key = key.replace(/\//gi, "");
       kony.store.removeItem(key); //If no item with that key exists, the method does not perform any action. Thus no need to check for key availablity.
     }
   };
   this.destroy = function() {
     kony.sdk.logsdk.info("Destroying data store for this app");
     kony.store.clear();
   };
   this.getAllItems = function() {
     kony.sdk.logsdk.info("Getting all item from data store");
     var items = {};
     var len = kony.store.length(); //get key length
     for (var i = 0; i < len; i++) {
       var key = kony.store.key(i); //get ith key
       var value = kony.store.getItem(key); //get value
       items[key] = value; //prepare itemset
     }
     return items;
   }
   /**
    * This method first encrypt the value and save encrypted value against the given key
    * @param key
    * @param value -can accept JSON(converts to string) or plain string only
    */
   this.setSecureItem = function(key, value) {
     kony.sdk.logsdk.info("saving data after encryption of plain data");
     if (kony.sdk.util.isJsonObject(value)) {
       value = JSON.stringify(value);
     }
     var encryptionKey = [kony.sdk.util.getSharedClientId()];
     var encryptionAlgorithm = kony.sdk.constants.ENCRYPTION_ALGO_AES;
     var securedValue = kony.sdk.util.encryptText(value, encryptionKey, encryptionAlgorithm);
     this.setItem(key, securedValue);
   }
   /**
    * This method retrieves saved encrypted value and decrypt it into original value
    * @param key
    * @returns {*} can return JSON if value is parsed or string otherwise
    */
   this.getSecureItem = function(key) {
     kony.sdk.logsdk.info("retrieving encrypted data as plain data");
     var value = this.getItem(key);
     var encryptionKey = [kony.sdk.util.getSharedClientId()];
     var decryptionAlgorithm = kony.sdk.constants.ENCRYPTION_ALGO_AES;
     var securedValue = kony.sdk.util.decryptText(value, encryptionKey, decryptionAlgorithm);
     if (kony.sdk.isJson(securedValue)) {
       securedValue = JSON.parse(securedValue);
     }
     return securedValue;
   }
 }

 function parseHttpResponse(httpRequest) {
   var isInvalidResponse = false;
   var isJsonResponse = false;
   var parsedResponse = {};
   parsedResponse.isRawResponse = false;
   var value = "";
   var response = null;
   if (kony.sdk.isNullOrUndefined(httpRequest) || kony.sdk.isNullOrUndefined(httpRequest.response)) {
     kony.sdk.logsdk.warn("parseHttpResponse :: Null or Invalid response received");
   } else if (httpRequest.responseType && httpRequest.responseType === "blob") {
     parsedResponse.response = httpRequest.response;
     parsedResponse.isRawResponse = true;
   } else {
     response = kony.sdk.cloneObject(httpRequest.response);
     kony.sdk.logsdk.debug("parseHttpResponse :: Network response :", response);
     //Defaulting to JSON format
     if (kony.sdk.util.isJsonObject(response)) {
       parsedResponse.response = response;
       isJsonResponse = true;
     } else if (kony.sdk.util.isValidString(response)) {
       if (kony.sdk.isJson(response)) {
         parsedResponse.response = JSON.parse(response);
         isJsonResponse = true;
       }
     }
     //Handling when response is not json
     if (!isJsonResponse) {
       if (kony.sdk.util.isValidString(httpRequest.response)) {
         parsedResponse.response = response;
       } else {
         parsedResponse.response = httpRequest.response;
       }
       var lowerCaseHeaders = kony.sdk.util.convertJsonKeysToLowerCase(httpRequest.getAllResponseHeaders());
       //value variable contains response header in lower case
       if (!kony.sdk.isNullOrUndefined(lowerCaseHeaders)) {
         value = lowerCaseHeaders[kony.sdk.constants.HTTP_CONTENT_HEADER.trim().toLowerCase()];
       } else {
         kony.sdk.logsdk.warn("parseHttpResponse :: received null response headers  " + lowerCaseHeaders);
       }
       kony.sdk.logsdk.warn("parseHttpResponse :: content-type of response " + value);
       //MFSDK-3525 Adding an additional check to see if content type is present.
       if (kony.sdk.util.isValidString(value) && value.startsWith(kony.sdk.constants.CONTENT_TYPE_JSON)) {
         kony.sdk.logsdk.warn("parseHttpResponse :: Unhandled content received for content-type application/json");
         isInvalidResponse = true;
       } else {
         parsedResponse.isRawResponse = true;
       }
     }
   }
   parsedResponse.isInvalidResponse = isInvalidResponse;
   return parsedResponse;
 }
 kony.sdk.getSdkType = function() {
   return kony.sdk.constants.SDK_TYPE_IDE;
 };
 kony.sdk.getPayload = function(konyRef) {
   var payload = {};
   payload.os = kony.os.deviceInfo().version + "";
   payload.dm = kony.os.deviceInfo().model;
   payload.did = kony.sdk.getDeviceId();
   payload.ua = kony.os.userAgent();
   if (appConfig) {
     payload.aid = appConfig.appId;
     payload.aname = appConfig.appName;
   } else {
     var clientParams = konyRef.getClientParams();
     payload.aid = clientParams.aid ? clientParams.aid : konyRef.mainRef.baseId;
     payload.aname = clientParams.aname ? clientParams.aname : konyRef.mainRef.name;
   }
   payload.chnl = kony.sdk.getChannelType();
   payload.plat = kony.sdk.getPlatformName();
   if (payload.plat === kony.sdk.constants.PLATFORM_IOS && payload.dm.toLowerCase().indexOf("ipod") !== -1) {
     payload.chnl = "ipod";
   }
   payload.aver = appConfig.appVersion;
   payload.atype = kony.sdk.getAType();
   payload.stype = "b2c";
   payload.kuid = konyRef.getUserId();
   payload.mfaid = konyRef.mainRef.appId;
   payload.mfbaseid = konyRef.mainRef.baseId;
   payload.mfaname = konyRef.mainRef.name;
   payload.sdkversion = kony.sdk.version;
   payload.sdktype = kony.sdk.getSdkType();
   if (kony.application.getCurrentForm()) {
     var fid = kony.application.getCurrentForm().id;
     if (fid) {
       payload.fid = fid;
     }
   }
   payload.sessiontype = kony.sdk.util.getSessionType();
   payload.clientUUID = konyRef.clientUUID;
   return payload;
 };
 /**
  * Returns unique identifier for a device.
  * In case of Android & Windows the API kony.os.deviceInfo().deviceid is guaranteed to provide unique identifier for a device.
  * In case of iOS the API kony.os.deviceInfo().identifierForVendor is guaranteed to provide unique key per vendor.
  * A different value is returned for apps on the same device that come from different vendors, and for apps on different devices regardless of vendor
  * @return {string}
  */
 kony.sdk.getDeviceId = function() {
   // For Android, SPA & Windows platforms.
   return kony.os.deviceInfo().deviceid;
 };
 kony.sdk.getChannelType = function() {
   var returnVal = "";
   returnVal = "desktop";
   return returnVal;
 };
 kony.sdk.getPlatformName = function() {
   var returnVal = "";
   returnVal = kony.sdk.constants.PLATFORM_THIN_CLIENT;
   return returnVal;
 };
 kony.sdk.util.isPlatformPlainJS = function() {
   var isPlatformPlainJS = false;
   isPlatformPlainJS = true;
   return isPlatformPlainJS;
 }
 kony.sdk.util.createSessionAndSendIST = function() {
   kony.license.createSession();
   kony.license.captureKonyLicenseUsage(true);
 }
 kony.mbaas.invokeMbaasServiceFromKonyStudio = function(url, inputParam, serviceID, operationID, callBack, infoObject) {
   var currentInstance = kony.sdk.getCurrentInstance();
   if (!currentInstance) {
     throw new Exception(kony.sdk.errorConstants.INIT_FAILURE, kony.sdk.constants.INIT_FAILURE_MESSAGE + "this service.");
   }
   var integrationService = currentInstance.getIntegrationService(serviceID);
   var options = {};
   if (inputParam && inputParam["httpconfig"]) {
     options["httpconfig_old"] = inputParam["httpconfig"];
     delete inputParam["httpconfig"];
   }
   if (inputParam && inputParam["httpRequestOptions"] && inputParam["httpRequestOptions"] instanceof Object) {
     options["httpRequestOptions"] = inputParam["httpRequestOptions"];
     delete inputParam["httpRequestOptions"];
   }
   if (inputParam && inputParam["xmlHttpRequestOptions"] && inputParam["xmlHttpRequestOptions"] instanceof Object) {
     options["xmlHttpRequestOptions"] = inputParam["xmlHttpRequestOptions"];
     delete inputParam["xmlHttpRequestOptions"];
   }
   var headers = null;
   if (inputParam && inputParam["httpheaders"]) {
     headers = inputParam["httpheaders"];
     delete inputParam["httpheaders"];
   }
   integrationService.invokeOperation(operationID, headers, inputParam, function(res) {
     if (typeof(callBack) === 'function') {
       callBack(400, res, infoObject);
     }
   }, function(res) {
     if (typeof(callBack) === 'function') {
       callBack(400, res, infoObject);
     }
   }, options);
 };
 kony.mbaas.invokeMbaasServiceFromKonyStudioSync = function(url, inputParam, serviceID, operationID) {
   var currentInstance = kony.sdk.getCurrentInstance();
   if (!currentInstance) {
     throw new Exception(kony.sdk.errorConstants.INIT_FAILURE, kony.sdk.constants.INIT_FAILURE_MESSAGE + "this service.");
   }
   var integrationService = currentInstance.getIntegrationService(serviceID);
   var headers = null;
   if (inputParam && inputParam["httpheaders"]) {
     headers = inputParam["httpheaders"];
     delete inputParam["httpheaders"];
   }
   return integrationService.invokeOperationSync(operationID, headers, inputParam);
 };
 kony.mbaas.invokeMbaasServiceFromKonyStudioAsync = function(url, inputParam, serviceID, operationID, callBack, info) {
   kony.mbaas.invokeMbaasServiceFromKonyStudio(url, inputParam, serviceID, operationID, callBack, info);
 };
 //Helps to prepare the input wrapped into kony.net.FormData
 kony.sdk.getFormData = function(payload) {
   var formData = new kony.net.FormData();
   formData.append(kony.sdk.constants.JSON_DATA, JSON.stringify(payload));
   return formData;
 };
 //Helps to update prepare the input wrapped into kony.net.FormData
 kony.sdk.updateFormData = function(formData, key, value) {
   formData.append(key, JSON.stringify(value));
   return formData;
 };
 //Helps to get the atype for Spa and DesktopWeb applications it would be kony.sdk.constants.SDK_ATYPE_SPA ,for android wear applications it would be "watch" and remaining it would be "native"
 kony.sdk.getAType = function() {
   var returnVal = kony.sdk.constants.SDK_ATYPE_NATIVE;
   returnVal = kony.sdk.constants.SDK_ATYPE_SPA;
   return returnVal;
 };
 kony.sdk.setLicenseCall = function(appKey, appSecret, data) {
   //checking if new MF app is connected
   var reportingServiceUrl = data.reportingsvc.session;
   if (typeof(appConfig) != "undefined") {
     if ((appKey === appConfig.appKey) && (appSecret === appConfig.appSecret) && (typeof(appConfig.svcDoc) !== "undefined" && reportingServiceUrl === appConfig.svcDoc.reportingsvc.session)) {
       return; //user is doing init on same environment and same MF-app
     } else {
       appConfig.isturlbase = reportingServiceUrl.replace("/IST", "");
       appConfig.appKey = appKey;
       appConfig.appSecret = appSecret;
       appConfig.serviceUrl = data.selflink;
       appConfig.svcDoc = data;
       // IST is triggered with new sid and new MF app on the same or different IST server based on how isturlbase is populated
       kony.sdk.util.createSessionAndSendIST();
     }
   }
 };
 /**
  * Saving App metadata in storage for Persistence
  */
 kony.sdk.util.saveMetadatainDs = function(appKey, appSecret, servConfig) {
   var appId = {
     "appKey": kony.sdk.util.encryptAppConfig(appKey),
     "appSecret": kony.sdk.util.encryptAppConfig(appSecret),
     "serviceUrl": kony.sdk.util.encryptAppConfig(servConfig.selflink)
   };
   kony.sdk.dataStore.setItem(kony.sdk.constants.TOOLS_ETAG_ID, servConfig.service_doc_etag);
   kony.sdk.logsdk.debug("Update done. Current version = " + kony.sdk.getCurrentInstance().mainRef.config.service_doc_etag + " Updated to " + servConfig.service_doc_etag);
   kony.sdk.dataStore.setItem(kony.sdk.util.prefixAppid(kony.sdk.constants.MOBILE_FABRIC_SERVICE_DOC), kony.sdk.util.encryptAppConfig(JSON.stringify(servConfig)));
   kony.sdk.dataStore.setItem(appConfig.appId, JSON.stringify(appId));
   kony.sdk.dataStore.setItem(kony.sdk.util.prefixAppid(kony.sdk.constants.ENCRYPTION_APPCONFIG_FLAG), true);
   kony.sdk.logsdk.info("### saveMetadatainDs:: metadata saved successfuly in dataStore");
 };
 /**
  * Deleting App metadata from datastore(cache)
  */
 kony.sdk.util.deleteMetadatafromDs = function() {
   kony.sdk.dataStore.removeItem(appConfig.appId);
   kony.sdk.dataStore.removeItem(kony.sdk.util.prefixAppid(kony.sdk.constants.MOBILE_FABRIC_SERVICE_DOC));
   kony.sdk.dataStore.removeItem(kony.sdk.util.prefixAppid(kony.sdk.constants.ENCRYPTION_APPCONFIG_FLAG));
   /** Checking whether Persisted login or Offline login or refresh login tokens are present in secure storage
    {returns} boolean
    */
   function shouldSharedClientIdentifierNeedsToBeRemoved() {
     return kony.sdk.util.isNullOrUndefinedOrEmptyObject(kony.sdk.dataStore.getItem(kony.sdk.constants.PERSISTED_AUTH_RESPONSE)) && kony.sdk.util.isNullOrUndefinedOrEmptyObject(kony.sdk.dataStore.getItem(kony.sdk.constants.OFFLINE_LOGIN_AUTH_RESPONSE)) && kony.sdk.util.isNullOrUndefinedOrEmptyObject(kony.sdk.dataStore.getItem(kony.sdk.constants.PERSISTED_REFRESH_LOGIN_PROVIDER_TOKENS));
   }
   if (shouldSharedClientIdentifierNeedsToBeRemoved()) {
     kony.sdk.logsdk.debug("### deleteMetadatafromDs:: Login meta not available, deleting identifier.");
     kony.sdk.dataStore.removeItem(kony.sdk.util.prefixAppid(kony.sdk.constants.SHARED_CLIENT_IDENTIFIER));
   }
   kony.sdk.logsdk.info("### deleteMetadatafromDs:: metadata deleted successfuly from dataStore");
 };
 /**
  * Validates the deeplink params. A valid deeplink redirection will contain params "code" & "launchmode" is 3.
  * @param {map} params  - query parameters from the deeplink redirection
  */
 kony.sdk.isValidDeeplinkCallback = function(params) {
   if (params && params.launchmode == kony.sdk.constants.LAUNCHMODE_DEEPLINK && params.launchparams.code) return true;
   else return false;
 };
 kony.sdk.getReportingParamsForOfflineObjects = function() {
   var reportingData = kony.sdk.getPayload(konyRef);
   reportingData.xmode = "offline";
   reportingData.rsid = kony.sdk.currentInstance.getSessionId();
   return JSON.stringify(reportingData);
 };
 var MFAppVersion;
 kony.sdk.setFabricAppVersion = function(version) {
   MFAppVersion = version;
 };
 /**
  * Returns the default fabric application version. For auto init app version will be available in appConfig,
  * for manual init developer has to send fabric version explicitly.
  *
  * Fabric version in manual init has more priority over one specified in visualizer.
  * @return {*}
  */
 kony.sdk.getFabricAppVersion = function() {
   if (!kony.sdk.isNullOrUndefined(MFAppVersion)) {
     return MFAppVersion;
   } else if (!kony.sdk.isNullOrUndefined(appConfig) && !kony.sdk.isNullOrUndefined(appConfig.runtimeAppVersion)) {
     if (appConfig.runtimeAppVersion == "Default" && !kony.sdk.isNullOrUndefined(appConfig.svcDoc)) {
       return appConfig.svcDoc.app_default_version;
     }
     return appConfig.runtimeAppVersion;
   }
 };
 /**
  * Encrypt given SSO token
  *
  * @param ssotoken token to be encrypted.
  * @return encrypted SSO token
  */
 kony.sdk.util.encryptSSOToken = function(ssotoken) {
   kony.sdk.logsdk.trace("Entering into kony.sdk.util.encryptSSOToken");
   return kony.sdk.util.encryptText(ssotoken, [kony.sdk.util.getAndSaveUUIDforSSO()], kony.sdk.constants.ENCRYPTION_ALGO_AES);
 };
 /**
  * Decrypt given encrypted_token
  *
  * @param token to be decrypted
  * @return decrypted token
  */
 kony.sdk.util.decryptSSOToken = function(encryptedtoken) {
   kony.sdk.logsdk.trace("Entering into kony.sdk.util.decryptSSOToken");
   if (kony.sdk.util.isNullOrUndefinedOrEmptyObject(encryptedtoken)) {
     return encryptedtoken;
   }
   var decryptedToken = kony.sdk.util.decryptText(encryptedtoken, [kony.sdk.util.getAndSaveUUIDforSSO()], kony.sdk.constants.ENCRYPTION_ALGO_AES);
   if (kony.sdk.util.isNullOrUndefinedOrEmptyObject(decryptedToken)) {
     // Backward compatibility. Since we didnt encrypt with deviceID decryption will fail. Decrypt with old key "ssoencryption". Encrypting with deviceID & persisting response.
     decryptedToken = kony.sdk.util.decryptText(encryptedtoken, [kony.sdk.constants.SSO_ENCRYPTION_KEY], kony.sdk.constants.ENCRYPTION_ALGO_AES);
     if (!kony.sdk.isNullOrUndefined(decryptedToken) && decryptedToken !== '') {
       kony.sdk.util.saveSSOToken(decryptedToken);
     }
   }
   return decryptedToken;
 };
 /**
  * Generates key to encrypt/decrypt any text.
  * @param salt {Array}
  * @param keyStrength {Integer}
  * @returns string
  */
 kony.sdk.util.generateSecureKeyFromText = function(salt, keyStrength) {
   var secureKey = "";
   if (!kony.sdk.isNullOrUndefined(salt) && kony.sdk.isArray(salt)) {
     var params = {};
     params["passphrasetext"] = salt;
     params["subalgo"] = kony.sdk.constants.ENCRYPTION_ALGO_AES;
     if (kony.sdk.getPlatformName() === kony.sdk.constants.PLATFORM_IOS && keyStrength === kony.sdk.constants.AES_ALGO_KEY_STRENGTH_256) {
       params[kony.sdk.constants.ENC_PASSPHRASE_HASH_ALGO] = kony.sdk.constants.HASH_FUNCTION_SHA2;
     } else {
       params[kony.sdk.constants.ENC_PASSPHRASE_HASH_ALGO] = kony.sdk.constants.HASH_FUNCTION_MD5;
     }
     secureKey = kony.crypto.newKey(kony.sdk.constants.ENC_TYPE_PASSPHRASE, keyStrength, params);
   } else {
     throw new Exception(kony.sdk.errorConstants.CONFIGURATION_FAILURE, "Invalid param. salt cannot be null, should be of type Array");
   }
   return secureKey;
 };
 /**
  * Encrypts text with the given salt and encryptionAlgo.
  * @param text to be encrypted
  * @param salt additional input to a one-way function that "hashes" data
  * @param encryptionAlgo algo to be used to decrypt
  * @returns decrypted string
  */
 kony.sdk.util.encryptText = function(text, salt, encryptionAlgo) {
   try {
     var encryptionKey = kony.sdk.util.generateSecureKeyFromText(salt, kony.sdk.constants.AES_ALGO_KEY_STRENGTH_256);
     if (kony.sdk.isNullOrUndefined(encryptionKey)) {
       encryptionKey = kony.sdk.util.generateSecureKeyFromText(salt, kony.sdk.constants.AES_ALGO_KEY_STRENGTH_128);
     }
     var encryptedText = kony.crypto.encrypt(encryptionAlgo, encryptionKey, text, {});
     if (kony.sdk.isNullOrUndefined(encryptedText) || encryptedText == "") {
       kony.sdk.util.recordCustomEvent("INVALID CRYPTO RESPONSE", "encryptedText: " + encryptedText, "encryptedText: null or EMPTY", "cipher", null);
     }
     var base64Data = kony.convertToBase64(encryptedText);
     if (kony.sdk.isNullOrUndefined(base64Data) || base64Data == "") {
       kony.sdk.util.recordCustomEvent("INVALID BASE64 DATA", "base64Data: " + base64Data, "base64Data: null or EMPTY", "cipher", null);
     }
     return base64Data;
   } catch (exception) {
     kony.sdk.logsdk.error("Exception occurred while encrypting text, exception :", exception);
     kony.sdk.util.recordCustomEvent("INVALID CRYPTO RESPONSE", "get encryptText: " + text, "encryptText: exception", "cipher", null);
   }
 };
 /**
  * Decrypts text with given decryptionAlgo and decryptionKey
  * @param text to be decrypted
  * @param salt additional input to a one-way function that "hashes" data in case of fallback
  * @param decryptionAlgo algo to be used to decrypt
  * @param decryptionKey key to be used to decrypt
  * @returns decrypted string
  */
 kony.sdk.util.performDecryption = function(text, salt, decryptionAlgo, decryptionKey) {
   try {
     // convert base64 to rawbytes
     var raw_text = kony.sdk.util.convertBase64ToRawBytes(text);
     var decryptText = kony.crypto.decrypt(decryptionAlgo, decryptionKey, raw_text, {});
     if (kony.sdk.isNullOrUndefined(decryptText) || decryptText == "") {
       kony.sdk.util.recordCustomEvent("INVALID CRYPTO RESPONSE", "get decryptText: " + text, "decryptText: null", "decipher", null);
       if (isKeyStrength256ForDecryption) {
         isKeyStrength256ForDecryption = false;
         decryptText = kony.sdk.util.fallBackToAES128ForDecryption(text, salt, decryptionAlgo);
       }
     }
     return decryptText;
   } catch (exception) {
     kony.sdk.logsdk.error("Exception occurred while converting to raw text, exception :", exception);
     kony.sdk.util.recordCustomEvent("INVALID CRYPTO RESPONSE", "get decryptText: " + text, "decryptText: exception", "decipher", null);
   }
 };
 /**
  * Initiates text decryption with the given salt and encryptionAlgo 128 bit
  * Immediate encryption with 256 bit is initiated for cases where 256 bit is supported and are using 128 bit until now
  * @param text to be decrypted
  * @param salt additional input to a one-way function that "hashes" data
  * @param decryptionAlgo algo to be used to decrypt
  * @returns decrypted string
  */
 kony.sdk.util.fallBackToAES128ForDecryption = function(text, salt, decryptionAlgo) {
   try {
     var decryptionKey = kony.sdk.util.generateSecureKeyFromText(salt, kony.sdk.constants.AES_ALGO_KEY_STRENGTH_128);
     var decryptText = kony.sdk.util.performDecryption(text, salt, decryptionAlgo, decryptionKey);
     kony.sdk.util.encryptText(decryptText, salt, kony.sdk.constants.ENCRYPTION_ALGO_AES);
     return decryptText;
   } catch (exception) {
     kony.sdk.logsdk.error("Exception occurred while decrypting text using AES 128, exception :", exception);
   }
 };
 /**
  * Flag to maintain info on decryption key size
  * @type {boolean}
  */
 isKeyStrength256ForDecryption = true;
 /**
  * Initiates text decryption with the given salt and encryptionAlgo 256 bit and falls back to 128 bit in cases of 256 bit not being supported
  * @param text to be decrypted
  * @param salt additional input to a one-way function that "hashes" data
  * @param decryptionAlgo algo to be used to decrypt
  * @returns decrypted string
  */
 kony.sdk.util.decryptText = function(text, salt, decryptionAlgo) {
   try {
     var decryptedText = null;
     var decryptionKey = kony.sdk.util.generateSecureKeyFromText(salt, kony.sdk.constants.AES_ALGO_KEY_STRENGTH_256);
     if (!kony.sdk.isNullOrUndefined(decryptionKey)) {
       isKeyStrength256ForDecryption = true;
       decryptedText = kony.sdk.util.performDecryption(text, salt, decryptionAlgo, decryptionKey);
     } else {
       isKeyStrength256ForDecryption = false;
       decryptedText = kony.sdk.util.fallBackToAES128ForDecryption(text, salt, decryptionAlgo);
     }
     return decryptedText;
   } catch (exception) {
     kony.sdk.logsdk.error("Exception occurred while decrypting text using AES 256, exception :", exception);
   }
 };
 /**
  * Converts base64String to raw bytes using frameworks API kony.convertToRawBytes
  */
 kony.sdk.util.convertBase64ToRawBytes = function(base64String) {
   var retVal = atob(base64String);
   if (kony.sdk.isNullOrUndefined(retVal) || retVal == "") {
     kony.sdk.util.recordCustomEvent("INVALID RAW BYTES", "get convertBase64ToRawBytes: ", "rawbytes: null", "decipher", null);
   }
   return retVal;
 };
 /**
  * Returns type of object
  * framework api kony.type is not supported by Phonegap and plain-js platforms
  * @return {*}
  */
 kony.sdk.util.type = function(objectVar) {
   if (kony.sdk.getAType() === kony.sdk.constants.SDK_ATYPE_NATIVE) {
     return kony.type(objectVar)
   } else {
     return typeof(objectVar)
   }
 };
 kony.sdk.util.encryptAppConfig = function(data) {
   var encryptionSalt = [kony.sdk.util.getSharedClientId()];
   var encryptionAlgo = kony.sdk.constants.ENCRYPTION_ALGO_AES;
   if (kony.sdk.isNullOrUndefined(data) || data == "") {
     kony.sdk.util.recordCustomEvent("INVALID APP CONFIG", "set appConfig: " + data, "appConfig: null or EMPTY", "cipher", null);
   }
   return kony.sdk.util.encryptText(data, encryptionSalt, encryptionAlgo);
 }
 kony.sdk.util.decryptAppConfig = function(data) {
   var encryptionSalt = [kony.sdk.util.getSharedClientId()];
   var encryptionAlgo = kony.sdk.constants.ENCRYPTION_ALGO_AES;
   var appConfig = kony.sdk.util.decryptText(data, encryptionSalt, encryptionAlgo);
   if (kony.sdk.isNullOrUndefined(appConfig) || appConfig == "") {
     kony.sdk.util.recordCustomEvent("INVALID APP CONFIG", "get appConfig: " + data, "appConfig: null", "decipher", null);
   }
   return appConfig;
 }
 /**
  * Loads the saved App metadata from datastore
  * @param dsAppMetaData to be updated
  * @param dsAppServiceDoc to be updated
  * @returns dsAppConfig {Object} - Contains both updated params
  */
 kony.sdk.util.loadMetadataFromDs = function(dsAppMetaData, dsAppServiceDoc) {
   var dsAppConfig = {};
   var dsAppData = kony.sdk.dataStore.getItem(appConfig.appId);
   dsAppServiceDoc = kony.sdk.dataStore.getItem(kony.sdk.util.prefixAppid(kony.sdk.constants.MOBILE_FABRIC_SERVICE_DOC));
   if (!kony.sdk.isNullOrUndefined(dsAppData)) {
     dsAppMetaData = JSON.parse(dsAppData);
   }
   if (kony.sdk.util.isAppConfigEncrypted()) {
     if (!kony.sdk.isNullOrUndefined(dsAppMetaData)) {
       var appKey = kony.sdk.util.decryptAppConfig(dsAppMetaData.appKey);
       var appSecret = kony.sdk.util.decryptAppConfig(dsAppMetaData.appSecret);
       var serviceUrl = kony.sdk.util.decryptAppConfig(dsAppMetaData.serviceUrl);
       if (kony.sdk.util.isNullOrEmptyString(appKey) || kony.sdk.util.isNullOrEmptyString(appSecret) || kony.sdk.util.isNullOrEmptyString(serviceUrl)) {
         kony.sdk.logsdk.warn("Null values for appKey, appSecret or serviceUrl found");
         dsAppMetaData.appKey = appConfig.appKey;
         dsAppMetaData.appSecret = appConfig.appSecret;
         dsAppMetaData.serviceUrl = appConfig.serviceUrl;
         kony.sdk.logsdk.info("Using appKey, appSecret and serviceUrl from Startup.js appConfig");
         kony.sdk.util.recordCustomEvent("Decrypted appKey,appSecret and serviceUrl equals NULL", "fallback startup.js appConfig", "loadMetadataFromDS", "update metadata run time", null);
       } else {
         dsAppMetaData.appKey = appKey;
         dsAppMetaData.appSecret = appSecret;
         dsAppMetaData.serviceUrl = serviceUrl;
       }
     } else {
       kony.sdk.util.recordCustomEvent("RETRIEVE DS APP METADATA", "DS_AppMetaData not found.", "", "decipher", null);
     }
     if (!kony.sdk.isNullOrUndefined(dsAppServiceDoc)) {
       dsAppServiceDoc = kony.sdk.util.decryptAppConfig(dsAppServiceDoc);
     }
   }
   dsAppConfig = {
     dsAppMetaData: dsAppMetaData,
     dsAppServiceDoc: dsAppServiceDoc
   };
   return dsAppConfig;
 };
 /**
  * Generates a guid if it is not already present in the datastore and sets encrytion flag
  * @returns a guid from the ds
  */
 kony.sdk.util.getSharedClientId = function() {
   if (kony.sdk.isNullOrUndefined(kony.sdk.dataStore.getItem(kony.sdk.util.prefixAppid(kony.sdk.constants.SHARED_CLIENT_IDENTIFIER)))) {
     kony.sdk.dataStore.setItem(kony.sdk.util.prefixAppid(kony.sdk.constants.SHARED_CLIENT_IDENTIFIER), kony.license.generateUUID());
     kony.sdk.util.recordCustomEvent("INVALID SHARED CLIENT_ID", "Generated new SharedClient ID", "SCID: NEW_VALUE", "decipher", null);
   }
   var sharedClientID = kony.sdk.dataStore.getItem(kony.sdk.util.prefixAppid(kony.sdk.constants.SHARED_CLIENT_IDENTIFIER));
   if (kony.sdk.isNullOrUndefined(sharedClientID)) {
     kony.sdk.util.recordCustomEvent("INVALID SHARED CLIENT_ID", "get SharedClient ID", "SCID: null", "decipher", null);
   }
   return sharedClientID;
 };
 /**
  * Checks the encrytion flag in ds to validate whether appConfig is encrypted or not
  * @returns {Boolean}
  */
 kony.sdk.util.isAppConfigEncrypted = function() {
   if (!kony.sdk.isNullOrUndefined(kony.store.getItem(kony.sdk.util.prefixAppid(kony.sdk.constants.ENCRYPTION_APPCONFIG_FLAG)))) {
     return true;
   } else {
     kony.sdk.util.recordCustomEvent("NO SHARED CLIENT_ID", "", "APP Config is not encrypted", "decipher", null);
     return false;
   }
 };
 /**
  * This function checks and updates integrityKey from serviceDoc
  * @param {Object} serviceDoc - serviceDoc to be read for integrity_check_required key
  */
 kony.sdk.util.checkAndUpdateIntegrityKey = function(serviceDoc) {
   if (serviceDoc.hasOwnProperty("integrity_check_required") && serviceDoc.integrity_check_required === true) {
     //MF server >=8.2
     konyRef.mainRef.integrityKey = true;
   } else {
     //MF server < 8.2 and integrity is disabled
     konyRef.mainRef.integrityKey = false;
   }
 };
 kony.sdk.util.recordCustomEvent = function(eventSubType, formID, widgetID, flowTag, metadata) {
   try {
     if (kony.sdk.isNullOrUndefined(KNYMetricsService) && kony.sdk.currentInstance && kony.sdk.currentInstance.getMetricsService) {
       KNYMetricsService = kony.sdk.currentInstance.getMetricsService();
     }
     // Null check to make sure that the KNYMetricsService object is available before making send event calls.
     if (!kony.sdk.isNullOrUndefined(KNYMetricsService)) {
       /* Commenting this function invocation due to bug : MFSDK-5496.
          Can be uncommented if required */
       //  KNYMetricsService.sendEvent("Custom", eventSubType, formID, widgetID, flowTag, metadata);
     } else {
       kony.sdk.logsdk.warn("recordCustomEvent failed as Metrics Service is not available");
     }
   } catch (error) {
     kony.sdk.logsdk.warn("recordCustomEvent failed due to " + error);
   }
 };
 kony.sdk.util.recordAndFlushCustomEvent = function(eventSubType, formID, widgetID, flowTag, metadata) {
   try {
     if (kony.sdk.isNullOrUndefined(KNYMetricsService) && kony.sdk.currentInstance && kony.sdk.currentInstance.getMetricsService) {
       KNYMetricsService = kony.sdk.currentInstance.getMetricsService();
     }
     // Null check to make sure that the KNYMetricsService object is available before making send event calls.
     if (!kony.sdk.isNullOrUndefined(KNYMetricsService)) {
       /* Commenting these function invocations due to bug : MFSDK-5496.
          Can be uncommented if required */
       //   KNYMetricsService.sendEvent("Custom", eventSubType, formID, widgetID, flowTag, metadata);
       //  KNYMetricsService.flushEvents();
     } else {
       kony.sdk.logsdk.warn("recordAndFlushCustomEvent failed as Metrics Service is not available");
     }
   } catch (error) {
     kony.sdk.logsdk.warn("recordAndFlushCustomEvent failed due to " + error);
   }
 };
 /**
  * Utility function to store, get and remove refresh tokens from datastore
  */
 kony.sdk.util.getRefreshLoginTokenStoreUtility = (function() {
   var refreshLoginTokenStoreUtilitySingletonObject = null;

   function refreshLoginTokenStoreUtility() {
     var currentObject = this;
     /**
      * This is an utility method to retrieve the persisted refresh login provider tokens
      * @returns {Object} - JSON Object containing all persisted login provider tokens
      */
     var getPersistedRefreshLoginProviderTokensObject = function() {
       kony.sdk.logsdk.perf("Entering getPersistedRefreshLoginProviderTokensObject");
       var encryptedPersistedRefreshLoginProviderTokens = kony.sdk.dataStore.getItem(kony.sdk.constants.PERSISTED_REFRESH_LOGIN_PROVIDER_TOKENS);
       var persistedRefreshLoginProviderTokensObject = null;
       if (!kony.sdk.isNullOrUndefined(encryptedPersistedRefreshLoginProviderTokens)) {
         kony.sdk.logsdk.info("decrypting persisted refresh login tokens");
         var decryptedPersistedRefreshLoginProviderTokens = kony.sdk.util.decryptText(encryptedPersistedRefreshLoginProviderTokens, [kony.sdk.util.getSharedClientId()], kony.sdk.constants.ENCRYPTION_ALGO_AES);
         if (!kony.sdk.isNullOrUndefined(decryptedPersistedRefreshLoginProviderTokens) && kony.sdk.isJson(decryptedPersistedRefreshLoginProviderTokens)) {
           kony.sdk.logsdk.info("parsing decrypted persisted refresh login tokens");
           persistedRefreshLoginProviderTokensObject = JSON.parse(decryptedPersistedRefreshLoginProviderTokens);
         } else {
           kony.sdk.logsdk.warn("failed to decrypt " + kony.sdk.constants.PERSISTED_REFRESH_LOGIN_PROVIDER_TOKENS + " for refresh login");
         }
         kony.sdk.logsdk.info("returning persisted refresh login tokens");
       } else {
         kony.sdk.logsdk.info("there are no available persisted refresh login tokens");
       }
       return persistedRefreshLoginProviderTokensObject;
     }
     /**
      * This is an utility method to store refresh login tokens in datastore
      * @param {JSON} refreshLoginProviderTokensObject - JSON Object containing provider specific refresh tokens as key, value pairs
      */
     var storePersistedRefreshLoginProviderTokensObject = function(refreshLoginProviderTokensObject) {
       kony.sdk.logsdk.perf("Entering storePersistedRefreshLoginProviderTokensObject");
       if (kony.sdk.isNullOrUndefined(refreshLoginProviderTokensObject)) {
         return;
       }
       var stringifiedRefreshLoginProviderTokens = JSON.stringify(refreshLoginProviderTokensObject);
       kony.sdk.logsdk.info("encrypting refresh login tokens object and persisting");
       var encryptedRefreshLoginProviderTokens = kony.sdk.util.encryptText(stringifiedRefreshLoginProviderTokens, [kony.sdk.util.getSharedClientId()], kony.sdk.constants.ENCRYPTION_ALGO_AES);
       kony.sdk.dataStore.setItem(kony.sdk.constants.PERSISTED_REFRESH_LOGIN_PROVIDER_TOKENS, encryptedRefreshLoginProviderTokens);
     }
     /**
      * This is an utility method used to remove all persisted refresh login provider tokens from datastore
      */
     this.removeAllPersistedRefreshLoginProviderTokens = function() {
       kony.sdk.logsdk.perf("Entering removeAllPersistedRefreshLoginProviderTokens");
       kony.sdk.dataStore.removeItem(kony.sdk.constants.PERSISTED_REFRESH_LOGIN_PROVIDER_TOKENS);
     }
     /**
      * This function is used to store the refresh tokens based on provider
      * @param {string} provider - name of the provider for which the refresh tokens needs to be stored
      * @param {Object} tokensData - JSON Object containing both backend and internal refresh tokens for the provided provider
      */
     this.storeTokens = function(provider, tokensData) {
       kony.sdk.logsdk.perf("Entering storeTokens");
       if (kony.sdk.util.isNullOrEmptyString(provider) || kony.sdk.util.isNullOrUndefinedOrEmptyObject(tokensData)) {
         return;
       }
       var persistedRefreshLoginProviderTokensObject = getPersistedRefreshLoginProviderTokensObject();
       if (kony.sdk.isNullOrUndefined(persistedRefreshLoginProviderTokensObject)) {
         persistedRefreshLoginProviderTokensObject = {};
       }
       persistedRefreshLoginProviderTokensObject[provider] = tokensData;
       kony.sdk.logsdk.info("persisting refresh login tokens in datastore");
       storePersistedRefreshLoginProviderTokensObject(persistedRefreshLoginProviderTokensObject);
       kony.sdk.logsdk.info("successfully stored refresh login tokens");
     }
     /**
      * This function gets the persisted refresh tokens
      * @param {string} provider - name of the provider for which the refresh tokens data needs to be retrieved
      * @returns {Object} - JSON Object containing provider specific internal and backend refresh token
      */
     this.getTokens = function(provider) {
       kony.sdk.logsdk.perf("Entering getTokens");
       if (kony.sdk.util.isNullOrEmptyString(provider)) {
         return null;
       }
       kony.sdk.logsdk.info("Fetching refresh login provider tokens from datastore");
       var persistedRefreshLoginProviderTokensObject = getPersistedRefreshLoginProviderTokensObject();
       var providerTokens = null;
       if (!kony.sdk.isNullOrUndefined(persistedRefreshLoginProviderTokensObject)) {
         providerTokens = persistedRefreshLoginProviderTokensObject[provider];
       }
       kony.sdk.logsdk.info("returning provider specific tokens");
       return providerTokens;
     }
     /**
      * This function removes the persisted refresh tokens for the provider
      * @param {string} provider - name of the provider for which the refresh tokens have to be removed
      */
     this.removeTokens = function(provider) {
       kony.sdk.logsdk.perf("Entering removeTokens");
       if (kony.sdk.util.isNullOrEmptyString(provider)) {
         return null;
       }
       kony.sdk.logsdk.info("Fetching refresh login provider tokens from datastore");
       var persistedRefreshLoginProviderTokensObject = getPersistedRefreshLoginProviderTokensObject();
       if (kony.sdk.isNullOrUndefined(persistedRefreshLoginProviderTokensObject)) {
         return;
       }
       kony.sdk.logsdk.info("removing provider specific tokens from datastore");
       delete persistedRefreshLoginProviderTokensObject[provider];
       if (Object.keys(persistedRefreshLoginProviderTokensObject).length === 0) {
         //removing persistedRefreshLoginProviderTokens from datastore
         currentObject.removeAllPersistedRefreshLoginProviderTokens();
       } else {
         storePersistedRefreshLoginProviderTokensObject(persistedRefreshLoginProviderTokensObject);
       }
     }
     /**
      * This function returns the provider specific token (token can be internal or backend refresh token based on tokenType)
      * @param provider - name of the provider for which the token has to be retrieved
      * @param tokenType - internal / backend refresh token constant
      * @returns token - corresponding internal or backend refresh token
      */
     var getToken = function(provider, tokenType) {
       kony.sdk.logsdk.perf("Entering getToken");
       var tokensData = currentObject.getTokens(provider);
       var token = null;
       if (!kony.sdk.isNullOrUndefined(tokensData)) {
         token = tokensData[tokenType];
       }
       return token;
     }
     /**
      * This function updates the token (can be internal/refresh) based on the tokenType
      * @param provider - name of the provider for which the token has to be updated
      * @param tokenType - type of the token to be updated (internal/refresh token)
      */
     var setToken = function(provider, tokenType, token) {
       kony.sdk.logsdk.perf("Entering setToken");
       var tokensData = currentObject.getTokens(provider);
       if (!kony.sdk.isNullOrUndefined(tokensData)) {
         tokensData[tokenType] = token;
         currentObject.storeTokens(provider, tokensData);
       }
     }
     /**
      * This function gets the internal refresh token for the given provider
      * @param {string} provider - name of the provider for which the internal refresh token has to be retrieved
      * @returns {string} internal refresh token for the given provider, returns null if provider is invalid
      */
     this.getInternalRefreshToken = function(provider) {
       kony.sdk.logsdk.perf("Entering getInternalRefreshToken");
       return getToken(provider, kony.sdk.constants.INTERNAL_REFRESH_TOKEN);
     }
     /**
      * This function set the internal refresh token for the give providers
      * @param {string/Array} providers - name of the provider/providers for which the given internal refresh token has to be updated
      * @param {string} internalRefreshToken - internal refresh token for the given provider
      */
     this.setInternalRefreshToken = function(providers, internalRefreshToken) {
       kony.sdk.logsdk.perf("Entering setInternalRefreshToken");
       //if given list of providers
       if (!kony.sdk.isNullOrUndefined(providers) && (providers.constructor === Array)) {
         var persistedRefreshLoginProviderTokens = getPersistedRefreshLoginProviderTokensObject();
         if (kony.sdk.isNullOrUndefined(persistedRefreshLoginProviderTokens)) {
           kony.sdk.logsdk.warn("there are no refresh login providers in data store, so provided backend refresh tokens can't be updated");
           return;
         }
         var persistedProvidersList = Object.keys(persistedRefreshLoginProviderTokens);
         if (!kony.sdk.isNullOrUndefined(persistedProvidersList)) {
           for (var index = 0; index < providers.length; index++) {
             if (persistedProvidersList.indexOf(providers[index]) != -1) {
               persistedRefreshLoginProviderTokens[providers[index]][kony.sdk.constants.INTERNAL_REFRESH_TOKEN] = internalRefreshToken;
             }
           }
           //store the updated tokens in data store
           storePersistedRefreshLoginProviderTokensObject(persistedRefreshLoginProviderTokens);
         }
       } else { // if given a provider
         setToken(providers, kony.sdk.constants.INTERNAL_REFRESH_TOKEN, internalRefreshToken);
       }
     }
     /**
      * This function gets the backend refresh token for the given provider
      * @param {string} provider - name of the provider for which the backend refresh token has to be retrieved
      * @returns {string} backendRefreshToken - backend refresh token for the given provider
      */
     this.getBackendRefreshToken = function(provider) {
       kony.sdk.logsdk.perf("Entering getBackendRefreshToken");
       return getToken(provider, kony.sdk.constants.BACKEND_REFRESH_TOKEN);
     }
     /**
      * This function updates the backend refresh token for the given provider
      * @param {string} provider - name of the provider for which the given backendRefreshToken has to be updated
      * @param {string} backendRefreshToken - backend refresh token for the given provider
      */
     this.setBackendRefreshToken = function(provider, backendRefreshToken) {
       kony.sdk.logsdk.perf("Entering setBackendRefreshToken");
       setToken(provider, kony.sdk.constants.BACKEND_REFRESH_TOKEN, backendRefreshToken);
     }
     /**
      * This function returns JSON object of all the persisted internal and refresh tokens with provider
      * @returns {Object} - JSON object containing aggregate of internal and backend refresh tokens
      */
     this.getAllPersistedRefreshLoginProviderTokens = function() {
       kony.sdk.logsdk.perf("Entering getAllPersistedRefreshLoginProviderTokens");
       return getPersistedRefreshLoginProviderTokensObject();
     }
     /**
      * This function updates backend refresh tokens for the given providers
      * @param {Object} backendRefreshTokens - JSON object containing provider name as key and value as backend refresh token
      */
     this.setBulkBackendRefreshTokens = function(backendRefreshTokens) {
       kony.sdk.logsdk.perf("Entering setBulkBackendRefreshTokens");
       if (kony.sdk.isNullOrUndefined(backendRefreshTokens) || !(backendRefreshTokens instanceof Object)) {
         kony.sdk.logsdk.warn("provided backend refresh tokens are null/undefined or not an Object type");
         return;
       }
       var persistedRefreshLoginProviderTokens = getPersistedRefreshLoginProviderTokensObject();
       if (kony.sdk.isNullOrUndefined(persistedRefreshLoginProviderTokens)) {
         kony.sdk.logsdk.warn("there are no refresh login providers in data store, so provided backend refresh tokens can't be updated");
         return;
       }
       var persistedProvidersList = Object.keys(persistedRefreshLoginProviderTokens);
       if (!kony.sdk.isNullOrUndefined(persistedProvidersList)) {
         var providers = Object.keys(backendRefreshTokens);
         var provider = null;
         for (var index = 0; index < providers.length; index++) {
           provider = providers[index];
           if (persistedProvidersList.indexOf(provider) != -1) {
             if (!kony.sdk.isNullOrUndefined(backendRefreshTokens[provider]) && konyRef.refreshLoginProvidersSet.has(provider)) {
               persistedRefreshLoginProviderTokens[provider][kony.sdk.constants.BACKEND_REFRESH_TOKEN] = backendRefreshTokens[provider];
             } else {
               kony.sdk.logsdk.warn("backend refresh token for " + provider + " is null or undefined");
             }
           }
         }
         //store the updated tokens in data store
         storePersistedRefreshLoginProviderTokensObject(persistedRefreshLoginProviderTokens);
       }
     }
   }
   return function() {
     if (kony.sdk.isNullOrUndefined(refreshLoginTokenStoreUtilitySingletonObject)) {
       refreshLoginTokenStoreUtilitySingletonObject = new refreshLoginTokenStoreUtility();
     }
     return refreshLoginTokenStoreUtilitySingletonObject;
   };
 })();
 /**
  * Utility function for PKCE enablement in Oauth flows
  * @return singleton utility object
  */
 kony.sdk.util.getUtilityForPKCE = (function() {
   var utilityObject = null;
   /**
    * Helper class containing methods for generating app verifier, app challenge,
    * updating url & body params
    */
   function helperClassPKCE() {
     var secureParams = null;
     /**
      * This method resets app verifier & app challenge to null
      * @return void
      */
     this.resetPKCEObject = function() {
       kony.sdk.logsdk.debug("secure params reset");
       secureParams = null;
     };
     /**
      * This method resets runtime utility object's PKCE values
      * and tries to generates app verifier & app challenge
      * @return void
      */
     this.initializePKCEObject = function() {
       utilityObject.resetPKCEObject();
       try {
         var app_verifier = kony.crypto.generateSecureRandom({
           "size": 43,
           "type": "base64"
         });
         app_verifier = replaceUnwantedCharacters(app_verifier);
         app_verifier = app_verifier.substring(0, 128);
         var base64table = {
           "returnBase64String": "true"
         };
         var app_challenge = kony.crypto.createHash(kony.sdk.constants.HASHING_ALGORITHM, app_verifier, base64table);
         app_challenge = replaceUnwantedCharacters(app_challenge);
         if (!kony.sdk.isNullOrUndefined(app_verifier) && !kony.sdk.isNullOrUndefined(app_challenge)) {
           kony.sdk.logsdk.debug("secure params generated");
           secureParams = {};
           secureParams[kony.sdk.constants.APP_VERIFIER] = app_verifier;
           secureParams[kony.sdk.constants.APP_CHALLENGE] = app_challenge;
         } else {
           kony.sdk.logsdk.error("secure params generated are null");
         }
       } catch (e) {
         kony.sdk.logsdk.error("could not generated secure params due to " + JSON.stringify(e));
         return false;
       }
       return true;
     };
     /**
      * This method replaces unwanted chars present in base64 table to RFC standardized char values
      * @param base64String - {string}
      * @return {string} base64 string with unwanted characters replaced
      */
     function replaceUnwantedCharacters(base64String) {
       return base64String.replace(/\+/g, '-').replace(/\//g, '_').replace(/=/g, '');
     }
     /**
      * This method adds app_challenge & app_challenge_method as queryParams on url
      * @param {String} url to call for login
      * @return {String} url with added query params
      */
     this.appendAppChallengeOnURL = function(url) {
       if (!kony.sdk.isNullOrUndefined(secureParams) && !kony.sdk.isNullOrUndefined(url)) {
         url += "&" + kony.sdk.constants.APP_CHALLENGE + kony.sdk.constants.EQUAL_TO + secureParams[kony.sdk.constants.APP_CHALLENGE] + "&" + kony.sdk.constants.KEY_APP_CHALLENGE_METHOD + kony.sdk.constants.EQUAL_TO + kony.sdk.constants.APP_CHALLENGE_METHOD_VALUE;
         if (kony.sdk.getPlatformName() === kony.sdk.constants.PLATFORM_THIN_CLIENT) {
           url += "&" + kony.sdk.constants.OAUTH_SESSION_RESPONSE_TYPE + kony.sdk.constants.EQUAL_TO + kony.sdk.constants.HEADER;
         } else {
           url += "&" + kony.sdk.constants.OAUTH_SESSION_RESPONSE_TYPE + kony.sdk.constants.EQUAL_TO + kony.sdk.constants.QUERY;
         }
         //after we passed app_challenge, we should no longer keep values with us.
         delete secureParams[kony.sdk.constants.APP_CHALLENGE];
       }
       return url;
     };
     /**
      * This method adds app_verifier in bodyParams
      * and destroys runtime utility object's PKCE values for cleanup and avoiding misuse
      * @param {JSON} bodyParams
      * @return {JSON} bodyParams with added app_verifier
      */
     this.appendAppVerifierInBodyParams = function(bodyParams) {
       if (!kony.sdk.isNullOrUndefined(secureParams) && kony.sdk.util.isJsonObject(bodyParams)) {
         bodyParams[kony.sdk.constants.APP_VERIFIER] = secureParams[kony.sdk.constants.APP_VERIFIER];
         //after we passed app_verifier, last step of login activity will end & we should no longer keep values with us.
         utilityObject.resetPKCEObject();
       }
       return bodyParams;
     };
   }
   return function() {
     if (kony.sdk.isNullOrUndefined(utilityObject)) {
       utilityObject = new helperClassPKCE();
       Object.freeze(utilityObject);
     }
     return utilityObject;
   }
 })();
 /** Utility to genarete clientUUID for service calls **/
 kony.sdk.util.checkAndGenerateClientUUID = function() {
   var persistedClientUUID = kony.sdk.util.decryptAndRetrieveClientUUID();
   if (kony.sdk.util.isNullOrEmptyString(persistedClientUUID)) {
     var clientUUID = kony.license.generateUUID().toString();
     konyRef.clientUUID = clientUUID;
     kony.sdk.util.encryptAndSaveClientUUID(clientUUID);
   } else {
     konyRef.clientUUID = persistedClientUUID;
   }
 };
 kony.sdk.util.encryptAndSaveClientUUID = function(clientUUID) {
   var encryptionSalt = [kony.sdk.util.getSDKUniversalSalt()];
   var encryptionAlgo = kony.sdk.constants.ENCRYPTION_ALGO_AES;
   var encrpytedText = kony.sdk.util.encryptText(clientUUID, encryptionSalt, encryptionAlgo);
   kony.sdk.dataStore.setItem(kony.sdk.constants.CLIENT_SDK_UUID, encrpytedText);
 };
 kony.sdk.util.decryptAndRetrieveClientUUID = function() {
   var encryptedText = kony.sdk.dataStore.getItem(kony.sdk.constants.CLIENT_SDK_UUID);
   if (kony.sdk.util.isNullOrEmptyString(encryptedText)) {
     return null;
   }
   var encryptionSalt = [kony.sdk.util.getSDKUniversalSalt()];
   var encryptionAlgo = kony.sdk.constants.ENCRYPTION_ALGO_AES;
   var decrpytedText = kony.sdk.util.decryptText(encryptedText, encryptionSalt, encryptionAlgo);
   return decrpytedText;
 };
 /** Utility to get sdk universal salt **/
 kony.sdk.util.getSDKUniversalSalt = function() {
   var salt = kony.sdk.dataStore.getItem(kony.sdk.constants.CLIENT_SDK_UNIVERSAL_SALT);
   if (!kony.sdk.util.isNullOrEmptyString(salt)) {
     return salt;
   }
   salt = kony.license.generateUUID().toString();
   kony.sdk.dataStore.setItem(kony.sdk.constants.CLIENT_SDK_UNIVERSAL_SALT, salt);
   return salt;
 };
 /**
  * Utility function to manage sdk meta data for login in same window
  */
 kony.sdk.util.getMetaDataManagerForLoginInSameWindow = (function() {
   var utilityObject = null;

   function MetaDataManager() {
     var metaData = null;
     var networkProvider = null;
     /**
      * This function returns Middleware endpoint for saving and retrieve values in cookie
      * @return {*}
      */
     function getClientStateEndpoint() {
       var mainRef = konyRef.mainRef;
       var middlewareServerUrl = mainRef.config.reportingsvc.session.split("/IST")[0];
       return middlewareServerUrl + kony.sdk.constants.APP_VERIFIER_MW_STORE_ENDPOINT;
     }
     /**
      * This method sets given value to current object of utility against given key
      * @param key
      * @param value
      */
     this.setItem = function(key, value) {
       kony.sdk.logsdk.info("setting value for MetaDataManagerForLoginInSameWindow for key-" + key);
       metaData.set(key, value);
     }
     /**
      * This method returns corresponding value for given key
      * @param key
      * @returns {any}
      */
     this.getItem = function(key) {
       kony.sdk.logsdk.info("getting value for MetaDataManagerForLoginInSameWindow for key-" + key);
       return metaData.get(key);
     }
     /**
      * This method retrieves app verifier at Middleware as sdk/browser being a public client should not store locally
      * successCallback will be called with app verifier body json if call gets passed ,otherwise failureCallback with error.
      * @param successCallback
      * @param failureCallback
      */
     this.retrieveAppVerifier = function(successCallback, failureCallback) {
       kony.sdk.logsdk.info("Entering retrieveAppVerifier");
       kony.sdk.claimsRefresh(_getCodeVerifier, failureCallback);

       function _getCodeVerifier() {
         kony.sdk.logsdk.info("getCodeVerifier's claims passed");
         var middlewareStateUrl = getClientStateEndpoint();
         var headers = {};
         headers[kony.sdk.constants.KONY_AUTHORIZATION_HEADER] = konyRef.currentClaimToken;
         headers[kony.sdk.constants.APP_KEY_HEADER] = konyRef.mainRef.appKey;
         headers[kony.sdk.constants.APP_SECRET_HEADER] = konyRef.mainRef.appSecret;
         var networkOptions = {};
         networkOptions.xmlHttpRequestOptions = {};
         networkOptions.xmlHttpRequestOptions.enableWithCredentials = true;
         networkOptions[kony.sdk.constants.IGNORE_MESSAGE_INTEGRITY] = true;
         networkProvider.get(middlewareStateUrl, null, headers, function(response) {
           kony.sdk.logsdk.info("Exiting retrieveAppVerifier with success");
           kony.sdk.verifyAndCallClosure(successCallback, response);
         }, function(err) {
           kony.sdk.logsdk.error("unable to save the app verifier at middleware " + middlewareStateUrl + " , due to " + err.message);
           var errorObject = kony.sdk.error.getSingleWindowLoginErrObj(kony.sdk.errorcodes.app_verifier_retrieve_failed, kony.sdk.errormessages.app_verifier_retrieve_failed);
           kony.sdk.verifyAndCallClosure(failureCallback, errorObject);
         }, null, networkOptions);
       }
     }
     /**
      * This method saves app verifier at Middleware as sdk/browser being a public client should not store locally
      * successCallback will be called if call gets passed ,otherwise failureCallback with error.
      * @param appVerifierJSON
      * @param successCallback
      * @param failureCallback
      */
     this.saveAppVerifier = function(appVerifierJSON, successCallback, failureCallback) {
       kony.sdk.logsdk.info("Entering saveAppVerifier");
       kony.sdk.claimsRefresh(_saveAppVerifier, failureCallback);

       function _saveAppVerifier() {
         kony.sdk.logsdk.info("saveAppVerifier's claims passed");
         var middlewareStateUrl = getClientStateEndpoint();
         var headers = {};
         headers[kony.sdk.constants.KONY_AUTHORIZATION_HEADER] = konyRef.currentClaimToken;
         headers[kony.sdk.constants.APP_KEY_HEADER] = konyRef.mainRef.appKey;
         headers[kony.sdk.constants.APP_SECRET_HEADER] = konyRef.mainRef.appSecret;
         var networkOptions = {};
         networkOptions.xmlHttpRequestOptions = {};
         networkOptions.xmlHttpRequestOptions.enableWithCredentials = true;
         networkOptions[kony.sdk.constants.IGNORE_MESSAGE_INTEGRITY] = true;
         networkProvider.post(middlewareStateUrl, appVerifierJSON, headers, function(response) {
           kony.sdk.logsdk.info("Exiting saveAppVerifier with success");
           kony.sdk.verifyAndCallClosure(successCallback, response);
         }, function(err) {
           kony.sdk.logsdk.error("unable to save the app verifier at middleware " + middlewareStateUrl + " , due to " + err.message);
           var errorObject = kony.sdk.error.getSingleWindowLoginErrObj(kony.sdk.errorcodes.app_verifier_save_failed, kony.sdk.errormessages.app_verifier_save_failed);
           kony.sdk.verifyAndCallClosure(failureCallback, errorObject);
         }, kony.sdk.constants.CONTENT_TYPE_JSON, networkOptions);
       }
     }
     /**
      * This method stores all value in secured way
      */
     this.saveMetaData = function() {
       kony.sdk.logsdk.info("saving data inside MetaDataManagerForLoginInSameWindow");
       kony.sdk.dataStore.setSecureItem(kony.sdk.constants.KEY_METADATA_SDK_LOGIN_FOR_SAME_WINDOW, this.getMetadataJSON());
     }
     /**
      * This method returns all values of Map as JSON
      * @returns {JSON}
      */
     this.getMetadataJSON = function() {
       kony.sdk.logsdk.info("getting value of MetaDataManagerForLoginInSameWindow in json format");
       var metaJSON = {};
       metaData.forEach(function(value, key) {
         metaJSON[key] = value;
       });
       return metaJSON;
     }
     /**
      * This method retrieves and returns secured values stored and rehydrate the current util object
      * @returns {JSON}
      */
     this.loadSavedMetaData = function() {
       if (kony.sdk.isNullOrUndefined(metaData) || metaData.size === 0) {
         kony.sdk.logsdk.info("retrieving saved value of MetaDataManagerForLoginInSameWindow");
         var metaJSON = kony.sdk.dataStore.getSecureItem(kony.sdk.constants.KEY_METADATA_SDK_LOGIN_FOR_SAME_WINDOW);
         for (key in metaJSON) {
           this.setItem(key, metaJSON[key]);
         }
       }
     }
     /**
      * This method removes stored values
      */
     this.removeSavedMetaData = function() {
       kony.sdk.logsdk.info("removing saved value of MetaDataManagerForLoginInSameWindow");
       kony.sdk.dataStore.removeItem(kony.sdk.constants.KEY_METADATA_SDK_LOGIN_FOR_SAME_WINDOW);
     }
     /**
      * This method initialize metaData object
      */
     this.initialize = function() {
       if (kony.sdk.isNullOrUndefined(metaData) && kony.sdk.isNullOrUndefined(networkProvider)) {
         kony.sdk.logsdk.info("initializing private variable of MetaDataManagerForLoginInSameWindow");
         metaData = new Map();
         networkProvider = new konyNetworkProvider();
       }
     }
     /**
      * This method removes any stored secured values and make run time values null
      */
     this.destroy = function() {
       kony.sdk.logsdk.info("making internal variable null & removing saved state of MetaDataManagerForLoginInSameWindow");
       this.removeSavedMetaData();
       metaData = null;
       networkProvider = null;
     }
   }
   return function() {
     kony.sdk.logsdk.info("returning singleton instance of MetaDataManagerForLoginInSameWindow");
     if (kony.sdk.isNullOrUndefined(utilityObject)) {
       utilityObject = new MetaDataManager();
       Object.freeze(utilityObject);
     }
     return utilityObject;
   }
 })();
 kony.sdk.util.getSessionURLfromAppConfig = function() {
   if (kony.sdk.isNullOrUndefined(appConfig) || kony.sdk.isNullOrUndefined(appConfig.svcDoc) || kony.sdk.isNullOrUndefined(appConfig.svcDoc.reportingsvc) || kony.sdk.isNullOrUndefined(appConfig.svcDoc.reportingsvc.session)) {
     return null;
   }
   return appConfig.svcDoc.reportingsvc.session;
 }/**
 * kony_serverevents version 202305.0.0
 */
/**
 * Created by Inderpreet Kaur on 3/1/2020.
 * Copyright  2020 Kony. All rights reserved.
 */
function initializeWebSocketConstants() {
  if (typeof(kony) === "undefined") {
    kony = {};
  }
  if (typeof(kony.sdk) === "undefined") {
    kony.sdk = {};
  }
  kony.sdk.websocket = kony.sdk.websocket || {};
  kony.sdk.websocket.constants = kony.sdk.websocket.constants || {};
  kony.sdk.websocket.constants = {
    BOOLEAN_TRUE: true,
    X_KONY_AUTHORIZATION: "X-Kony-Authorization",
    X_KONY_CLIENT_UUID: "clientUUID",
    EQUAL_TO: "=",
    // Callback Type Constants
    WEBSOCKET_TYPE_ONERROR: "onError",
    WEBSOCKET_TYPE_ONOPEN: "onOpen",
    WEBSOCKET_TYPE_ONCLOSE: "onClose",
    WEBSOCKET_TYPE_ONMESSAGE: "onMessage",
    WEBSOCKET_TYPE_ONPUBLISH: "onPublish",
    WEBSOCKET_TYPE_ONSUBSCRIBE: "onSubscribe",
    WEBSOCKET_TYPE_ONUNSUBSCRIBE: "onUnsubscribe",
    WEBSOCKET_TYPE_ONPUBLISH_ERROR: "onPublishError",
    WEBSOCKET_TYPE_ONSUBSCRIBE_ERROR: "onSubscribeError",
    WEBSOCKET_TYPE_ONUNSUBSCRIBE_ERROR: "onUnsubscribeError",
    WEBSOCKET_PUBLISH_EVENTS: "events",
    WEBSOCKET_SUBSCRIBE_EVENTS: "subscribe",
    WEBSOCKET_UNSUBSCRIBE_EVENTS: "unsubscribe",
    WEBSOCKET_TOPICS_EVENTS: "topics",
    //Subscribe constants
    WEBSOCKET_SUBSCRIBE_MODE: "subscribeMode",
    WEBSOCKET_MODE_PRIVATE: "private",
    WEBSOCKET_MODE_PUBLIC: "public",
    // UnSubscribe constants
    UNSUBSCRIBE_OPTION_CLOSE_CONNECTION: "closeConnection",
    WEBSOCKET_UNSUBSCRIBE_MODE: "unSubscribeMode",
    // Server Response Constants
    WEBSOCKET_RESPONSE_ACK: "ack",
    WEBSOCKET_RESPONSE_CODE: "code",
    WEBSOCKET_RESPONSE_DATA: "data",
    WEBSOCKET_RESPONSE_TOPIC: "topic",
    WEBSOCKET_RESPONSE_MESSAGE: "message",
    WEBSOCKET_RESPONSE_EVENTS_ID: "eventId",
    WEBSOCKET_RESPONSE_FAILED_EVENTS: "failedTopics",
    WEBSOCKET_RESPONSE_SUCCESSFULL_EVENTS: "successTopics",
    // Websocket log messages
    SERVER_EVENTS_NO_INTERNET_MESSAGE: "No internet available, please check device connectivity",
    SERVER_EVENTS_INITIALISING_MESSAGE: "Websocket is not initialized, initializing the socket instance",
    SERVER_EVENTS_NOT_INITIALISED_MESSAGE: "Websocket is not initialized, cannot perform unsubscribe",
    SERVER_EVENTS_CALLBACKS_ERROR_MESSAGE: "Mandatory callbacks are missing.",
    INVALID_MODE_PROVIDED_MESSAGE: "Server events mode provided is not valid.",
    INVALID_EVENT_STRING_MESSAGE: "Event string passed in event array is not valid."
  };
}
/**
 * Created by Inderpreet Kaur on 3/1/2020.
 * Copyright  2020 Kony. All rights reserved.
 */
function initializeWebSocketHandler() {
  kony.sdk.websocket = kony.sdk.websocket || {};
  var TAG = "KonyWebSocketHandler : ";
  /**
   *    Generates and returns websocket url.
   */
  kony.sdk.websocket.generateServerEventsURL = function() {
    var url = konyRef.serverEventsUrl;
    var authToken = konyRef.currentClaimToken;
    var clientUUID = konyRef.clientUUID;
    if (!kony.sdk.util.isNullOrEmptyString(authToken) && !kony.sdk.util.isNullOrEmptyString(clientUUID) && !kony.sdk.util.isNullOrEmptyString(url)) {
      url = url + "?" + kony.sdk.websocket.constants.X_KONY_AUTHORIZATION + kony.sdk.websocket.constants.EQUAL_TO + authToken + "&" + kony.sdk.websocket.constants.X_KONY_CLIENT_UUID + kony.sdk.websocket.constants.EQUAL_TO + clientUUID;
    } else {
      kony.sdk.logsdk.error(TAG + "generateServerEventsURL:: authToken or serverEventsUrl or clientUUID is null or undefined");
      return null;
    }
    return url;
  };
  kony.sdk.websocket.setServerEventsCallbacks = function(onMessage, onError, onClose) {
    var LOG_PREFIX = "kony.sdk.webSocket.setServerEventsCallbacks";
    kony.sdk.logsdk.trace(" Entering " + LOG_PREFIX);

    function onMessageCallback(result) {
      kony.sdk.logsdk.perf("Executing onMessageCallback");
      kony.sdk.verifyAndCallClosure(onMessage, result);
      kony.sdk.logsdk.perf("Executing Finished onMessageCallback");
    }

    function onErrorCallback(error) {
      kony.sdk.logsdk.perf("Executing onErrorCallback");
      kony.sdk.logsdk.error("subscribeServerEvents::onError Error:", error);
      kony.sdk.verifyAndCallClosure(onError, error);
      kony.sdk.logsdk.perf("Executing Finished onErrorCallback");
    }

    function onCloseCallback(result) {
      kony.sdk.logsdk.perf("Executing onCloseCallback");
      kony.sdk.verifyAndCallClosure(onClose, result);
      kony.sdk.logsdk.perf("Executing Finished onCloseCallback");
    }
    kony.sdk.websocket.util.setKonyWebsocketCallbacks({
      "onMessage": onMessageCallback,
      "onError": onErrorCallback,
      "onClose": onCloseCallback
    });
  };
  kony.sdk.websocket.publishServerEvents = function(events, onPublish, publishOptions) {
    var LOG_PREFIX = "kony.sdk.webSocket.publishServerEvents";
    kony.sdk.logsdk.trace(" Entering " + LOG_PREFIX);

    function onPublishCallback(result) {
      kony.sdk.logsdk.perf("Executing onPublishCallback");
      kony.sdk.verifyAndCallClosure(onPublish, result);
      kony.sdk.logsdk.perf("Executing Finished onPublishCallback");
    }
    kony.sdk.websocket.util.setKonyWebsocketCallback({
      "onPublish": onPublishCallback
    });
    kony.sdk.websocket.util.sendWebsocketMessage(events);
  };
  kony.sdk.websocket.subscribeServerEvents = function(url, events, onSubscribe, subscribeOptions) {
    var LOG_PREFIX = "kony.sdk.webSocket.subscribeServerEvents";
    kony.sdk.logsdk.trace(" Entering " + LOG_PREFIX);

    function onSubscribeCallback(result) {
      kony.sdk.logsdk.perf("Executing onSubscribeCallback");
      kony.sdk.verifyAndCallClosure(onSubscribe, result);
      kony.sdk.logsdk.perf("Executing Finished onSubscribeCallback");
    }
    kony.sdk.websocket.util.setKonyWebsocketCallbacks({
      "onSubscribe": onSubscribeCallback
    });
    if (kony.sdk.websocket && !kony.sdk.websocket.isWebSocketAvailable()) {
      kony.sdk.logsdk.info(LOG_PREFIX + kony.sdk.websocket.constants.SERVER_EVENTS_INITIALISING_MESSAGE);
      kony.sdk.websocket.util.openWebSocketHandler(url, events);
    } else {
      kony.sdk.websocket.util.sendWebsocketMessage(events);
    }
  };
  kony.sdk.websocket.unSubscribeServerEvents = function(events, onUnsubscribe, unSubscribeOptions) {
    var LOG_PREFIX = "kony.sdk.webSocket.unSubscribeServerEvents";
    kony.sdk.logsdk.trace(" Entering " + LOG_PREFIX);
    if (unSubscribeOptions && unSubscribeOptions[kony.sdk.websocket.constants.UNSUBSCRIBE_OPTION_CLOSE_CONNECTION] && unSubscribeOptions[kony.sdk.websocket.constants.UNSUBSCRIBE_OPTION_CLOSE_CONNECTION] === kony.sdk.websocket.constants.BOOLEAN_TRUE) {
      kony.sdk.websocket.util.closeWebSocket();
      return;
    }

    function onUnsubscribeCallback(result) {
      kony.sdk.logsdk.perf("Executing unSubscribeServerEvents");
      kony.sdk.verifyAndCallClosure(onUnsubscribe, result);
      kony.sdk.logsdk.perf("Executing Finished unSubscribeServerEvents");
    }
    kony.sdk.websocket.util.setKonyWebsocketCallbacks({
      "onUnsubscribe": onUnsubscribeCallback
    });
    if (!kony.sdk.util.isNullOrUndefinedOrEmptyObject(events)) {
      kony.sdk.websocket.util.sendWebsocketMessage(events);
    } else {
      kony.sdk.websocket.util.raiseError(LOG_PREFIX + "events is null or undefined");
      return;
    }
  };
  kony.sdk.websocket.isWebSocketAvailable = function() {
    var LOG_PREFIX = "kony.sdk.webSocket.isWebSocketAvailable";
    kony.sdk.logsdk.trace(" Entering " + LOG_PREFIX);
    return kony.sdk.websocket.util.isInternalWebSocketAvailable();
  };
}
/**
 * Created by Inderpreet Kaur on 3/1/2020.
 * Copyright  2020 Kony. All rights reserved.
 */
function initializeWebSocketManager() {
  if (typeof(kony) === "undefined") {
    kony = {};
  }
  if (typeof(kony.sdk) === "undefined") {
    kony.sdk = {};
  }
  kony.sdk.websocket = kony.sdk.websocket || {};
  kony.sdk.websocket.util = kony.sdk.websocket.util || {};
  kony.sdk.websocket.onMessage = null;
  kony.sdk.websocket.onError = null;
  kony.sdk.websocket.onClose = null;
  kony.sdk.websocket.onSubscribe = null;
  kony.sdk.websocket.onPublish = null;
  kony.sdk.websocket.onUnsubscribe = null;
  var konyWebSocket = null;
  /**
   *    Defines callback for onMessage, onError and onClose for websockets.
   */
  kony.sdk.websocket.util.setKonyWebsocketCallbacks = function(callback) {
    kony.sdk.logsdk.perf("Executing kony.sdk.websocket.util.setKonyWebsocketCallback");
    for (var key in callback) {
      switch (key) {
        case kony.sdk.websocket.constants.WEBSOCKET_TYPE_ONMESSAGE:
          kony.sdk.websocket.onMessage = callback[key];
          break;
        case kony.sdk.websocket.constants.WEBSOCKET_TYPE_ONERROR:
          kony.sdk.websocket.onError = callback[key];
          break;
        case kony.sdk.websocket.constants.WEBSOCKET_TYPE_ONCLOSE:
          kony.sdk.websocket.onClose = callback[key];
          break;
        case kony.sdk.websocket.constants.WEBSOCKET_TYPE_ONSUBSCRIBE:
          kony.sdk.websocket.onSubscribe = callback[key];
          break;
        case kony.sdk.websocket.constants.WEBSOCKET_TYPE_ONPUBLISH:
          kony.sdk.websocket.onPublish = callback[key];
          break;
        case kony.sdk.websocket.constants.WEBSOCKET_TYPE_ONUNSUBSCRIBE:
          kony.sdk.websocket.onUnsubscribe = callback[key];
          break;
        default:
          kony.sdk.logsdk.warn("Invalid key passed while setting websocket callback : ", key);
      }
    }
    kony.sdk.logsdk.perf("Executing Finished kony.sdk.websocket.util.setKonyWebsocketCallback");
  };
  /**
   *    Opens and handles websocket after the connection is established.
   */
  kony.sdk.websocket.util.openWebSocketHandler = function(url, events) {
    kony.sdk.logsdk.perf("Executing kony.sdk.websocket.util.openWebSocketHandler");
    if ((!kony.sdk.isNullOrUndefined(konyWebSocket) && (konyWebSocket.readyState === WebSocket.OPEN))) {
      kony.sdk.logsdk.info("Websocket is already initialized.");
      return;
    }
    if (window.WebSocket) {
      kony.sdk.logsdk.info("Websocket is supported by this browser!");
      try {
        konyWebSocket = new WebSocket(url);
      } catch (error) {
        kony.sdk.logsdk.error("openWebSocketHandler:: Error while opening websocket, Error : ", error);
        kony.sdk.websocket.util.parseMessageForTypeAndCallCommonCallback(kony.sdk.websocket.constants.WEBSOCKET_TYPE_ONERROR, "Error while opening websocket, Error : " + error);
        return;
      }
      konyWebSocket.onopen = function() {
        kony.sdk.logsdk.perf("Executing Websocket onopen eventHandler.");
        kony.sdk.logsdk.info("WebSocket is connected.");
        kony.sdk.websocket.util.parseMessageForTypeAndCallCommonCallback(kony.sdk.websocket.constants.WEBSOCKET_TYPE_ONOPEN, "WebSocket connection established");
        kony.sdk.websocket.util.sendWebsocketMessage(events);
        kony.sdk.logsdk.perf("Executing Finished Websocket onopen eventHandler.");
      };
      konyWebSocket.onmessage = function(event) {
        kony.sdk.logsdk.perf("Executing Websocket onmessage eventHandler.");
        var message = event.data;
        kony.sdk.logsdk.info("Event Message Recieved.");
        kony.sdk.websocket.util.parseServerResponseAndCallLocalCallback(message);
        kony.sdk.logsdk.perf("Executing Finished Websocket onmessage eventHandler.");
      };
      konyWebSocket.onerror = function(error) {
        kony.sdk.logsdk.perf("Executing Websocket onerror eventHandler.");
        kony.sdk.logsdk.error("openWebSocketHandler:: Websocket Failed With Error :" + error);
        konyWebSocket = null;
        kony.sdk.websocket.util.parseMessageForTypeAndCallCommonCallback(kony.sdk.websocket.constants.WEBSOCKET_TYPE_ONERROR, "Websocket Failed With Error : " + error);
        kony.sdk.logsdk.perf("Executing Finished Websocket onerror eventHandler.");
      };
      konyWebSocket.onclose = function() {
        kony.sdk.logsdk.perf("Executing Websocket onclose eventHandler.");
        konyWebSocket = null;
        kony.sdk.logsdk.info("WebSocket is closed.");
        kony.sdk.websocket.util.parseMessageForTypeAndCallCommonCallback(kony.sdk.websocket.constants.WEBSOCKET_TYPE_ONCLOSE, "All Topics Unsubscribed and WebSocket connection closed.");
        kony.sdk.logsdk.perf("Executing Finished Websocket onclose eventHandler.");
      };
    } else {
      kony.sdk.logsdk.error("openWebSocketHandler:: WebSocket is not supported by this browser.");
      kony.sdk.websocket.util.parseMessageForTypeAndCallCommonCallback(kony.sdk.websocket.constants.WEBSOCKET_TYPE_ONERROR, "WebSocket is not supported by this browser");
    }
    kony.sdk.logsdk.perf("Executing Finished kony.sdk.websocket.util.openWebSocketHandler");
  };
  /**
   *    Sending the acknowledgement after getting the response from server.
   *    @param eventID event id from server side.
   */
  kony.sdk.websocket.util.sendAcknowledgementToServer = function(eventID) {
    var ackPayLoad = {};
    var ack = {};
    ack[kony.sdk.websocket.constants.WEBSOCKET_RESPONSE_EVENTS_ID] = eventID;
    ackPayLoad[kony.sdk.websocket.constants.WEBSOCKET_RESPONSE_ACK] = ack;
    var ackString = JSON.stringify(ackPayLoad);
    kony.sdk.websocket.util.sendWebsocketMessage(ackString);
  };
  /**
   *    Sends message through the WebSocket connection using WebSocket instance.
   */
  kony.sdk.websocket.util.sendWebsocketMessage = function(events) {
    kony.sdk.logsdk.perf("Executing kony.sdk.websocket.util.sendWebsocketMessage");
    if (kony.sdk.isNullOrUndefined(konyWebSocket)) {
      kony.sdk.logsdk.error("sendWebsocketMessage:: Websocket is not initialized.");
      kony.sdk.websocket.util.parseMessageForTypeAndCallCommonCallback(kony.sdk.websocket.constants.WEBSOCKET_TYPE_ONERROR, "Websocket is not initialized.");
      return;
    }
    kony.sdk.logsdk.info("Websocket ready State is " + konyWebSocket.readyState);
    if (konyWebSocket.readyState === WebSocket.OPEN) {
      kony.sdk.logsdk.info("Sending events using webSocket.");
      konyWebSocket.send(events);
    } else {
      kony.sdk.logsdk.error("sendWebsocketMessage:: Websocket is not open.");
      kony.sdk.websocket.util.parseMessageForTypeAndCallCommonCallback(kony.sdk.websocket.constants.WEBSOCKET_TYPE_ONERROR, "Websocket is not open.");
      return;
    }
    kony.sdk.logsdk.perf("Executing Finished kony.sdk.websocket.util.sendWebsocketMessage");
  };
  /**
   *    Closes the WebSocket connection, if any. If the connection is already closed, this api does nothing.
   */
  kony.sdk.websocket.util.closeWebSocket = function() {
    kony.sdk.logsdk.perf("Executing Finished kony.sdk.websocket.util.ned) {closeWebSocket");
    if (kony.sdk.isNullOrUndefined(konyWebSocket)) {
      kony.sdk.logsdk.error("closeWebSocket:: Websocket is not initialized.");
      kony.sdk.websocket.util.parseMessageForTypeAndCallCommonCallback(kony.sdk.websocket.constants.WEBSOCKET_TYPE_ONERROR, "Websocket is not initialized.");
      return;
    } else {
      kony.sdk.logsdk.info("Websocket ready State is " + konyWebSocket.readyState);
      if (konyWebSocket.readyState === WebSocket.OPEN) {
        kony.sdk.logsdk.info("Closing the Websocket.");
        konyWebSocket.close();
      } else {
        kony.sdk.logsdk.error("closeWebSocket:: Websocket is not open.");
        kony.sdk.websocket.util.parseMessageForTypeAndCallCommonCallback(kony.sdk.websocket.constants.WEBSOCKET_TYPE_ONERROR, "Websocket is not open.");
      }
    }
    kony.sdk.logsdk.perf("Executing Finished kony.sdk.websocket.util.closeWebSocket");
  };
  /**
   *  Checks and returns if websocket instance is available.
   */
  kony.sdk.websocket.util.isInternalWebSocketAvailable = function() {
    return !kony.sdk.isNullOrUndefined(konyWebSocket);
  };
}
/**
 * Created by Inderpreet Kaur on 3/1/2020.
 * Copyright  2020 Kony. All rights reserved.
 */
function initializeWebSocketResponseHandler() {
  if (typeof(kony) === "undefined") {
    kony = {};
  }
  if (typeof(kony.sdk) === "undefined") {
    kony.sdk = {};
  }
  kony.sdk.websocket = kony.sdk.websocket || {};
  kony.sdk.websocket.util = kony.sdk.websocket.util || {};
  /**
   * Parse the response message from server.
   */
  kony.sdk.websocket.util.parseServerResponseAndCallLocalCallback = function(response) {
    kony.sdk.logsdk.perf("Executing kony.sdk.websocket.util.parseServerResponseAndCallLocalCallback");
    const msg = "Error while parsing response from server.";
    try {
      var parsedResponse = JSON.parse(response);
    } catch (error) {
      kony.sdk.logsdk.error("parseAndGetLocalResponse:: " + msg);
      kony.sdk.websocket.util.raiseError(msg + ": " + error);
      return;
    }
    if (kony.sdk.util.isNullOrUndefinedOrEmptyObject(parsedResponse)) {
      kony.sdk.logsdk.error("parseAndGetLocalResponse:: " + msg);
      kony.sdk.websocket.util.raiseError(msg);
      return;
    }
    kony.sdk.websocket.util.handleServerResponseAndCallbackResponse(parsedResponse);
    kony.sdk.logsdk.perf("Executing Finished kony.sdk.websocket.util.parseAndGetLocalResponse");
  };
  /**
   * Method gets response and invokes callback.
   */
  kony.sdk.websocket.util.parseMessageForTypeAndCallCommonCallback = function(type, response) {
    kony.sdk.logsdk.perf("Executing kony.sdk.websocket.util.parseMessageForTypeAndCallCommonCallback");
    const finalMessage = kony.sdk.websocket.util.getResponseMessageForType(type, response);
    if (kony.sdk.util.isNullOrUndefinedOrEmptyObject(finalMessage)) {
      const msg = "Error in creating response for parseMessageForTypeAndCallCommonCallback";
      kony.sdk.logsdk.error(msg);
      kony.sdk.websocket.util.raiseError(msg);
      return;
    }
    if (type === kony.sdk.websocket.constants.WEBSOCKET_TYPE_ONOPEN) {
      kony.sdk.verifyAndCallClosure(kony.sdk.websocket.onMessage, finalMessage);
    }
    if (type === kony.sdk.websocket.constants.WEBSOCKET_TYPE_ONCLOSE) {
      kony.sdk.verifyAndCallClosure(kony.sdk.websocket.onClose, finalMessage);
    }
    if (type === kony.sdk.websocket.constants.WEBSOCKET_TYPE_ONERROR) {
      kony.sdk.verifyAndCallClosure(kony.sdk.websocket.onError, finalMessage);
    }
  };
  /**
   * Invoke respective callback based on response received from server.
   */
  kony.sdk.websocket.util.handleServerResponseAndCallbackResponse = function(response) {
    kony.sdk.logsdk.perf("Executing kony.sdk.websocket.util.handleServerResponseAndCallbackResponse");
    const code = response[kony.sdk.websocket.constants.WEBSOCKET_RESPONSE_CODE];
    if (code === kony.sdk.websocket.util.ServerCodeType.ON_MESSAGE) {
      kony.sdk.logsdk.info("OnMessage type response received.");
      kony.sdk.logsdk.info("Sending acknowledgment to the server.");
      kony.sdk.websocket.util.sendAcknowledgementToServer(response[kony.sdk.websocket.constants.WEBSOCKET_RESPONSE_EVENTS_ID]);
      const finalMessage = kony.sdk.websocket.util.getResponseMessageForOnMessage(response);
      kony.sdk.verifyAndCallClosure(kony.sdk.websocket.onMessage, finalMessage);
    } else if (code >= kony.sdk.websocket.util.ServerCodeType.SERVER_ON_ERROR_INVALID_USER && code <= kony.sdk.websocket.util.ServerCodeType.SERVER_ON_ERROR_ERROR_REQUEST_PAYLOAD) {
      kony.sdk.logsdk.info("Response message type received: ON_ERROR");
      kony.sdk.logsdk.debug("Error: " + response[kony.sdk.websocket.constants.WEBSOCKET_RESPONSE_MESSAGE]);
      var errorMessage = "Please Re-Subscribe/Unsubscribe.";
      if (code === kony.sdk.websocket.util.ServerCodeType.SERVER_ON_ERROR_INVALID_USER) {
        errorMessage = "Authentication failed, " + errorMessage;
      }
      kony.sdk.websocket.util.raiseError(errorMessage);
    } else {
      const message = response[kony.sdk.websocket.constants.WEBSOCKET_RESPONSE_MESSAGE];
      const successTopics = response[kony.sdk.websocket.constants.WEBSOCKET_RESPONSE_SUCCESSFULL_EVENTS];
      const failedTopics = response[kony.sdk.websocket.constants.WEBSOCKET_RESPONSE_FAILED_EVENTS];
      const finalMessage = kony.sdk.websocket.util.getResponseMessageForCode(code, message, successTopics, failedTopics);
      if (kony.sdk.util.isNullOrUndefinedOrEmptyObject(finalMessage)) {
        const msg = "Error in creating response for handleServerResponseAndCallbackResponse";
        kony.sdk.logsdk.error(msg);
        kony.sdk.websocket.util.raiseError(msg);
        return;
      }
      switch (code) {
        case kony.sdk.websocket.util.ServerCodeType.SUBSCRIBE_SUCCESS:
        case kony.sdk.websocket.util.ServerCodeType.SUBSCRIBE_ERROR:
        case kony.sdk.websocket.util.ServerCodeType.SUBSCRIBE_PARTIAL_SUCCESS:
          kony.sdk.logsdk.info("Response message type received: SUBSCRIBE");
          kony.sdk.verifyAndCallClosure(kony.sdk.websocket.onSubscribe, finalMessage);
          break;
        case kony.sdk.websocket.util.ServerCodeType.UNSUBSCRIBE_SUCCESS:
        case kony.sdk.websocket.util.ServerCodeType.UNSUBSCRIBE_ERROR:
        case kony.sdk.websocket.util.ServerCodeType.UNSUBSCRIBE_PARTIAL_SUCCESS:
          kony.sdk.logsdk.info("Response message type received: UNSUBSCRIBE");
          kony.sdk.verifyAndCallClosure(kony.sdk.websocket.onUnsubscribe, finalMessage);
          break;
        case kony.sdk.websocket.util.ServerCodeType.PUBLISH_SUCCESS:
        case kony.sdk.websocket.util.ServerCodeType.PUBLISH_ERROR:
        case kony.sdk.websocket.util.ServerCodeType.PUBLISH_PARTIAL_SUCCESS:
          kony.sdk.logsdk.info("Response message type received: PUBLISH");
          kony.sdk.verifyAndCallClosure(kony.sdk.websocket.onPublish, finalMessage);
          break;
        default:
          kony.sdk.logsdk.error("Invalid code passed in response, message: ", finalMessage);
          kony.sdk.websocket.util.raiseError("Invalid response received, response : " + finalMessage);
          break;
      }
    }
  };
  kony.sdk.websocket.util.raiseError = function(message) {
    kony.sdk.logsdk.perf("Executing kony.sdk.websocket.util.raiseError");
    const finalErrorMessage = kony.sdk.websocket.util.getResponseMessageForType(kony.sdk.websocket.constants.WEBSOCKET_TYPE_ONERROR, message);
    kony.sdk.verifyAndCallClosure(kony.sdk.websocket.onError, finalErrorMessage);
  };
}
/**
 * Created by Inderpreet Kaur on 3/1/2020.
 * Copyright  2020 Kony. All rights reserved.
 */
function initializeWebSocketResponseMessage() {
  if (typeof(kony) === "undefined") {
    kony = {};
  }
  if (typeof(kony.sdk) === "undefined") {
    kony.sdk = {};
  }
  kony.sdk.websocket = kony.sdk.websocket || {};
  kony.sdk.websocket.util = kony.sdk.websocket.util || {};
  const ServerCodeType = {
    SUBSCRIBE_SUCCESS: 620001,
    SUBSCRIBE_ERROR: 620002,
    SUBSCRIBE_PARTIAL_SUCCESS: 620003,
    PUBLISH_SUCCESS: 620004,
    PUBLISH_ERROR: 620005,
    PUBLISH_PARTIAL_SUCCESS: 620006,
    UNSUBSCRIBE_SUCCESS: 620007,
    UNSUBSCRIBE_ERROR: 620008,
    UNSUBSCRIBE_PARTIAL_SUCCESS: 620009,
    ON_MESSAGE: 620010,
    SERVER_ON_ERROR_INVALID_USER: 620011,
    SERVER_ON_ERROR_MISSING_MANDATORY_PARAM: 620012,
    SERVER_ON_ERROR_UPDATING_WEBSOCKET_SESSION: 620013,
    SERVER_ON_ERROR_ERROR_REQUEST_PAYLOAD: 620014,
  };
  Object.freeze(ServerCodeType);
  kony.sdk.websocket.util.ServerCodeType = ServerCodeType;
  const ClientCodeType = {
    SUBS_SUCCESS: 6201,
    SUBS_ERROR: 6202,
    SUBS_PARTIAL_SUCCESS: 6203,
    UNSUBS_SUCCESS: 6207,
    UNSUBS_ERROR: 6208,
    UNSUBS_PARTIAL_SUCCESS: 6209,
    PUB_SUCCESS: 6204,
    PUB_ERROR: 6205,
    PUB_PARTIAL_SUCCESS: 6206,
    ON_MESSAGE: 6210,
    ON_OPEN: 7200,
    ON_ERROR: 7201,
    ON_CLOSE: 7202
  };
  Object.freeze(ClientCodeType);
  kony.sdk.websocket.util.ClientCodeType = ClientCodeType;
  /**
   Creating client and server code dictionary. Dictionary contains both  server code enum type or code type
   as string for key with respective client codes as pair.
   **/
  var responseCodeLookUp = {};
  responseCodeLookUp[ServerCodeType.SUBSCRIBE_SUCCESS] = ClientCodeType.SUBS_SUCCESS;
  responseCodeLookUp[ServerCodeType.SUBSCRIBE_PARTIAL_SUCCESS] = ClientCodeType.SUBS_PARTIAL_SUCCESS;
  responseCodeLookUp[ServerCodeType.SUBSCRIBE_ERROR] = ClientCodeType.SUBS_ERROR;
  responseCodeLookUp[ServerCodeType.UNSUBSCRIBE_SUCCESS] = ClientCodeType.UNSUBS_SUCCESS;
  responseCodeLookUp[ServerCodeType.UNSUBSCRIBE_PARTIAL_SUCCESS] = ClientCodeType.UNSUBS_PARTIAL_SUCCESS;
  responseCodeLookUp[ServerCodeType.UNSUBSCRIBE_ERROR] = ClientCodeType.UNSUBS_ERROR;
  responseCodeLookUp[ServerCodeType.PUBLISH_SUCCESS] = ClientCodeType.PUB_SUCCESS;
  responseCodeLookUp[ServerCodeType.PUBLISH_PARTIAL_SUCCESS] = ClientCodeType.PUB_PARTIAL_SUCCESS;
  responseCodeLookUp[ServerCodeType.PUBLISH_ERROR] = ClientCodeType.PUB_ERROR;
  responseCodeLookUp[kony.sdk.websocket.constants.WEBSOCKET_TYPE_ONOPEN] = ClientCodeType.ON_OPEN;
  responseCodeLookUp[kony.sdk.websocket.constants.WEBSOCKET_TYPE_ONMESSAGE] = ClientCodeType.ON_MESSAGE;
  responseCodeLookUp[kony.sdk.websocket.constants.WEBSOCKET_TYPE_ONCLOSE] = ClientCodeType.ON_CLOSE;
  responseCodeLookUp[kony.sdk.websocket.constants.WEBSOCKET_TYPE_ONERROR] = ClientCodeType.ON_ERROR;
  kony.sdk.websocket.util.setKeyAndValueForFinalMessage = function(finalMessageJSON, message, successTopics, failedTopics) {
    kony.sdk.logsdk.perf("Executing kony.sdk.websocket.util.setKeyAndValueForFinalmessage");
    if (!kony.sdk.util.isNullOrUndefinedOrEmptyObject(message)) {
      finalMessageJSON[kony.sdk.websocket.constants.WEBSOCKET_RESPONSE_MESSAGE] = message;
    }
    if (!kony.sdk.util.isNullOrUndefinedOrEmptyObject(successTopics)) {
      finalMessageJSON[kony.sdk.websocket.constants.WEBSOCKET_RESPONSE_SUCCESSFULL_EVENTS] = successTopics;
    }
    if (!kony.sdk.util.isNullOrUndefinedOrEmptyObject(failedTopics)) {
      finalMessageJSON[kony.sdk.websocket.constants.WEBSOCKET_RESPONSE_FAILED_EVENTS] = failedTopics;
    }
  };
  kony.sdk.websocket.util.getResponseMessageForOnMessage = function(message) {
    var finalMessageJSON = {};
    var clientCode = responseCodeLookUp[kony.sdk.websocket.constants.WEBSOCKET_TYPE_ONMESSAGE];
    finalMessageJSON[kony.sdk.websocket.constants.WEBSOCKET_RESPONSE_CODE] = clientCode;
    finalMessageJSON[kony.sdk.websocket.constants.WEBSOCKET_RESPONSE_DATA] = message[kony.sdk.websocket.constants.WEBSOCKET_RESPONSE_DATA];
    finalMessageJSON[kony.sdk.websocket.constants.WEBSOCKET_RESPONSE_TOPIC] = message[kony.sdk.websocket.constants.WEBSOCKET_RESPONSE_TOPIC];
    var responseString = JSON.stringify(finalMessageJSON);
    return responseString;
  };
  /**
   * Create response message string depending on type of message.
   */
  kony.sdk.websocket.util.getResponseMessageForType = function(type, message) {
    kony.sdk.logsdk.perf("Executing kony.sdk.websocket.util.getResponseMessageForType");
    const finalMessageJSON = {};
    const clientCode = responseCodeLookUp[type];
    if (clientCode <= 0) {
      kony.sdk.logsdk.error("Invalid Code found in response for getResponseMessageForType");
      return null;
    }
    finalMessageJSON[kony.sdk.websocket.constants.WEBSOCKET_RESPONSE_CODE] = clientCode;
    if (type === kony.sdk.websocket.constants.WEBSOCKET_TYPE_ONCLOSE || type === kony.sdk.websocket.constants.WEBSOCKET_TYPE_ONOPEN) {
      kony.sdk.logsdk.info("Message type received : " + type);
      kony.sdk.websocket.util.setKeyAndValueForFinalMessage(finalMessageJSON, message, null, null);
    } else if (type === kony.sdk.websocket.constants.WEBSOCKET_TYPE_ONERROR) {
      kony.sdk.logsdk.info("Message type received : " + type);
      message = "Error Occurred in Server events, Error :" + message;
      kony.sdk.websocket.util.setKeyAndValueForFinalMessage(finalMessageJSON, message, null, null);
    } else {
      kony.sdk.logsdk.debug("Invalid Callback type found");
      return null;
    }
    var responseString = JSON.stringify(finalMessageJSON)
    return responseString;
  };
  /**
   * Create response message string depending on the code.
   */
  kony.sdk.websocket.util.getResponseMessageForCode = function(code, message, successTopics, failedTopics) {
    kony.sdk.logsdk.perf("Executing kony.sdk.websocket.util.getResponseMessageForCode");
    const finalMessageJSON = {};
    const clientCode = responseCodeLookUp[code];
    if (clientCode <= 0) {
      kony.sdk.logsdk.error("Invalid Code found in response for getResponseMessageForCode");
      return null;
    }
    finalMessageJSON[kony.sdk.websocket.constants.WEBSOCKET_RESPONSE_CODE] = clientCode;
    switch (code) {
      case ServerCodeType.SUBSCRIBE_SUCCESS:
      case ServerCodeType.PUBLISH_SUCCESS:
      case ServerCodeType.UNSUBSCRIBE_SUCCESS:
        kony.sdk.logsdk.info("Message type received for : " + kony.sdk.util.getKeyByValue(ClientCodeType, clientCode));
        kony.sdk.websocket.util.setKeyAndValueForFinalMessage(finalMessageJSON, message, successTopics, null);
        break;
      case ServerCodeType.SUBSCRIBE_ERROR:
      case ServerCodeType.PUBLISH_ERROR:
      case ServerCodeType.UNSUBSCRIBE_ERROR:
        kony.sdk.logsdk.info("Message type received for : " + kony.sdk.util.getKeyByValue(ClientCodeType, clientCode));
        kony.sdk.websocket.util.setKeyAndValueForFinalMessage(finalMessageJSON, message, null, failedTopics);
        break;
      case ServerCodeType.SUBSCRIBE_PARTIAL_SUCCESS:
      case ServerCodeType.PUBLISH_PARTIAL_SUCCESS:
      case ServerCodeType.UNSUBSCRIBE_PARTIAL_SUCCESS:
        kony.sdk.logsdk.info("Message type received for partial success : " + kony.sdk.util.getKeyByValue(ClientCodeType, clientCode));
        kony.sdk.websocket.util.setKeyAndValueForFinalMessage(finalMessageJSON, message, successTopics, failedTopics);
        break;
      default:
        kony.sdk.logsdk.error("Invalid code passed in response, message: ", message);
        return null;
    }
    try {
      var responseString = JSON.stringify(finalMessageJSON)
    } catch (error) {
      kony.sdk.logsdk.error("Error in creating response message, error: " + error);
      return null;
    }
    return responseString;
  };
}
/**
 * Created by Inderpreet Kaur on 3/1/2020.
 * Copyright  2020 Kony. All rights reserved.
 */
if (typeof(kony) === "undefined") {
  kony = {};
}
if (typeof(kony.sdk) === "undefined") {
  kony.sdk = {};
}
// kony.serverEvents is a flag to know whether KonyServerEvents.js file is loaded or not.
kony.serverEvents = true;

function initializeServerEvents() {
  var onErrorCallback = null;
  var eventCallbackFlag = false;
  var failureCallbackFlag = false;
  var TAG = "KonyServerEvents :: ";
  const ErrorCodes = {
    ON_ERROR: 7201,
    ON_UNSUBSCRIBE_ERROR: 6208,
    ON_SUBS_ERROR: 6202
  };
  Object.freeze(ErrorCodes);
  var callbackErrorInvoker = function(type, message, callback) {
    var finalMessage = {};
    switch (type) {
      case kony.sdk.websocket.constants.WEBSOCKET_TYPE_ONERROR:
        finalMessage.code = ErrorCodes.ON_ERROR;
        break;
      case kony.sdk.websocket.constants.WEBSOCKET_TYPE_ONUNSUBSCRIBE_ERROR:
        finalMessage.code = ErrorCodes.ON_UNSUBSCRIBE_ERROR;
        break;
      case kony.sdk.websocket.constants.WEBSOCKET_TYPE_ONSUBSCRIBE_ERROR:
        finalMessage.code = ErrorCodes.ON_SUBS_ERROR;
        break;
      default:
        finalMessage.code = ErrorCodes.ON_ERROR;
        break;
    }
    finalMessage.message = message;
    if ((!callback || (finalMessage.code === ErrorCodes.ON_ERROR)) && onErrorCallback) {
      finalMessage.code = ErrorCodes.ON_ERROR;
      kony.sdk.verifyAndCallClosure(onErrorCallback, JSON.stringify(finalMessage));
    } else if (callback) {
      kony.sdk.verifyAndCallClosure(callback, JSON.stringify(finalMessage));
    }
  };
  /**
   * Create events string payload.
   * @param events,  the value to be used for events object
   * @param mode, value, either it may be Public or Private
   * @param type, it is the type of events- subscribe or unsubscribe
   * @returns {string}
   */
  var createEventsPayloadString = function(events, mode, type) {
    var payload = {};
    var finalPayload = {};
    var scope = {};
    if (kony.sdk.util.isValidString(events)) {
      var eventsArray = [];
      eventsArray.push(events);
      scope[mode] = eventsArray
    } else if (kony.sdk.isArray(events) && events.length > 0) {
      for (var e in events) {
        if (!kony.sdk.util.isValidString(events[e])) {
          kony.sdk.logsdk.error(TAG + "createEventsPayloadString:: " + kony.sdk.websocket.constants.INVALID_EVENT_STRING_MESSAGE);
          return;
        }
      }
      scope[mode] = events;
    } else {
      kony.sdk.logsdk.error(TAG + "createEventsPayloadString:: " + kony.sdk.websocket.constants.INVALID_EVENT_STRING_MESSAGE);
      return;
    }
    payload[kony.sdk.websocket.constants.X_KONY_AUTHORIZATION] = konyRef.currentClaimToken;
    payload[kony.sdk.websocket.constants.X_KONY_CLIENT_UUID] = konyRef.clientUUID;
    payload[kony.sdk.websocket.constants.WEBSOCKET_TOPICS_EVENTS] = scope;
    if (type === kony.sdk.websocket.constants.WEBSOCKET_SUBSCRIBE_EVENTS) {
      finalPayload[kony.sdk.websocket.constants.WEBSOCKET_SUBSCRIBE_EVENTS] = payload;
    } else {
      finalPayload[kony.sdk.websocket.constants.WEBSOCKET_UNSUBSCRIBE_EVENTS] = payload
    }
    var eventsString = JSON.stringify(finalPayload);
    return eventsString;
  };
  /**
   * Segregating the mode from options.
   * @param options, the value to be used for events object
   * @param type, it is the type of events- subscribe or unsubscribe
   * @returns {string}
   */
  var segregateEventModes = function(options, type) {
    var mode = null;
    if (type === kony.sdk.websocket.constants.WEBSOCKET_SUBSCRIBE_EVENTS) {
      mode = options[kony.sdk.websocket.constants.WEBSOCKET_SUBSCRIBE_MODE];
    } else {
      mode = options[kony.sdk.websocket.constants.WEBSOCKET_UNSUBSCRIBE_MODE];
    }
    if (kony.sdk.isNullOrUndefined(mode)) {
      return kony.sdk.websocket.constants.WEBSOCKET_MODE_PRIVATE;
    } else if (mode.toLowerCase() === kony.sdk.websocket.constants.WEBSOCKET_MODE_PRIVATE || mode.toLowerCase() === kony.sdk.websocket.constants.WEBSOCKET_MODE_PUBLIC) {
      return mode.toLowerCase();
    } else {
      kony.sdk.logsdk.error(TAG + "segregatingEventModes:: " + kony.sdk.websocket.constants.INVALID_MODE_PROVIDED_MESSAGE);
      return;
    }
  };
  /**
   * Method isServerEventsCallbackAssigned, checking the mandatory callbacks setup.
   * @returns {boolean}
   */
  var isServerEventsCallbackAssigned = function() {
    if (eventCallbackFlag === false || failureCallbackFlag === false) {
      return false;
    } else {
      return true;
    }
  };
  /**
   * isOptionObjectValid, method to validate obj to be function.
   * @param obj
   * @returns {boolean}
   */
  var isOptionObjectValid = function(obj) {
    if (kony.sdk.isNullOrUndefined(obj) || !typeof obj === 'function') {
      return false;
    } else {
      return true;
    }
  };
  /**
   * isOncloseConnectionValid, method to validate onCloseConnection key
   * @param obj
   * @returns {boolean}
   */
  var isOncloseConnectionValid = function(obj) {
    if (!(obj === true || obj === false)) {
      return false;
    }
    return true;
  };
  /**
   * Method setServerEventsCallbacks, setting the common callbacks
   *
   * @param options, contains callback functions
   */
  kony.sdk.prototype.setServerEventsCallbacks = function(options) {
    if (!kony.sdk.util.isNullOrUndefinedOrEmptyObject(options)) {
      if (!isOptionObjectValid(options.onFailureCallback)) {
        kony.sdk.logsdk.error(TAG + "setServerEventsCallbacks:: onFailureCallback callback is null or undefined");
        return;
      } else {
        failureCallbackFlag = true;
        onErrorCallback = options.onFailureCallback;
      }
      if (!isOptionObjectValid(options.onEventCallback)) {
        kony.sdk.logsdk.error(TAG + "subscribeServerEvents:: onEventCallback callback is null or undefined");
        callbackErrorInvoker(kony.sdk.websocket.constants.WEBSOCKET_TYPE_ONERROR, "onEventCallback callback is null or undefined.", onErrorCallback);
        return;
      } else {
        eventCallbackFlag = true;
      }
      if (!options.onCloseCallback) {
        options.onCloseCallback = null;
      }
      kony.sdk.websocket.setServerEventsCallbacks(options.onEventCallback, options.onFailureCallback, options.onCloseCallback);
    } else {
      kony.sdk.logsdk.error(TAG + "setServerEventsCallbacks:: options are null or undefined");
      return;
    }
  };
  /**
   * Subscribe to server events.
   *
   * example : ["transaction/deposit",
   *            "transaction/withdraw"]
   * @param events            events string to be sent to the server
   * @param subscribeOptions additional options for subscribing
   */
  kony.sdk.prototype.subscribeServerEvents = function(events, subscribeOptions) {
    if (!isServerEventsCallbackAssigned()) {
      kony.sdk.logsdk.error(TAG + "subscribeServerEvents:: " + kony.sdk.websocket.constants.SERVER_EVENTS_CALLBACKS_ERROR_MESSAGE);
      return;
    }
    if (kony.sdk.util.isNullOrUndefinedOrEmptyObject(subscribeOptions)) {
      subscribeOptions = {};
    }
    if (!kony.sdk.isNetworkAvailable()) {
      kony.sdk.logsdk.error(TAG + "subscribeServerEvents:: " + kony.sdk.websocket.constants.SERVER_EVENTS_NO_INTERNET_MESSAGE);
      callbackErrorInvoker(kony.sdk.websocket.constants.WEBSOCKET_TYPE_ONERROR, kony.sdk.websocket.constants.SERVER_EVENTS_NO_INTERNET_MESSAGE, onErrorCallback);
      return;
    }
    if (kony.sdk.util.isNullOrUndefinedOrEmptyObject(events)) {
      kony.sdk.logsdk.error(TAG + "subscribeServerEvents:: Events to be subscribed for are null or undefined or empty.");
      callbackErrorInvoker(kony.sdk.websocket.constants.WEBSOCKET_TYPE_ONERROR, "Events to be subscribed are null or undefined or empty.", onErrorCallback);
      return;
    }
    kony.sdk.claimsRefresh(function() {
      kony.sdk.logsdk.info(TAG + "subscribeServerEvents:: " + "Generating websocket url");
      var url = kony.sdk.websocket.generateServerEventsURL();
      if (kony.sdk.isNullOrUndefined(url)) {
        kony.sdk.websocket.util.raiseError(TAG + "subscribeServerEvents:: Error in generating websocket url.");
        return;
      }
      try {
        var mode = segregateEventModes(subscribeOptions, kony.sdk.websocket.constants.WEBSOCKET_SUBSCRIBE_EVENTS);
        if (kony.sdk.isNullOrUndefined(mode)) {
          kony.sdk.logsdk.error(TAG + "subscribeServerEvents:: Event mode passed is not valid.");
          callbackErrorInvoker(kony.sdk.websocket.constants.WEBSOCKET_TYPE_ONERROR, kony.sdk.websocket.constants.INVALID_MODE_PROVIDED_MESSAGE, onErrorCallback);
          return;
        }
        var eventsString = createEventsPayloadString(events, mode, kony.sdk.websocket.constants.WEBSOCKET_SUBSCRIBE_EVENTS);
        if (kony.sdk.isNullOrUndefined(eventsString)) {
          kony.sdk.logsdk.error(TAG + "subscribeServerEvents:: Event string passed is not valid.");
          callbackErrorInvoker(kony.sdk.websocket.constants.WEBSOCKET_TYPE_ONERROR, kony.sdk.websocket.constants.INVALID_EVENT_STRING_MESSAGE, onErrorCallback);
          return;
        }
      } catch (error) {
        kony.sdk.logsdk.error(TAG + "subscribeServerEvents:: Error : ", error);
        callbackErrorInvoker(kony.sdk.websocket.constants.WEBSOCKET_TYPE_ONERROR, error, onErrorCallback);
        return;
      }
      if (isOptionObjectValid(subscribeOptions.onSubscribeCallback)) {
        kony.sdk.websocket.subscribeServerEvents(url, eventsString, subscribeOptions.onSubscribeCallback, subscribeOptions);
      } else {
        kony.sdk.websocket.subscribeServerEvents(url, eventsString, null, subscribeOptions);
      }
    }, function(error) {
      kony.sdk.logsdk.error(TAG + "subscribeServerEvents::onFailure Error:", error);
      callbackErrorInvoker(kony.sdk.websocket.constants.WEBSOCKET_TYPE_ONERROR, error, onErrorCallback);
    });
  };
  /**
   * Unsubscribe from server events.
   *
   * example : ["transaction/deposit",
   *            "transaction/withdraw"]
   * @param events             events string to unsubscribe
   * @param unSubscribeOptions additional options to unsubscribe
   */
  kony.sdk.prototype.unSubscribeServerEvents = function(events, unSubscribeOptions) {
    if (!isServerEventsCallbackAssigned()) {
      kony.sdk.logsdk.error(TAG + "unSubscribeServerEvents:: " + kony.sdk.websocket.constants.SERVER_EVENTS_CALLBACKS_ERROR_MESSAGE);
      return;
    }
    if (kony.sdk.util.isNullOrUndefinedOrEmptyObject(unSubscribeOptions)) {
      unSubscribeOptions = {};
    }
    if (!kony.sdk.isNetworkAvailable()) {
      kony.sdk.logsdk.error(TAG + "unSubscribeServerEvents:: " + kony.sdk.websocket.constants.SERVER_EVENTS_NO_INTERNET_MESSAGE);
      callbackErrorInvoker(kony.sdk.websocket.constants.WEBSOCKET_TYPE_ONERROR, kony.sdk.websocket.constants.SERVER_EVENTS_NO_INTERNET_MESSAGE, onErrorCallback);
      return;
    }
    if (kony.sdk.websocket && !kony.sdk.websocket.isWebSocketAvailable()) {
      kony.sdk.logsdk.error(TAG + "unSubscribeServerEvents:: " + kony.sdk.websocket.constants.SERVER_EVENTS_NOT_INITIALISED_MESSAGE);
      callbackErrorInvoker(kony.sdk.websocket.constants.WEBSOCKET_TYPE_ONERROR, kony.sdk.websocket.constants.SERVER_EVENTS_NOT_INITIALISED_MESSAGE, onErrorCallback);
      return;
    }
    var eventsString = null;
    if (!kony.sdk.util.isNullOrUndefinedOrEmptyObject(unSubscribeOptions[kony.sdk.websocket.constants.UNSUBSCRIBE_OPTION_CLOSE_CONNECTION])) {
      if (!isOncloseConnectionValid(unSubscribeOptions[kony.sdk.websocket.constants.UNSUBSCRIBE_OPTION_CLOSE_CONNECTION])) {
        kony.sdk.logsdk.error(TAG + "unSubscribeServerEvents:: CloseConnection value type is invalid.");
        callbackErrorInvoker(kony.sdk.websocket.constants.WEBSOCKET_TYPE_ONERROR, "CloseConnection value type is invalid.", onErrorCallback);
        return;
      }
      if (unSubscribeOptions[kony.sdk.websocket.constants.UNSUBSCRIBE_OPTION_CLOSE_CONNECTION] === kony.sdk.websocket.constants.BOOLEAN_TRUE) {
        kony.sdk.logsdk.info(TAG + "unSubscribeServerEvents:: Closing the webSocket connection.");
        kony.sdk.websocket.unSubscribeServerEvents(eventsString, null, unSubscribeOptions);
        return;
      }
    }
    if (!kony.sdk.util.isNullOrUndefinedOrEmptyObject(events)) {
      var mode = segregateEventModes(unSubscribeOptions, kony.sdk.websocket.constants.WEBSOCKET_UNSUBSCRIBE_EVENTS);
      if (kony.sdk.isNullOrUndefined(mode)) {
        kony.sdk.logsdk.error(TAG + "unSubscribeServerEvents:: Event mode passed is not valid.");
        callbackErrorInvoker(kony.sdk.websocket.constants.WEBSOCKET_TYPE_ONERROR, kony.sdk.websocket.constants.INVALID_MODE_PROVIDED_MESSAGE, onErrorCallback);
        return;
      }
      kony.sdk.claimsRefresh(function() {
        eventsString = createEventsPayloadString(events, mode, kony.sdk.websocket.constants.WEBSOCKET_UNSUBSCRIBE_EVENTS);
        if (kony.sdk.isNullOrUndefined(eventsString)) {
          kony.sdk.logsdk.error(TAG + "unSubscribeServerEvents:: Event string passed is not valid.");
          callbackErrorInvoker(kony.sdk.websocket.constants.WEBSOCKET_TYPE_ONERROR, kony.sdk.websocket.constants.INVALID_EVENT_STRING_MESSAGE, onErrorCallback);
          return;
        }
        if (isOptionObjectValid(unSubscribeOptions.onUnsubscribeCallback)) {
          kony.sdk.websocket.unSubscribeServerEvents(eventsString, unSubscribeOptions.onUnsubscribeCallback, unSubscribeOptions);
        } else {
          kony.sdk.websocket.unSubscribeServerEvents(eventsString, null, unSubscribeOptions);
        }
      }, function(error) {
        kony.sdk.logsdk.error(TAG + "unSubscribeServerEvents::onFailure Error:", error);
        callbackErrorInvoker(kony.sdk.websocket.constants.WEBSOCKET_TYPE_ONERROR, error, onErrorCallback);
      });
    } else {
      kony.sdk.logsdk.error(TAG + "unSubscribeServerEvents:: Events to be unsubscribed for are null or undefined or empty.");
      callbackErrorInvoker(kony.sdk.websocket.constants.WEBSOCKET_TYPE_ONERROR, "Events to be Unsubscribed are null or undefined or empty.", onErrorCallback);
      return;
    }
  };
  // Initialise serverEvents
  initializeWebSocketConstants();
  initializeWebSocketHandler();
  initializeWebSocketManager();
  initializeWebSocketResponseMessage();
  initializeWebSocketResponseHandler();
}